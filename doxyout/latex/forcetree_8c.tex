\hypertarget{forcetree_8c}{
\section{forcetree.c File Reference}
\label{forcetree_8c}\index{forcetree.c@{forcetree.c}}
}


gravitational tree and code for Ewald correction  


{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$time.h$>$}\par
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include \char`\"{}allvars.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}proto.h\char`\"{}}\par
Include dependency graph for forcetree.c:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c__incl}
\end{center}
\end{figure}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{forcetree_8c_a0e93cfb2d62849853fd34957ba6e6fdc}{NTAB}~1000
\item 
\#define \hyperlink{forcetree_8c_a1094686c363ae3a70dca627763873649}{NEAREST}(x)~(((x)$>$boxhalf)?((x)-\/boxsize):(((x)$<$-\/boxhalf)?((x)+boxsize):(x)))
\item 
\#define \hyperlink{forcetree_8c_a22e6626f2c98ed902f8ded47f6438c05}{EN}~64
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{forcetree_8c_a10f92098e86f82baec9f84a283f4c9e5}{force\_\-treebuild} (int npart)
\item 
int \hyperlink{forcetree_8c_aadc9b1624ed78f3ccd0dbb9908fe0bb6}{force\_\-treebuild\_\-single} (int npart)
\item 
void \hyperlink{forcetree_8c_a8eaedfa5c6d72bca79b465003679ed89}{force\_\-create\_\-empty\_\-nodes} (int no, int topnode, int bits, int x, int y, int z, int $\ast$nodecount, int $\ast$nextfree)
\item 
void \hyperlink{forcetree_8c_ad9e0a57b7577d64a315c142e197d292d}{force\_\-insert\_\-pseudo\_\-particles} (void)
\item 
void \hyperlink{forcetree_8c_ab745c54c805d07ad255a3f86ff77e18d}{force\_\-update\_\-node\_\-recursive} (int no, int sib, int father)
\item 
void \hyperlink{forcetree_8c_af9a7e3a922557e089da5d7ee1dde89a0}{force\_\-update\_\-pseudoparticles} (void)
\item 
void \hyperlink{forcetree_8c_aaabf16b5e99c9ac6bc6bbe039756bddb}{force\_\-exchange\_\-pseudodata} (void)
\item 
void \hyperlink{forcetree_8c_ab8e5d4fed349d96c6d4f55897473ce19}{force\_\-treeupdate\_\-pseudos} (void)
\item 
void \hyperlink{forcetree_8c_a947a734f3bbba14d4092c7480880d3c7}{force\_\-flag\_\-localnodes} (void)
\item 
void \hyperlink{forcetree_8c_a04fb647ef783d5baeb9275d806c08365}{force\_\-update\_\-len} (void)
\item 
void \hyperlink{forcetree_8c_a4592b750f8555f580691103acf1e5366}{force\_\-update\_\-node\_\-len\_\-local} (void)
\item 
void \hyperlink{forcetree_8c_a5f85438d619d63c812c8e05faf1f0074}{force\_\-update\_\-node\_\-len\_\-toptree} (void)
\item 
void \hyperlink{forcetree_8c_a4764c1fb83a956c1712345538630854c}{force\_\-update\_\-hmax} (void)
\item 
void \hyperlink{forcetree_8c_a4c108b1da2bc4f2620f62aeab90c1074}{force\_\-update\_\-node\_\-hmax\_\-local} (void)
\item 
void \hyperlink{forcetree_8c_ac3f5945bb7c73936ef49af1507265afe}{force\_\-update\_\-node\_\-hmax\_\-toptree} (void)
\item 
int \hyperlink{forcetree_8c_a59ae74ef51d6a7065605638422489391}{force\_\-treeevaluate} (int target, int mode, double $\ast$ewaldcountsum)
\item 
int \hyperlink{forcetree_8c_ae01e179b7686a7fe62970160b7bbdb46}{force\_\-treeevaluate\_\-shortrange} (int target, int mode)
\item 
int \hyperlink{forcetree_8c_ab6894fe5ae268ea8f6bc7c4a8c87a87f}{force\_\-treeevaluate\_\-ewald\_\-correction} (int target, int mode, double pos\_\-x, double pos\_\-y, double pos\_\-z, double aold)
\item 
void \hyperlink{forcetree_8c_af29d257a1e4545ba4b9c3648444979b6}{force\_\-treeevaluate\_\-potential} (int target, int mode)
\item 
void \hyperlink{forcetree_8c_abd9d86a6c08e77a4fa78fa76b96cdde7}{force\_\-treeevaluate\_\-potential\_\-shortrange} (int target, int mode)
\item 
void \hyperlink{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2}{force\_\-treeallocate} (int maxnodes, int maxpart)
\item 
void \hyperlink{forcetree_8c_a0a9667f530dad09ebed8c0c98e5d3888}{force\_\-treefree} (void)
\item 
int \hyperlink{forcetree_8c_a0ec221b2517893874b12dc366bfe0da8}{force\_\-treeevaluate\_\-direct} (int target, int mode)
\item 
void \hyperlink{forcetree_8c_ab303b92c6d6b4144999c5cebabd65ec0}{dump\_\-particles} (void)
\item 
void \hyperlink{forcetree_8c_a47f99270d9b0b0f75d86b3b9d078dff6}{ewald\_\-init} (void)
\item 
void \hyperlink{forcetree_8c_ad8b8e212e593e1795f6ba522239086fc}{ewald\_\-corr} (double dx, double dy, double dz, double $\ast$fper)
\item 
double \hyperlink{forcetree_8c_aa0657e3de6bfb76715c14ddd72d25e58}{ewald\_\-pot\_\-corr} (double dx, double dy, double dz)
\item 
double \hyperlink{forcetree_8c_a4a219224b239f0c20497e54ae421f134}{ewald\_\-psi} (double x\mbox{[}3\mbox{]})
\item 
void \hyperlink{forcetree_8c_a49e4b7c0d57d0ab446b4ec38f3618925}{ewald\_\-force} (int iii, int jjj, int kkk, double x\mbox{[}3\mbox{]}, double force\mbox{[}3\mbox{]})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}{last}
\item 
static float \hyperlink{forcetree_8c_abe941030bf66a95df993b617bffefd9b}{tabfac}
\item 
static float \hyperlink{forcetree_8c_a76b621ce2fa9c17911a62495174029eb}{shortrange\_\-table} \mbox{[}1000\mbox{]}
\item 
static float \hyperlink{forcetree_8c_a196b7c27d03bd3ecc1259b2f67017fbe}{shortrange\_\-table\_\-potential} \mbox{[}1000\mbox{]}
\item 
static int \hyperlink{forcetree_8c_a37ea0ff529d9c7e76f1f7895bde01183}{first\_\-flag} = 0
\item 
static float \hyperlink{forcetree_8c_aa5cc9e7d836cdcf307f7640533e5e928}{fcorrx} \mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}
\item 
static float \hyperlink{forcetree_8c_ac7d44a9c9f475423540e3acd8bca75d3}{fcorry} \mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}
\item 
static float \hyperlink{forcetree_8c_aa4f6ad92e563dd2a0d0b324452b051f6}{fcorrz} \mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}
\item 
static float \hyperlink{forcetree_8c_a7a88fa4a0ea6d18436481c44288646a0}{potcorr} \mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}
\item 
static double \hyperlink{forcetree_8c_af6350369fa0c71cba122f936412fcb4d}{fac\_\-intp}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
gravitational tree and code for Ewald correction This file contains the computation of the gravitational force by means of a tree. The type of tree implemented is a geometrical oct-\/tree, starting from a cube encompassing all particles. This cube is automatically found in the domain decomposition, which also splits up the global \char`\"{}top-\/level\char`\"{} tree along node boundaries, moving the particles of different parts of the tree to separate processors. Tree nodes can be dynamically updated in drift/kick operations to avoid having to reconstruct the tree every timestep. 

Definition in file \hyperlink{forcetree_8c_source}{forcetree.c}.



\subsection{Define Documentation}
\hypertarget{forcetree_8c_a22e6626f2c98ed902f8ded47f6438c05}{
\index{forcetree.c@{forcetree.c}!EN@{EN}}
\index{EN@{EN}!forcetree.c@{forcetree.c}}
\subsubsection[{EN}]{\setlength{\rightskip}{0pt plus 5cm}\#define EN~64}}
\label{forcetree_8c_a22e6626f2c98ed902f8ded47f6438c05}
Size of 3D lock-\/up table for Ewald correction force 

Definition at line 45 of file forcetree.c.



Referenced by ewald\_\-corr(), ewald\_\-init(), ewald\_\-pot\_\-corr(), and force\_\-treeevaluate\_\-ewald\_\-correction().

\hypertarget{forcetree_8c_a1094686c363ae3a70dca627763873649}{
\index{forcetree.c@{forcetree.c}!NEAREST@{NEAREST}}
\index{NEAREST@{NEAREST}!forcetree.c@{forcetree.c}}
\subsubsection[{NEAREST}]{\setlength{\rightskip}{0pt plus 5cm}\#define NEAREST(
\begin{DoxyParamCaption}
\item[{}]{x}
\end{DoxyParamCaption}
)~(((x)$>$boxhalf)?((x)-\/boxsize):(((x)$<$-\/boxhalf)?((x)+boxsize):(x)))}}
\label{forcetree_8c_a1094686c363ae3a70dca627763873649}
Macro that maps a distance to the nearest periodic neighbour 

Definition at line 43 of file forcetree.c.



Referenced by force\_\-treeevaluate(), force\_\-treeevaluate\_\-ewald\_\-correction(), force\_\-treeevaluate\_\-potential(), force\_\-treeevaluate\_\-potential\_\-shortrange(), and force\_\-treeevaluate\_\-shortrange().

\hypertarget{forcetree_8c_a0e93cfb2d62849853fd34957ba6e6fdc}{
\index{forcetree.c@{forcetree.c}!NTAB@{NTAB}}
\index{NTAB@{NTAB}!forcetree.c@{forcetree.c}}
\subsubsection[{NTAB}]{\setlength{\rightskip}{0pt plus 5cm}\#define NTAB~1000}}
\label{forcetree_8c_a0e93cfb2d62849853fd34957ba6e6fdc}
length of lock-\/up table for short-\/range force kernel in TreePM algorithm 

Definition at line 31 of file forcetree.c.



Referenced by force\_\-treeallocate(), force\_\-treeevaluate\_\-potential\_\-shortrange(), and force\_\-treeevaluate\_\-shortrange().



\subsection{Function Documentation}
\hypertarget{forcetree_8c_ab303b92c6d6b4144999c5cebabd65ec0}{
\index{forcetree.c@{forcetree.c}!dump\_\-particles@{dump\_\-particles}}
\index{dump\_\-particles@{dump\_\-particles}!forcetree.c@{forcetree.c}}
\subsubsection[{dump\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void dump\_\-particles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ab303b92c6d6b4144999c5cebabd65ec0}
This function dumps some of the basic particle data to a file. In case the tree construction fails, it is called just before the run terminates with an error message. Examination of the generated file may then give clues to what caused the problem. 

Definition at line 3040 of file forcetree.c.



References fd, FLOAT, my\_\-fwrite(), NumPart, P, and ThisTask.



Referenced by force\_\-create\_\-empty\_\-nodes(), and force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  FILE *fd;
  char buffer[200];
  int i;

  sprintf(buffer, "particles%d.dat", ThisTask);
  fd = fopen(buffer, "w");
  my_fwrite(&NumPart, 1, sizeof(int), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].Pos[0], 3, sizeof(FLOAT), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].Vel[0], 3, sizeof(FLOAT), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].ID, 1, sizeof(int), fd);

  fclose(fd);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab303b92c6d6b4144999c5cebabd65ec0_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab303b92c6d6b4144999c5cebabd65ec0_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ad8b8e212e593e1795f6ba522239086fc}{
\index{forcetree.c@{forcetree.c}!ewald\_\-corr@{ewald\_\-corr}}
\index{ewald\_\-corr@{ewald\_\-corr}!forcetree.c@{forcetree.c}}
\subsubsection[{ewald\_\-corr}]{\setlength{\rightskip}{0pt plus 5cm}void ewald\_\-corr (
\begin{DoxyParamCaption}
\item[{double}]{ dx, }
\item[{double}]{ dy, }
\item[{double}]{ dz, }
\item[{double $\ast$}]{ fper}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ad8b8e212e593e1795f6ba522239086fc}
This function looks up the correction force due to the infinite number of periodic particle/node images. We here use trilinear interpolation to get it from the precomputed tables, which contain one octant around the target particle at the origin. The other octants are obtained from it by exploiting the symmetry properties. 

Definition at line 3228 of file forcetree.c.



References EN, fac\_\-intp, fcorrx, fcorry, fcorrz, and NODE::u.



Referenced by force\_\-treeevaluate\_\-direct().




\begin{DoxyCode}
{
  int signx, signy, signz;
  int i, j, k;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;

  if(dx < 0)
    {
      dx = -dx;
      signx = +1;
    }
  else
    signx = -1;

  if(dy < 0)
    {
      dy = -dy;
      signy = +1;
    }
  else
    signy = -1;

  if(dz < 0)
    {
      dz = -dz;
      signz = +1;
    }
  else
    signz = -1;

  u = dx * fac_intp;
  i = (int) u;
  if(i >= EN)
    i = EN - 1;
  u -= i;
  v = dy * fac_intp;
  j = (int) v;
  if(j >= EN)
    j = EN - 1;
  v -= j;
  w = dz * fac_intp;
  k = (int) w;
  if(k >= EN)
    k = EN - 1;
  w -= k;

  f1 = (1 - u) * (1 - v) * (1 - w);
  f2 = (1 - u) * (1 - v) * (w);
  f3 = (1 - u) * (v) * (1 - w);
  f4 = (1 - u) * (v) * (w);
  f5 = (u) * (1 - v) * (1 - w);
  f6 = (u) * (1 - v) * (w);
  f7 = (u) * (v) * (1 - w);
  f8 = (u) * (v) * (w);

  fper[0] = signx * (fcorrx[i][j][k] * f1 +
                     fcorrx[i][j][k + 1] * f2 +
                     fcorrx[i][j + 1][k] * f3 +
                     fcorrx[i][j + 1][k + 1] * f4 +
                     fcorrx[i + 1][j][k] * f5 +
                     fcorrx[i + 1][j][k + 1] * f6 +
                     fcorrx[i + 1][j + 1][k] * f7 + fcorrx[i + 1][j + 1][k + 1] *
       f8);

  fper[1] = signy * (fcorry[i][j][k] * f1 +
                     fcorry[i][j][k + 1] * f2 +
                     fcorry[i][j + 1][k] * f3 +
                     fcorry[i][j + 1][k + 1] * f4 +
                     fcorry[i + 1][j][k] * f5 +
                     fcorry[i + 1][j][k + 1] * f6 +
                     fcorry[i + 1][j + 1][k] * f7 + fcorry[i + 1][j + 1][k + 1] *
       f8);

  fper[2] = signz * (fcorrz[i][j][k] * f1 +
                     fcorrz[i][j][k + 1] * f2 +
                     fcorrz[i][j + 1][k] * f3 +
                     fcorrz[i][j + 1][k + 1] * f4 +
                     fcorrz[i + 1][j][k] * f5 +
                     fcorrz[i + 1][j][k + 1] * f6 +
                     fcorrz[i + 1][j + 1][k] * f7 + fcorrz[i + 1][j + 1][k + 1] *
       f8);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ad8b8e212e593e1795f6ba522239086fc_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a49e4b7c0d57d0ab446b4ec38f3618925}{
\index{forcetree.c@{forcetree.c}!ewald\_\-force@{ewald\_\-force}}
\index{ewald\_\-force@{ewald\_\-force}!forcetree.c@{forcetree.c}}
\subsubsection[{ewald\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void ewald\_\-force (
\begin{DoxyParamCaption}
\item[{int}]{ iii, }
\item[{int}]{ jjj, }
\item[{int}]{ kkk, }
\item[{double}]{ x\mbox{[}3\mbox{]}, }
\item[{double}]{ force\mbox{[}3\mbox{]}}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a49e4b7c0d57d0ab446b4ec38f3618925}
This function computes the force correction term (difference between full force of infinite lattice and nearest image) by Ewald summation. 

Definition at line 3411 of file forcetree.c.



Referenced by ewald\_\-init().




\begin{DoxyCode}
{
  double alpha, r2;
  double r, val, hdotx, dx[3];
  int i, h[3], n[3], h2;

  alpha = 2.0;

  for(i = 0; i < 3; i++)
    force[i] = 0;

  if(iii == 0 && jjj == 0 && kkk == 0)
    return;

  r2 = x[0] * x[0] + x[1] * x[1] + x[2] * x[2];

  for(i = 0; i < 3; i++)
    force[i] += x[i] / (r2 * sqrt(r2));

  for(n[0] = -4; n[0] <= 4; n[0]++)
    for(n[1] = -4; n[1] <= 4; n[1]++)
      for(n[2] = -4; n[2] <= 4; n[2]++)
        {
          for(i = 0; i < 3; i++)
            dx[i] = x[i] - n[i];

          r = sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);

          val = erfc(alpha * r) + 2 * alpha * r / sqrt(M_PI) * exp(-alpha * alpha
       * r * r);

          for(i = 0; i < 3; i++)
            force[i] -= dx[i] / (r * r * r) * val;
        }

  for(h[0] = -4; h[0] <= 4; h[0]++)
    for(h[1] = -4; h[1] <= 4; h[1]++)
      for(h[2] = -4; h[2] <= 4; h[2]++)
        {
          hdotx = x[0] * h[0] + x[1] * h[1] + x[2] * h[2];
          h2 = h[0] * h[0] + h[1] * h[1] + h[2] * h[2];

          if(h2 > 0)
            {
              val = 2.0 / ((double) h2) * exp(-M_PI * M_PI * h2 / (alpha * alpha)
      ) * sin(2 * M_PI * hdotx);

              for(i = 0; i < 3; i++)
                force[i] -= h[i] * val;
            }
        }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a49e4b7c0d57d0ab446b4ec38f3618925_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a47f99270d9b0b0f75d86b3b9d078dff6}{
\index{forcetree.c@{forcetree.c}!ewald\_\-init@{ewald\_\-init}}
\index{ewald\_\-init@{ewald\_\-init}!forcetree.c@{forcetree.c}}
\subsubsection[{ewald\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void ewald\_\-init (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a47f99270d9b0b0f75d86b3b9d078dff6}
This function initializes tables with the correction force and the correction potential due to the periodic images of a point mass located at the origin. These corrections are obtained by Ewald summation. (See Hernquist, Bouchet, Suto, ApJS, 1991, 75, 231) The correction fields are used to obtain the full periodic force if periodic boundaries combined with the pure tree algorithm are used. For the TreePM algorithm, the Ewald correction is not used.

The correction fields are stored on disk once they are computed. If a corresponding file is found, they are loaded from disk to speed up the initialization. The Ewald summation is done in parallel, i.e. the processors share the work to compute the tables if needed. 

Definition at line 3079 of file forcetree.c.



References All, global\_\-data\_\-all\_\-processes::BoxSize, EN, ewald\_\-force(), ewald\_\-psi(), fac\_\-intp, fcorrx, fcorry, fcorrz, fd, FLOAT, NODE::len, my\_\-fread(), my\_\-fwrite(), NTask, potcorr, and ThisTask.



Referenced by begrun().




\begin{DoxyCode}
{
  int i, j, k, beg, len, size, n, task, count;
  double x[3], force[3];
  char buf[200];
  FILE *fd;

  if(ThisTask == 0)
    {
      printf("initialize Ewald correction...\n");
      fflush(stdout);
    }

#ifdef DOUBLEPRECISION
  sprintf(buf, "ewald_spc_table_%d_dbl.dat", EN);
#else
  sprintf(buf, "ewald_spc_table_%d.dat", EN);
#endif

  if((fd = fopen(buf, "r")))
    {
      if(ThisTask == 0)
        {
          printf("\nreading Ewald tables from file `%s'\n", buf);
          fflush(stdout);
        }

      my_fread(&fcorrx[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), f
      d);
      my_fread(&fcorry[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), f
      d);
      my_fread(&fcorrz[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), f
      d);
      my_fread(&potcorr[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), 
      fd);
      fclose(fd);
    }
  else
    {
      if(ThisTask == 0)
        {
          printf("\nNo Ewald tables in file `%s' found.\nRecomputing them...\n", 
      buf);
          fflush(stdout);
        }

      /* ok, let's recompute things. Actually, we do that in parallel. */

      size = (EN + 1) * (EN + 1) * (EN + 1) / NTask;


      beg = ThisTask * size;
      len = size;
      if(ThisTask == (NTask - 1))
        len = (EN + 1) * (EN + 1) * (EN + 1) - beg;

      for(i = 0, count = 0; i <= EN; i++)
        for(j = 0; j <= EN; j++)
          for(k = 0; k <= EN; k++)
            {
              n = (i * (EN + 1) + j) * (EN + 1) + k;
              if(n >= beg && n < (beg + len))
                {
                  if(ThisTask == 0)
                    {
                      if((count % (len / 20)) == 0)
                        {
                          printf("%4.1f percent done\n", count / (len / 100.0));
                          fflush(stdout);
                        }
                    }

                  x[0] = 0.5 * ((double) i) / EN;
                  x[1] = 0.5 * ((double) j) / EN;
                  x[2] = 0.5 * ((double) k) / EN;

                  ewald_force(i, j, k, x, force);

                  fcorrx[i][j][k] = force[0];
                  fcorry[i][j][k] = force[1];
                  fcorrz[i][j][k] = force[2];

                  if(i + j + k == 0)
                    potcorr[i][j][k] = 2.8372975;
                  else
                    potcorr[i][j][k] = ewald_psi(x);

                  count++;
                }
            }

      for(task = 0; task < NTask; task++)
        {
          beg = task * size;
          len = size;
          if(task == (NTask - 1))
            len = (EN + 1) * (EN + 1) * (EN + 1) - beg;

#ifdef DOUBLEPRECISION
          MPI_Bcast(&fcorrx[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorry[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorrz[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&potcorr[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
#else
          MPI_Bcast(&fcorrx[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorry[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorrz[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&potcorr[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
#endif
        }

      if(ThisTask == 0)
        {
          printf("\nwriting Ewald tables to file `%s'\n", buf);
          fflush(stdout);

          if((fd = fopen(buf, "w")))
            {
              my_fwrite(&fcorrx[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              my_fwrite(&fcorry[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              my_fwrite(&fcorrz[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              my_fwrite(&potcorr[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              fclose(fd);
            }
        }
    }

  fac_intp = 2 * EN / All.BoxSize;

  for(i = 0; i <= EN; i++)
    for(j = 0; j <= EN; j++)
      for(k = 0; k <= EN; k++)
        {
          potcorr[i][j][k] /= All.BoxSize;
          fcorrx[i][j][k] /= All.BoxSize * All.BoxSize;
          fcorry[i][j][k] /= All.BoxSize * All.BoxSize;
          fcorrz[i][j][k] /= All.BoxSize * All.BoxSize;
        }

  if(ThisTask == 0)
    {
      printf("initialization of periodic boundaries finished.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a47f99270d9b0b0f75d86b3b9d078dff6_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{forcetree_8c_a47f99270d9b0b0f75d86b3b9d078dff6_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_aa0657e3de6bfb76715c14ddd72d25e58}{
\index{forcetree.c@{forcetree.c}!ewald\_\-pot\_\-corr@{ewald\_\-pot\_\-corr}}
\index{ewald\_\-pot\_\-corr@{ewald\_\-pot\_\-corr}!forcetree.c@{forcetree.c}}
\subsubsection[{ewald\_\-pot\_\-corr}]{\setlength{\rightskip}{0pt plus 5cm}double ewald\_\-pot\_\-corr (
\begin{DoxyParamCaption}
\item[{double}]{ dx, }
\item[{double}]{ dy, }
\item[{double}]{ dz}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_aa0657e3de6bfb76715c14ddd72d25e58}
This function looks up the correction potential due to the infinite number of periodic particle/node images. We here use tri-\/linear interpolation to get it from the precomputed table, which contains one octant around the target particle at the origin. The other octants are obtained from it by exploiting symmetry properties. 

Definition at line 3317 of file forcetree.c.



References EN, fac\_\-intp, potcorr, and NODE::u.



Referenced by force\_\-treeevaluate\_\-potential().




\begin{DoxyCode}
{
  int i, j, k;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;

  if(dx < 0)
    dx = -dx;

  if(dy < 0)
    dy = -dy;

  if(dz < 0)
    dz = -dz;

  u = dx * fac_intp;
  i = (int) u;
  if(i >= EN)
    i = EN - 1;
  u -= i;
  v = dy * fac_intp;
  j = (int) v;
  if(j >= EN)
    j = EN - 1;
  v -= j;
  w = dz * fac_intp;
  k = (int) w;
  if(k >= EN)
    k = EN - 1;
  w -= k;

  f1 = (1 - u) * (1 - v) * (1 - w);
  f2 = (1 - u) * (1 - v) * (w);
  f3 = (1 - u) * (v) * (1 - w);
  f4 = (1 - u) * (v) * (w);
  f5 = (u) * (1 - v) * (1 - w);
  f6 = (u) * (1 - v) * (w);
  f7 = (u) * (v) * (1 - w);
  f8 = (u) * (v) * (w);

  return potcorr[i][j][k] * f1 +
    potcorr[i][j][k + 1] * f2 +
    potcorr[i][j + 1][k] * f3 +
    potcorr[i][j + 1][k + 1] * f4 +
    potcorr[i + 1][j][k] * f5 +
    potcorr[i + 1][j][k + 1] * f6 + potcorr[i + 1][j + 1][k] * f7 + potcorr[i + 1
      ][j + 1][k + 1] * f8;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_aa0657e3de6bfb76715c14ddd72d25e58_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a4a219224b239f0c20497e54ae421f134}{
\index{forcetree.c@{forcetree.c}!ewald\_\-psi@{ewald\_\-psi}}
\index{ewald\_\-psi@{ewald\_\-psi}!forcetree.c@{forcetree.c}}
\subsubsection[{ewald\_\-psi}]{\setlength{\rightskip}{0pt plus 5cm}double ewald\_\-psi (
\begin{DoxyParamCaption}
\item[{double}]{ x\mbox{[}3\mbox{]}}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a4a219224b239f0c20497e54ae421f134}
This function computes the potential correction term by means of Ewald summation. 

Definition at line 3370 of file forcetree.c.



Referenced by ewald\_\-init().




\begin{DoxyCode}
{
  double alpha, psi;
  double r, sum1, sum2, hdotx;
  double dx[3];
  int i, n[3], h[3], h2;

  alpha = 2.0;

  for(n[0] = -4, sum1 = 0; n[0] <= 4; n[0]++)
    for(n[1] = -4; n[1] <= 4; n[1]++)
      for(n[2] = -4; n[2] <= 4; n[2]++)
        {
          for(i = 0; i < 3; i++)
            dx[i] = x[i] - n[i];

          r = sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);
          sum1 += erfc(alpha * r) / r;
        }

  for(h[0] = -4, sum2 = 0; h[0] <= 4; h[0]++)
    for(h[1] = -4; h[1] <= 4; h[1]++)
      for(h[2] = -4; h[2] <= 4; h[2]++)
        {
          hdotx = x[0] * h[0] + x[1] * h[1] + x[2] * h[2];
          h2 = h[0] * h[0] + h[1] * h[1] + h[2] * h[2];
          if(h2 > 0)
            sum2 += 1 / (M_PI * h2) * exp(-M_PI * M_PI * h2 / (alpha * alpha)) * 
      cos(2 * M_PI * hdotx);
        }

  r = sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);

  psi = M_PI / (alpha * alpha) - sum1 - sum2 + 1 / r;

  return psi;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a4a219224b239f0c20497e54ae421f134_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a8eaedfa5c6d72bca79b465003679ed89}{
\index{forcetree.c@{forcetree.c}!force\_\-create\_\-empty\_\-nodes@{force\_\-create\_\-empty\_\-nodes}}
\index{force\_\-create\_\-empty\_\-nodes@{force\_\-create\_\-empty\_\-nodes}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-create\_\-empty\_\-nodes}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-create\_\-empty\_\-nodes (
\begin{DoxyParamCaption}
\item[{int}]{ no, }
\item[{int}]{ topnode, }
\item[{int}]{ bits, }
\item[{int}]{ x, }
\item[{int}]{ y, }
\item[{int}]{ z, }
\item[{int $\ast$}]{ nodecount, }
\item[{int $\ast$}]{ nextfree}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a8eaedfa5c6d72bca79b465003679ed89}
This function recursively creates a set of empty tree nodes which corresponds to the top-\/level tree for the domain grid. This is done to ensure that this top-\/level tree is always \char`\"{}complete\char`\"{} so that we can easily associate the pseudo-\/particles of other CPUs with tree-\/nodes at a given level in the tree, even when the particle population is so sparse that some of these nodes are actually empty. 

Definition at line 292 of file forcetree.c.



References NODE::center, topnode\_\-data::Daughter, DomainNodeIndex, dump\_\-particles(), endrun(), force\_\-create\_\-empty\_\-nodes(), topnode\_\-data::Leaf, NODE::len, MaxNodes, Nodes, peano\_\-hilbert\_\-key(), NODE::suns, ThisTask, TopNodes, and NODE::u.



Referenced by force\_\-create\_\-empty\_\-nodes(), and force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  int i, j, k, n, sub, count;

  if(TopNodes[topnode].Daughter >= 0)
    {
      for(i = 0; i < 2; i++)
        for(j = 0; j < 2; j++)
          for(k = 0; k < 2; k++)
            {
              sub = 7 & peano_hilbert_key((x << 1) + i, (y << 1) + j, (z << 1) + 
      k, bits);

              count = i + 2 * j + 4 * k;

              Nodes[no].u.suns[count] = *nextfree;


              Nodes[*nextfree].len = 0.5 * Nodes[no].len;
              Nodes[*nextfree].center[0] = Nodes[no].center[0] + (2 * i - 1) * 0.
      25 * Nodes[no].len;
              Nodes[*nextfree].center[1] = Nodes[no].center[1] + (2 * j - 1) * 0.
      25 * Nodes[no].len;
              Nodes[*nextfree].center[2] = Nodes[no].center[2] + (2 * k - 1) * 0.
      25 * Nodes[no].len;

              for(n = 0; n < 8; n++)
                Nodes[*nextfree].u.suns[n] = -1;

              if(TopNodes[TopNodes[topnode].Daughter + sub].Daughter == -1)
                DomainNodeIndex[TopNodes[TopNodes[topnode].Daughter + sub].Leaf] 
      = *nextfree;

              *nextfree = *nextfree + 1;
              *nodecount = *nodecount + 1;

              if((*nodecount) >= MaxNodes)
                {
                  printf("task %d: maximum number %d of tree-nodes reached.\n", 
      ThisTask, MaxNodes);
                  printf("in create empty nodes\n");
                  dump_particles();
                  endrun(11);
                }

              force_create_empty_nodes(*nextfree - 1, TopNodes[topnode].Daughter 
      + sub,
                                       bits + 1, 2 * x + i, 2 * y + j, 2 * z + k,
       nodecount, nextfree);
            }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a8eaedfa5c6d72bca79b465003679ed89_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a8eaedfa5c6d72bca79b465003679ed89_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_aaabf16b5e99c9ac6bc6bbe039756bddb}{
\index{forcetree.c@{forcetree.c}!force\_\-exchange\_\-pseudodata@{force\_\-exchange\_\-pseudodata}}
\index{force\_\-exchange\_\-pseudodata@{force\_\-exchange\_\-pseudodata}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-exchange\_\-pseudodata}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-exchange\_\-pseudodata (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_aaabf16b5e99c9ac6bc6bbe039756bddb}
This function communicates the values of the multipole moments of the top-\/level tree-\/nodes of the domain grid. This data can then be used to update the pseudo-\/particles on each CPU accordingly. 

Definition at line 684 of file forcetree.c.



References NODE::d, DomainEndList, DomainMoment, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, Extnodes, DomainNODE::mass, Nodes, NTask, PTask, DomainNODE::s, TAG\_\-DMOM, ThisTask, NODE::u, extNODE::vs, and DomainNODE::vs.



Referenced by force\_\-update\_\-pseudoparticles().




\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      /* read out the multipole moments from the local base cells */
      DomainMoment[i].s[0] = Nodes[no].u.d.s[0];
      DomainMoment[i].s[1] = Nodes[no].u.d.s[1];
      DomainMoment[i].s[2] = Nodes[no].u.d.s[2];
      DomainMoment[i].vs[0] = Extnodes[no].vs[0];
      DomainMoment[i].vs[1] = Extnodes[no].vs[1];
      DomainMoment[i].vs[2] = Extnodes[no].vs[2];
      DomainMoment[i].mass = Nodes[no].u.d.mass;
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      DomainMoment[i].bitflags = Nodes[no].u.d.bitflags;
#else
      DomainMoment[i].maxsoft = Nodes[no].maxsoft;
#endif
#endif
    }

  /* share the pseudo-particle data accross CPUs */

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainMoment[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) * 
      sizeof(struct DomainNODE),
                     MPI_BYTE, recvTask, TAG_DMOM,
                     &DomainMoment[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) * 
      sizeof(struct DomainNODE),
                     MPI_BYTE, recvTask, TAG_DMOM, MPI_COMM_WORLD, &status);
    }

}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_aaabf16b5e99c9ac6bc6bbe039756bddb_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a947a734f3bbba14d4092c7480880d3c7}{
\index{forcetree.c@{forcetree.c}!force\_\-flag\_\-localnodes@{force\_\-flag\_\-localnodes}}
\index{force\_\-flag\_\-localnodes@{force\_\-flag\_\-localnodes}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-flag\_\-localnodes}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-flag\_\-localnodes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a947a734f3bbba14d4092c7480880d3c7}
This function flags nodes in the top-\/level tree that are dependent on local particle data. 

Definition at line 834 of file forcetree.c.



References NODE::d, DomainMyLast, DomainMyStart, DomainNodeIndex, Nodes, NTopleaves, and NODE::u.



Referenced by force\_\-treebuild().




\begin{DoxyCode}
{
  int no, i;

  /* mark all top-level nodes */

  for(i = 0; i < NTopleaves; i++)
    {
      no = DomainNodeIndex[i];

      while(no >= 0)
        {
          if((Nodes[no].u.d.bitflags & 1))
            break;

          Nodes[no].u.d.bitflags |= 1;

          no = Nodes[no].u.d.father;
        }
    }

  /* mark top-level nodes that contain local particles */

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      /*
         if(DomainMoment[i].mass > 0)
       */
      {
        no = DomainNodeIndex[i];

        while(no >= 0)
          {
            if((Nodes[no].u.d.bitflags & 2))
              break;

            Nodes[no].u.d.bitflags |= 2;

            no = Nodes[no].u.d.father;
          }
      }
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a947a734f3bbba14d4092c7480880d3c7_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ad9e0a57b7577d64a315c142e197d292d}{
\index{forcetree.c@{forcetree.c}!force\_\-insert\_\-pseudo\_\-particles@{force\_\-insert\_\-pseudo\_\-particles}}
\index{force\_\-insert\_\-pseudo\_\-particles@{force\_\-insert\_\-pseudo\_\-particles}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-insert\_\-pseudo\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-insert\_\-pseudo\_\-particles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ad9e0a57b7577d64a315c142e197d292d}
this function inserts pseudo-\/particles which will represent the mass distribution of the other CPUs. Initially, the mass of the pseudo-\/particles is set to zero, and their coordinate is set to the center of the domain-\/cell they correspond to. These quantities will be updated later on. 

Definition at line 346 of file forcetree.c.



References All, NODE::center, DomainMoment, DomainMyLast, DomainNodeIndex, endrun(), DomainNODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nodes, NTopleaves, NODE::s, DomainNODE::s, NODE::suns, and NODE::u.



Referenced by force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  int i, index, subnode, nn, th;

  for(i = 0; i < NTopleaves; i++)
    {
      index = DomainNodeIndex[i];

      DomainMoment[i].mass = 0;
      DomainMoment[i].s[0] = Nodes[index].center[0];
      DomainMoment[i].s[1] = Nodes[index].center[1];
      DomainMoment[i].s[2] = Nodes[index].center[2];
    }

  for(i = 0; i < NTopleaves; i++)
    {
      if(i < DomainMyStart || i > DomainMyLast)
        {
          th = All.MaxPart;     /* select index of first node in tree */

          while(1)
            {
              if(th >= All.MaxPart)     /* we are dealing with an internal node *
      /
                {
                  if(th >= All.MaxPart + MaxNodes)
                    endrun(888);        /* this can't be */

                  subnode = 0;
                  if(DomainMoment[i].s[0] > Nodes[th].center[0])
                    subnode += 1;
                  if(DomainMoment[i].s[1] > Nodes[th].center[1])
                    subnode += 2;
                  if(DomainMoment[i].s[2] > Nodes[th].center[2])
                    subnode += 4;

                  nn = Nodes[th].u.suns[subnode];

                  if(nn >= 0)   /* ok, something is in the daughter slot already,
       need to continue */
                    {
                      th = nn;
                    }
                  else
                    {
                      /* here we have found an empty slot where we can 
                       * attach the pseudo particle as a leaf 
                       */
                      Nodes[th].u.suns[subnode] = All.MaxPart + MaxNodes + i;

                      break;    /* done for this pseudo particle */
                    }
                }
              else
                {
                  endrun(889);  /* this can't be */
                }
            }
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ad9e0a57b7577d64a315c142e197d292d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ad9e0a57b7577d64a315c142e197d292d_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2}{
\index{forcetree.c@{forcetree.c}!force\_\-treeallocate@{force\_\-treeallocate}}
\index{force\_\-treeallocate@{force\_\-treeallocate}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeallocate}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeallocate (
\begin{DoxyParamCaption}
\item[{int}]{ maxnodes, }
\item[{int}]{ maxpart}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2}
This function allocates the memory used for storage of the tree and of auxiliary arrays needed for tree-\/walk and link-\/lists. Usually, maxnodes approximately equal to 0.7$\ast$maxpart is sufficient to store the tree for up to maxpart particles. 

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition 



Definition at line 2827 of file forcetree.c.



References All, endrun(), Extnodes, Extnodes\_\-base, Father, first\_\-flag, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, MAXTOPNODES, Nextnode, Nodes, Nodes\_\-base, NTAB, shortrange\_\-table, shortrange\_\-table\_\-potential, tabfac, ThisTask, and NODE::u.



Referenced by init(), pmforce\_\-periodic(), pmpotential\_\-periodic(), and restart().




\begin{DoxyCode}
{
  int i;
  size_t bytes;
  double allbytes = 0;
  double u;

  MaxNodes = maxnodes;

  if(!(Nodes_base = malloc(bytes = (MaxNodes + 1) * sizeof(struct NODE))))
    {
      printf("failed to allocate memory for %d tree-nodes (%g MB).\n", MaxNodes, 
      bytes / (1024.0 * 1024.0));
      endrun(3);
    }
  allbytes += bytes;

  if(!(Extnodes_base = malloc(bytes = (MaxNodes + 1) * sizeof(struct extNODE))))
    {
      printf("failed to allocate memory for %d tree-extnodes (%g MB).\n", 
      MaxNodes,
             bytes / (1024.0 * 1024.0));
      endrun(3);
    }
  allbytes += bytes;

  Nodes = Nodes_base - All.MaxPart;
  Extnodes = Extnodes_base - All.MaxPart;

  if(!(Nextnode = malloc(bytes = (maxpart + MAXTOPNODES) * sizeof(int))))
    {
      printf("Failed to allocate %d spaces for 'Nextnode' array (%g MB)\n", maxpa
      rt + MAXTOPNODES,
             bytes / (1024.0 * 1024.0));
      exit(0);
    }
  allbytes += bytes;

  if(!(Father = malloc(bytes = (maxpart) * sizeof(int))))
    {
      printf("Failed to allocate %d spaces for 'Father' array (%g MB)\n", maxpart
      , bytes / (1024.0 * 1024.0));
      exit(0);
    }
  allbytes += bytes;

  if(first_flag == 0)
    {
      first_flag = 1;

      if(ThisTask == 0)
        printf("\nAllocated %g MByte for BH-tree. %lu\n\n", allbytes / (1024.0 * 
      1024.0),
               sizeof(struct NODE) + sizeof(struct extNODE));

      tabfac = NTAB / 3.0;

      for(i = 0; i < NTAB; i++)
        {
          u = 3.0 / NTAB * (i + 0.5);
          shortrange_table[i] = erfc(u) + 2.0 * u / sqrt(M_PI) * exp(-u * u);
          shortrange_table_potential[i] = erfc(u);
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a10f92098e86f82baec9f84a283f4c9e5}{
\index{forcetree.c@{forcetree.c}!force\_\-treebuild@{force\_\-treebuild}}
\index{force\_\-treebuild@{force\_\-treebuild}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treebuild}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treebuild (
\begin{DoxyParamCaption}
\item[{int}]{ npart}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a10f92098e86f82baec9f84a283f4c9e5}
This function is a driver routine for constructing the gravitational oct-\/tree, which is done by calling a small number of other functions. 

Definition at line 61 of file forcetree.c.



References All, force\_\-flag\_\-localnodes(), force\_\-treebuild\_\-single(), force\_\-update\_\-pseudoparticles(), Numnodestree, global\_\-data\_\-all\_\-processes::Time, and TimeOfLastTreeConstruction.



Referenced by compute\_\-potential(), gravity\_\-tree(), and ngb\_\-treebuild().




\begin{DoxyCode}
{
  Numnodestree = force_treebuild_single(npart);

  force_update_pseudoparticles();

  force_flag_localnodes();

  TimeOfLastTreeConstruction = All.Time;

  return Numnodestree;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a10f92098e86f82baec9f84a283f4c9e5_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a10f92098e86f82baec9f84a283f4c9e5_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_aadc9b1624ed78f3ccd0dbb9908fe0bb6}{
\index{forcetree.c@{forcetree.c}!force\_\-treebuild\_\-single@{force\_\-treebuild\_\-single}}
\index{force\_\-treebuild\_\-single@{force\_\-treebuild\_\-single}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treebuild\_\-single}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treebuild\_\-single (
\begin{DoxyParamCaption}
\item[{int}]{ npart}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_aadc9b1624ed78f3ccd0dbb9908fe0bb6}
Constructs the gravitational oct-\/tree.

The index convention for accessing tree nodes is the following: the indices 0...NumPart-\/1 reference single particles, the indices All.MaxPart.... All.MaxPart+nodes-\/1 reference tree nodes. `Nodes\_\-base' points to the first tree node, while `nodes' is shifted such that nodes\mbox{[}All.MaxPart\mbox{]} gives the first tree node. Finally, node indices with values 'All.MaxPart + MaxNodes' and larger indicate \char`\"{}pseudo
  particles\char`\"{}, i.e. multipole moments of top-\/level nodes that lie on different CPUs. If such a node needs to be opened, the corresponding particle must be exported to that CPU. The 'Extnodes' structure parallels that of 'Nodes'. Its information is only needed for the SPH part of the computation. (The data is split onto these two structures as a tuning measure. If it is merged into 'Nodes' a somewhat bigger size of the nodes also for gravity would result, which would reduce cache utilization slightly. 

$<$ Bits per dimension available for Peano-\/Hilbert order. Note: If peanokey is defined 0 0 int, the allowed maximum is 10. If 64-\/bit integers are used, the maximum is 21 



Definition at line 93 of file forcetree.c.



References All, BITS\_\-PER\_\-DIMENSION, NODE::center, NODE::d, topnode\_\-data::Daughter, DomainCenter, DomainCorner, DomainFac, DomainLen, DomainNodeIndex, dump\_\-particles(), endrun(), force\_\-create\_\-empty\_\-nodes(), force\_\-insert\_\-pseudo\_\-particles(), force\_\-update\_\-node\_\-recursive(), global\_\-data\_\-all\_\-processes::ForceSoftening, get\_\-random\_\-number(), particle\_\-data::GravCost, last, topnode\_\-data::Leaf, NODE::len, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nextnode, Nodes, P, peano\_\-hilbert\_\-key(), topnode\_\-data::StartKey, NODE::suns, ThisTask, TopNodes, particle\_\-data::Type, and NODE::u.



Referenced by force\_\-treebuild().




\begin{DoxyCode}
{
  int i, j, subnode = 0, parent, numnodes;
  int nfree, th, nn, no;
  struct NODE *nfreep;
  double lenhalf, epsilon;
  peanokey key;


  /* create an empty root node  */
  nfree = All.MaxPart;          /* index of first free node */
  nfreep = &Nodes[nfree];       /* select first node */

  nfreep->len = DomainLen;
  for(j = 0; j < 3; j++)
    nfreep->center[j] = DomainCenter[j];
  for(j = 0; j < 8; j++)
    nfreep->u.suns[j] = -1;


  numnodes = 1;
  nfreep++;
  nfree++;

  /* create a set of empty nodes corresponding to the top-level domain
   * grid. We need to generate these nodes first to make sure that we have a
   * complete top-level tree which allows the easy insertion of the
   * pseudo-particles at the right place 
   */

  force_create_empty_nodes(All.MaxPart, 0, 1, 0, 0, 0, &numnodes, &nfree);


  /* if a high-resolution region in a global tree is used, we need to generate
   * an additional set empty nodes to make sure that we have a complete
   * top-level tree for the high-resolution inset
   */

  nfreep = &Nodes[nfree];
  parent = -1;                  /* note: will not be used below before it is chan
      ged */


  /* now we insert all particles */
  for(i = 0; i < npart; i++)
    {

      /* the softening is only used to check whether particles are so close
       * that the tree needs not to be refined further
       */
      epsilon = All.ForceSoftening[P[i].Type];

      key = peano_hilbert_key((P[i].Pos[0] - DomainCorner[0]) * DomainFac,
                              (P[i].Pos[1] - DomainCorner[1]) * DomainFac,
                              (P[i].Pos[2] - DomainCorner[2]) * DomainFac, 
      BITS_PER_DIMENSION);

      no = 0;
      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (key - TopNodes[no].StartKey) / (TopNodes[no
      ].Size / 8);

      no = TopNodes[no].Leaf;
      th = DomainNodeIndex[no];

      while(1)
        {
          if(th >= All.MaxPart) /* we are dealing with an internal node */
            {
              subnode = 0;
              if(P[i].Pos[0] > Nodes[th].center[0])
                subnode += 1;
              if(P[i].Pos[1] > Nodes[th].center[1])
                subnode += 2;
              if(P[i].Pos[2] > Nodes[th].center[2])
                subnode += 4;

              nn = Nodes[th].u.suns[subnode];

              if(nn >= 0)       /* ok, something is in the daughter slot already,
       need to continue */
                {
                  parent = th;
                  th = nn;
                }
              else
                {
                  /* here we have found an empty slot where we can attach
                   * the new particle as a leaf.
                   */
                  Nodes[th].u.suns[subnode] = i;
                  break;        /* done for this particle */
                }
            }
          else
            {
              /* We try to insert into a leaf with a single particle.  Need
               * to generate a new internal node at this point.
               */
              Nodes[parent].u.suns[subnode] = nfree;

              nfreep->len = 0.5 * Nodes[parent].len;
              lenhalf = 0.25 * Nodes[parent].len;

              if(subnode & 1)
                nfreep->center[0] = Nodes[parent].center[0] + lenhalf;
              else
                nfreep->center[0] = Nodes[parent].center[0] - lenhalf;

              if(subnode & 2)
                nfreep->center[1] = Nodes[parent].center[1] + lenhalf;
              else
                nfreep->center[1] = Nodes[parent].center[1] - lenhalf;

              if(subnode & 4)
                nfreep->center[2] = Nodes[parent].center[2] + lenhalf;
              else
                nfreep->center[2] = Nodes[parent].center[2] - lenhalf;

              nfreep->u.suns[0] = -1;
              nfreep->u.suns[1] = -1;
              nfreep->u.suns[2] = -1;
              nfreep->u.suns[3] = -1;
              nfreep->u.suns[4] = -1;
              nfreep->u.suns[5] = -1;
              nfreep->u.suns[6] = -1;
              nfreep->u.suns[7] = -1;


              subnode = 0;
              if(P[th].Pos[0] > nfreep->center[0])
                subnode += 1;
              if(P[th].Pos[1] > nfreep->center[1])
                subnode += 2;
              if(P[th].Pos[2] > nfreep->center[2])
                subnode += 4;
#ifndef NOTREERND
              if(nfreep->len < 1.0e-3 * epsilon)
                {
                  /* seems like we're dealing with particles at identical (or ext
      remely close)
                   * locations. Randomize subnode index to allow tree constructio
      n. Note: Multipole moments
                   * of tree are still correct, but this will only happen well be
      low gravitational softening
                   * length-scale anyway.
                   */
                  subnode = (int) (8.0 * get_random_number((0xffff & P[i].ID) + 
      P[i].GravCost));
                  P[i].GravCost += 1;
                  if(subnode >= 8)
                    subnode = 7;
                }
#endif
              nfreep->u.suns[subnode] = th;

              th = nfree;       /* resume trying to insert the new particle at
                                 * the newly created internal node
                                 */

              numnodes++;
              nfree++;
              nfreep++;

              if((numnodes) >= MaxNodes)
                {
                  printf("task %d: maximum number %d of tree-nodes reached.\n", 
      ThisTask, MaxNodes);
                  printf("for particle %d\n", i);
                  dump_particles();
                  endrun(1);
                }
            }
        }
    }


  /* insert the pseudo particles that represent the mass distribution of other do
      mains */
  force_insert_pseudo_particles();


  /* now compute the multipole moments recursively */
  last = -1;

  force_update_node_recursive(All.MaxPart, -1, -1);

  if(last >= All.MaxPart)
    {
      if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
        Nextnode[last - MaxNodes] = -1;
      else
        Nodes[last].u.d.nextnode = -1;
    }
  else
    Nextnode[last] = -1;

  return numnodes;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_aadc9b1624ed78f3ccd0dbb9908fe0bb6_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_aadc9b1624ed78f3ccd0dbb9908fe0bb6_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a59ae74ef51d6a7065605638422489391}{
\index{forcetree.c@{forcetree.c}!force\_\-treeevaluate@{force\_\-treeevaluate}}
\index{force\_\-treeevaluate@{force\_\-treeevaluate}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeevaluate}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode, }
\item[{double $\ast$}]{ ewaldcountsum}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a59ae74ef51d6a7065605638422489391}
This routine computes the gravitational force for a given local particle, or for a particle in the communication buffer. Depending on the value of TypeOfOpeningCriterion, either the geometrical BH cell-\/opening criterion, or the `relative' opening criterion is used. 

Definition at line 1126 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BoxSize, calculate\_\-interact\_\-kick(), NODE::center, check\_\-interaction\_\-table(), NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, FLOAT, force\_\-treeevaluate\_\-ewald\_\-correction(), global\_\-data\_\-all\_\-processes::ForceSoftening, get\_\-random\_\-number(), particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, particle\_\-data::ID, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, gravdata\_\-in::Ninteractions, Nodes, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, prob\_\-of\_\-interaction(), SphP, particle\_\-data::Ti\_\-begstep, particle\_\-data::Ti\_\-endstep, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, update\_\-interaction\_\-table(), particle\_\-data::Vel, and gravdata\_\-in::w.



Referenced by gravity\_\-tree().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ninteractions, ptype;
  double r2, dx, dy, dz, mass, r, fac, u, h, h_inv, h3_inv;
  double acc_x, acc_y, acc_z, pos_x, pos_y, pos_z, aold;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center,kick_x,kick_y,kick_z,kick_target[3],kick_no[3],prob;
  FLOAT  targetVel[3];
  int targetBegstep,targetEndstep;
  IDTYPE targetID;              
  int si_count,i;
  kick_x = 0;
  kick_y = 0;
  kick_z = 0;
  si_count = 0;
  if(mode == 0)
  {
    for(i=0;i<3;i++)
      targetVel[i] = P[target].Vel[i];
    targetBegstep = P[target].Ti_begstep;
    targetEndstep = P[target].Ti_endstep;
    targetID      = P[target].ID;
  }
  else
  {
    for(i=0;i<3;i++)
      targetVel[i] = GravDataGet[target].Vel[i];
    targetBegstep = GravDataGet[target].Ti_begstep;
    targetEndstep = GravDataGet[target].Ti_endstep;
    targetID      = GravDataGet[target].ID;
  }
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  ninteractions = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#ifdef COMPUTE_SELFINTERACTION_FORDARK      
      ptype = GravDataGet[target].Type;
#endif
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }



#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
  h3_inv = h_inv * h_inv * h_inv;
#endif
  no = All.MaxPart;             /* root node */

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;

          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }
          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;

          mass = nop->u.d.mass;
        }
#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node. Need to check openi
      ng criterion */
        {
          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can
                                                 * continue to do a short-cut */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
           /* check if any portion the cell lies withing the intercation range */
      
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#else

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* check in addition whether we lie inside the cell */

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#endif

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(986);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5 signals 
      that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif

          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        fac = mass / (r2 * r);
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
          h3_inv = h_inv * h_inv * h_inv;
#endif
          u = r * h_inv;
          if(u < 0.5)
            fac = mass * h3_inv * (10.666666666667 + u * u * (32.0 * u - 38.4));
          else
            fac =
              mass * h3_inv * (21.333333333333 - 48.0 * u +
                               38.4 * u * u - 10.666666666667 * u * u * u - 0.066
      666666667 / (u * u * u));
        }
      
        acc_x += dx * fac;
        acc_y += dy * fac;
        acc_z += dz * fac;

#ifdef COMPUTE_SELFINTERACTION_FORDARK
        if (no < All.MaxPart)
          {
            if ((ptype == 1 && P[no].Type == 4) || (ptype == 4 && P[no].Type == 1
      ) ) /*This line has been modified for the Test1. original: if (ptype == 1 && P[no
      ].Type == 1)*/
              {
                if (r < 2.0 * All.ForceSoftening[1] && check_interaction_table(ta
      rgetID,P[no].ID) == 0)
                  {
                    prob = prob_of_interaction(r, targetVel, P[no].Vel, targetBeg
      step, targetEndstep);
                    if (get_random_number(P[no].ID) < prob)
                      {
                        calculate_interact_kick(targetVel, P[no].Vel, kick_target
      , kick_no);
                        kick_x += kick_target[0];
                        kick_y += kick_target[1];
                        kick_z += kick_target[2];
                        for (i = 0; i < 3 ; i++)
                          P[no].Vel[i] += kick_no[i];
                        si_count+=1;
                        update_interaction_table(targetID,P[no].ID);
                      }
                  }
              }
          }
#endif
      ninteractions++;
    }
  
#ifdef COMPUTE_SELFINTERACTION_FORDARK 
  All.Nself_interactions += si_count;
#endif

  /* store result at the proper place */
  if(mode == 0)
    {
      P[target].GravAccel[0] = acc_x;
      P[target].GravAccel[1] = acc_y;
      P[target].GravAccel[2] = acc_z;
      P[target].GravCost = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      P[target].Vel[0] += kick_x;
      P[target].Vel[1] += kick_y;
      P[target].Vel[2] += kick_z;
#endif
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
      GravDataResult[target].w.Ninteractions = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      GravDataResult[target].Vel[0] = kick_x;
      GravDataResult[target].Vel[1] = kick_y;
      GravDataResult[target].Vel[2] = kick_z;
#endif
    }

#ifdef PERIODIC
  *ewaldcountsum += force_treeevaluate_ewald_correction(target, mode, pos_x, pos_
      y, pos_z, aold);
#endif

  return ninteractions;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a59ae74ef51d6a7065605638422489391_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a59ae74ef51d6a7065605638422489391_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a0ec221b2517893874b12dc366bfe0da8}{
\index{forcetree.c@{forcetree.c}!force\_\-treeevaluate\_\-direct@{force\_\-treeevaluate\_\-direct}}
\index{force\_\-treeevaluate\_\-direct@{force\_\-treeevaluate\_\-direct}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeevaluate\_\-direct}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate\_\-direct (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a0ec221b2517893874b12dc366bfe0da8}
This function does the force computation with direct summation for the specified particle in the communication buffer. This can be useful for debugging purposes, in particular for explicit checks of the force accuracy. 

Definition at line 2909 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BoxSize, dmax(), ewald\_\-corr(), global\_\-data\_\-all\_\-processes::ForceSoftening, particle\_\-data::GravAccelDirect, GravDataGet, GravDataResult, particle\_\-data::Mass, NumPart, P, gravdata\_\-in::Pos, particle\_\-data::Pos, particle\_\-data::Type, gravdata\_\-in::u, and NODE::u.



Referenced by gravity\_\-forcetest().




\begin{DoxyCode}
{
  double epsilon;
  double h, h_inv, dx, dy, dz, r, r2, u, r_inv, fac;
  int i, ptype;
  double pos_x, pos_y, pos_z;
  double acc_x, acc_y, acc_z;

#ifdef PERIODIC
  double fcorr[3];
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
    }

  for(i = 0; i < NumPart; i++)
    {
      epsilon = dmax(All.ForceSoftening[P[i].Type], All.ForceSoftening[ptype]);

      h = epsilon;
      h_inv = 1 / h;

      dx = P[i].Pos[0] - pos_x;
      dy = P[i].Pos[1] - pos_y;
      dz = P[i].Pos[2] - pos_z;

#ifdef PERIODIC
      while(dx > boxhalf)
        dx -= boxsize;
      while(dy > boxhalf)
        dy -= boxsize;
      while(dz > boxhalf)
        dz -= boxsize;
      while(dx < -boxhalf)
        dx += boxsize;
      while(dy < -boxhalf)
        dy += boxsize;
      while(dz < -boxhalf)
        dz += boxsize;
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      r = sqrt(r2);

      u = r * h_inv;

      if(u >= 1)
        {
          r_inv = 1 / r;

          fac = P[i].Mass * r_inv * r_inv * r_inv;
        }
      else
        {
          if(u < 0.5)
            fac = P[i].Mass * h_inv * h_inv * h_inv * (10.666666666667 + u * u * 
      (32.0 * u - 38.4));
          else
            fac =
              P[i].Mass * h_inv * h_inv * h_inv * (21.333333333333 -
                                                   48.0 * u + 38.4 * u * u -
                                                   10.666666666667 * u * u *
                                                   u - 0.066666666667 / (u * u * 
      u));
        }

      acc_x += dx * fac;
      acc_y += dy * fac;
      acc_z += dz * fac;

#ifdef PERIODIC
      if(u > 1.0e-5)
        {
          ewald_corr(dx, dy, dz, fcorr);

          acc_x += P[i].Mass * fcorr[0];
          acc_y += P[i].Mass * fcorr[1];
          acc_z += P[i].Mass * fcorr[2];
        }
#endif
    }


  if(mode == 0)
    {
      P[target].GravAccelDirect[0] = acc_x;
      P[target].GravAccelDirect[1] = acc_y;
      P[target].GravAccelDirect[2] = acc_z;
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
    }


  return NumPart;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{forcetree_8c_a0ec221b2517893874b12dc366bfe0da8_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a0ec221b2517893874b12dc366bfe0da8_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ab6894fe5ae268ea8f6bc7c4a8c87a87f}{
\index{forcetree.c@{forcetree.c}!force\_\-treeevaluate\_\-ewald\_\-correction@{force\_\-treeevaluate\_\-ewald\_\-correction}}
\index{force\_\-treeevaluate\_\-ewald\_\-correction@{force\_\-treeevaluate\_\-ewald\_\-correction}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeevaluate\_\-ewald\_\-correction}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate\_\-ewald\_\-correction (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode, }
\item[{double}]{ pos\_\-x, }
\item[{double}]{ pos\_\-y, }
\item[{double}]{ pos\_\-z, }
\item[{double}]{ aold}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ab6894fe5ae268ea8f6bc7c4a8c87a87f}
This function computes the Ewald correction, and is needed if periodic boundary conditions together with a pure tree algorithm are used. Note that the ordinary tree walk does not carry out this correction directly as it was done in Gadget-\/1.1. Instead, the tree is walked a second time. This is actually faster because the \char`\"{}Ewald-\/Treewalk\char`\"{} can use a different opening criterion than the normal tree walk. In particular, the Ewald correction is negligible for particles that are very close, but it is large for particles that are far away (this is quite different for the normal direct force). So we can here use a different opening criterion. Sufficient accuracy is usually obtained if the node length has dropped to a certain fraction $\sim$$<$ 0.25 of the BoxLength. However, we may only short-\/cut the interaction list of the normal full Ewald tree walk if we are sure that the whole node and all daughter nodes \char`\"{}lie on the same side\char`\"{} of the periodic boundary, i.e. that the real tree walk would not find a daughter node or particle that was mapped to a different nearest neighbour position when the tree walk would be further refined. 

Definition at line 1934 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BoxSize, NODE::center, NODE::d, DomainTask, EN, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, fac\_\-intp, fcorrx, fcorry, fcorrz, global\_\-data\_\-all\_\-processes::ForceSoftening, particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataResult, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, gravdata\_\-in::Ninteractions, Nodes, P, particle\_\-data::Pos, gravdata\_\-in::u, NODE::u, and gravdata\_\-in::w.



Referenced by force\_\-treeevaluate().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, cost;
  double dx, dy, dz, mass, r2;
  int signx, signy, signz;
  int i, j, k, openflag;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;
  double acc_x, acc_y, acc_z;
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif
  
  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  cost = 0;

  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }

              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);

      if(no < All.MaxPart)
        no = Nextnode[no];
      else                      /* we have an  internal node. Need to check openi
      ng criterion */
        {
          openflag = 0;

          r2 = dx * dx + dy * dy + dz * dz;
        
#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       +
                              (nop->center[1] - pos_y)*(nop->center[1] - pos_y) +
      
                              (nop->center[2] - pos_z)*(nop->center[2] - pos_z));
      
          /*check if any portion the cell lies withing the intercation range*/
        if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  openflag = 1;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  openflag = 1;
                }
              else
                {
                  if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                        {
                          if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                            {
                              openflag = 1;
                            }
                        }
                    }
                }
            }

          if(openflag)
            {
              /* now we check if we can avoid opening the cell */

              u = nop->center[0] - pos_x;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              u = nop->center[1] - pos_y;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              u = nop->center[2] - pos_z;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* if the cell is too large, we need to refine
               * it further 
               */
              if(nop->len > 0.20 * boxsize)
                {
                  /* cell is too large */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }

          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 1))       /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      /* compute the Ewald correction force */

      if(dx < 0)
        {
          dx = -dx;
          signx = +1;
        }
      else
        signx = -1;

      if(dy < 0)
        {
          dy = -dy;
          signy = +1;
        }
      else
        signy = -1;

      if(dz < 0)
        {
          dz = -dz;
          signz = +1;
        }
      else
        signz = -1;

      u = dx * fac_intp;
      i = (int) u;
      if(i >= EN)
        i = EN - 1;
      u -= i;
      v = dy * fac_intp;
      j = (int) v;
      if(j >= EN)
        j = EN - 1;
      v -= j;
      w = dz * fac_intp;
      k = (int) w;
      if(k >= EN)
        k = EN - 1;
      w -= k;

      /* compute factors for trilinear interpolation */

      f1 = (1 - u) * (1 - v) * (1 - w);
      f2 = (1 - u) * (1 - v) * (w);
      f3 = (1 - u) * (v) * (1 - w);
      f4 = (1 - u) * (v) * (w);
      f5 = (u) * (1 - v) * (1 - w);
      f6 = (u) * (1 - v) * (w);
      f7 = (u) * (v) * (1 - w);
      f8 = (u) * (v) * (w);

      acc_x += mass * signx * (fcorrx[i][j][k] * f1 +
                               fcorrx[i][j][k + 1] * f2 +
                               fcorrx[i][j + 1][k] * f3 +
                               fcorrx[i][j + 1][k + 1] * f4 +
                               fcorrx[i + 1][j][k] * f5 +
                               fcorrx[i + 1][j][k + 1] * f6 +
                               fcorrx[i + 1][j + 1][k] * f7 + fcorrx[i + 1][j + 1
      ][k + 1] * f8);

      acc_y += mass * signy * (fcorry[i][j][k] * f1 +
                               fcorry[i][j][k + 1] * f2 +
                               fcorry[i][j + 1][k] * f3 +
                               fcorry[i][j + 1][k + 1] * f4 +
                               fcorry[i + 1][j][k] * f5 +
                               fcorry[i + 1][j][k + 1] * f6 +
                               fcorry[i + 1][j + 1][k] * f7 + fcorry[i + 1][j + 1
      ][k + 1] * f8);

      acc_z += mass * signz * (fcorrz[i][j][k] * f1 +
                               fcorrz[i][j][k + 1] * f2 +
                               fcorrz[i][j + 1][k] * f3 +
                               fcorrz[i][j + 1][k + 1] * f4 +
                               fcorrz[i + 1][j][k] * f5 +
                               fcorrz[i + 1][j][k + 1] * f6 +
                               fcorrz[i + 1][j + 1][k] * f7 + fcorrz[i + 1][j + 1
      ][k + 1] * f8);
      cost++;
    }


  /* add the result at the proper place */

  if(mode == 0)
    {
      P[target].GravAccel[0] += acc_x;
      P[target].GravAccel[1] += acc_y;
      P[target].GravAccel[2] += acc_z;
      P[target].GravCost += cost;
    }
  else
    {
      GravDataResult[target].u.Acc[0] += acc_x;
      GravDataResult[target].u.Acc[1] += acc_y;
      GravDataResult[target].u.Acc[2] += acc_z;
      GravDataResult[target].w.Ninteractions += cost;
    }

  return cost;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab6894fe5ae268ea8f6bc7c4a8c87a87f_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_af29d257a1e4545ba4b9c3648444979b6}{
\index{forcetree.c@{forcetree.c}!force\_\-treeevaluate\_\-potential@{force\_\-treeevaluate\_\-potential}}
\index{force\_\-treeevaluate\_\-potential@{force\_\-treeevaluate\_\-potential}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeevaluate\_\-potential}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeevaluate\_\-potential (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_af29d257a1e4545ba4b9c3648444979b6}
This routine computes the gravitational potential by walking the tree. The same opening criteria is used as for the gravitational force walk. 

Definition at line 2216 of file forcetree.c.



References All, global\_\-data\_\-all\_\-processes::BoxSize, NODE::center, NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, ewald\_\-pot\_\-corr(), Exportflag, global\_\-data\_\-all\_\-processes::ForceSoftening, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, Nodes, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, gravdata\_\-in::Potential, particle\_\-data::Potential, SphP, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, and gravdata\_\-in::w.



Referenced by compute\_\-potential().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype;
  double r2, dx, dy, dz, mass, r, u, h, h_inv, wp;
  double pot, pos_x, pos_y, pos_z, aold;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif
  
  pot = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }


#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
#endif
  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an internal node. Need to check openin
      g criterion */
        {
          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can make
                                                 * a short-cut 
                                                 */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
           /*check if any portion the cell lies withing the intercation range*/
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
          {
            /* open cell */
            no = nop->u.d.nextnode;
            continue;
          }
#endif
        
          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(988);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5 signals 
      that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif

          no = nop->u.d.sibling;        /* node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        pot -= mass / r;
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
#endif
          u = r * h_inv;

          if(u < 0.5)
            wp = -2.8 + u * u * (5.333333333333 + u * u * (6.4 * u - 9.6));
          else
            wp =
              -3.2 + 0.066666666667 / u + u * u * (10.666666666667 +
                                                   u * (-16.0 + u * (9.6 - 2.1333
      33333333 * u)));

          pot += mass * h_inv * wp;
        }
#ifdef PERIODIC
      pot += mass * ewald_pot_corr(dx, dy, dz);
#endif
    }

  /* store result at the proper place */

  if(mode == 0)
    P[target].Potential = pot;
  else
    GravDataResult[target].u.Potential = pot;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_af29d257a1e4545ba4b9c3648444979b6_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_af29d257a1e4545ba4b9c3648444979b6_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_abd9d86a6c08e77a4fa78fa76b96cdde7}{
\index{forcetree.c@{forcetree.c}!force\_\-treeevaluate\_\-potential\_\-shortrange@{force\_\-treeevaluate\_\-potential\_\-shortrange}}
\index{force\_\-treeevaluate\_\-potential\_\-shortrange@{force\_\-treeevaluate\_\-potential\_\-shortrange}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeevaluate\_\-potential\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeevaluate\_\-potential\_\-shortrange (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_abd9d86a6c08e77a4fa78fa76b96cdde7}
This function computes the short-\/range potential when the TreePM algorithm is used. This potential is the Newtonian potential, modified by a complementary error function. 

Definition at line 2493 of file forcetree.c.



References All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, NODE::center, NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, global\_\-data\_\-all\_\-processes::ForceSoftening, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, Nodes, NTAB, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, gravdata\_\-in::Potential, particle\_\-data::Potential, global\_\-data\_\-all\_\-processes::Rcut, shortrange\_\-table\_\-potential, SphP, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, and gravdata\_\-in::w.



Referenced by compute\_\-potential().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype, tabindex;
  double r2, dx, dy, dz, mass, r, u, h, h_inv, wp;
  double pot, pos_x, pos_y, pos_z, aold;
  double eff_dist, fac, rcut, asmth, asmthfac;
  double dxx, dyy, dzz;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif

#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif

  pot = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }


  rcut = All.Rcut[0];
  asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
  if(((1 << ptype) & (PLACEHIGHRESREGION)))
    {
      rcut = All.Rcut[1];
      asmth = All.Asmth[1];
    }
#endif
  asmthfac = 0.5 / asmth * (NTAB / 3.0);

#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
#endif

  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign  */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node. Need to check openi
      ng criterion */
        {
          /* check whether we can stop walking along this branch */
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node which
       does not contain local particles */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

          eff_dist = rcut + 0.5 * nop->len;

          dxx = nop->center[0] - pos_x; /* observe the sign ! */
          dyy = nop->center[1] - pos_y; /* this vector is -y in my thesis notatio
      n */
          dzz = nop->center[2] - pos_z;
#ifdef PERIODIC
          dxx = NEAREST(dxx);
          dyy = NEAREST(dyy);
          dzz = NEAREST(dzz);
#endif
          if(dxx < -eff_dist || dxx > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

          if(dyy < -eff_dist || dyy > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

          if(dzz < -eff_dist || dzz > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
           /*check if any portion the cell lies withing the intercation range*/
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
          {
            /* open cell */
            no = nop->u.d.nextnode;
            continue;
          }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(989);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      /* bit-5 signals that there are particles of
                       * different softening in the node
                       */
                      if(((nop->u.d.bitflags >> 5) & 1))
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif
          no = nop->u.d.sibling;        /* node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      tabindex = (int) (r * asmthfac);

      if(tabindex < NTAB)
        {
          fac = shortrange_table_potential[tabindex];

          if(r >= h)
            pot -= fac * mass / r;
          else
            {
#ifdef UNEQUALSOFTENINGS
              h_inv = 1.0 / h;
#endif
              u = r * h_inv;

              if(u < 0.5)
                wp = -2.8 + u * u * (5.333333333333 + u * u * (6.4 * u - 9.6));
              else
                wp =
                  -3.2 + 0.066666666667 / u + u * u * (10.666666666667 +
                                                       u * (-16.0 + u * (9.6 - 2.
      133333333333 * u)));
              pot += fac * mass * h_inv * wp;
            }
        }
    }


  /* store result at the proper place */
  if(mode == 0)
    P[target].Potential = pot;
  else
    GravDataResult[target].u.Potential = pot;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_abd9d86a6c08e77a4fa78fa76b96cdde7_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_abd9d86a6c08e77a4fa78fa76b96cdde7_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ae01e179b7686a7fe62970160b7bbdb46}{
\index{forcetree.c@{forcetree.c}!force\_\-treeevaluate\_\-shortrange@{force\_\-treeevaluate\_\-shortrange}}
\index{force\_\-treeevaluate\_\-shortrange@{force\_\-treeevaluate\_\-shortrange}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeevaluate\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate\_\-shortrange (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ae01e179b7686a7fe62970160b7bbdb46}
In the TreePM algorithm, the tree is walked only locally around the target coordinate. Tree nodes that fall outside a box of half side-\/length Rcut= RCUT$\ast$ASMTH$\ast$MeshSize can be discarded. The short-\/range potential is modified by a complementary error function, multiplied with the Newtonian form. The resulting short-\/range suppression compared to the Newtonian force is tabulated, because looking up from this table is faster than recomputing the corresponding factor, despite the memory-\/access panelty (which reduces cache performance) incurred by the table. 

Definition at line 1500 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, calculate\_\-interact\_\-kick(), NODE::center, check\_\-interaction\_\-table(), NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, FLOAT, global\_\-data\_\-all\_\-processes::ForceSoftening, get\_\-random\_\-number(), particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, particle\_\-data::ID, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, gravdata\_\-in::Ninteractions, Nodes, NTAB, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, prob\_\-of\_\-interaction(), global\_\-data\_\-all\_\-processes::Rcut, shortrange\_\-table, SphP, particle\_\-data::Ti\_\-begstep, particle\_\-data::Ti\_\-endstep, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, update\_\-interaction\_\-table(), particle\_\-data::Vel, and gravdata\_\-in::w.



Referenced by gravity\_\-tree().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype, ninteractions, tabindex;
  double r2, dx, dy, dz, mass, r, fac, u, h, h_inv, h3_inv;
  double acc_x, acc_y, acc_z, pos_x, pos_y, pos_z, aold;
  double eff_dist;
  double rcut, asmth, asmthfac, rcut2, dist;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center,kick_x,kick_y,kick_z,kick_target[3],kick_no[3],prob;
  FLOAT targetVel[3];
  int targetBegstep,targetEndstep;
  IDTYPE targetID;              
  int si_count,i;
  kick_x = 0;
  kick_y = 0;
  kick_z = 0;
  si_count = 0;
  if(mode == 0)
    {
      for(i=0;i<3;i++)
        targetVel[i] = P[target].Vel[i];
      targetBegstep = P[target].Ti_begstep;
      targetEndstep = P[target].Ti_endstep;
      targetID      = P[target].ID;
    }
  else
    {
      for(i=0;i<3;i++)
        targetVel[i] = GravDataGet[target].Vel[i];
      targetBegstep = GravDataGet[target].Ti_begstep;
      targetEndstep = GravDataGet[target].Ti_endstep;
      targetID      = GravDataGet[target].ID;
    }
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  ninteractions = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#ifdef COMPUTE_SELFINTERACTION_FORDARK      
      ptype = GravDataGet[target].Type;
#endif
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }

  rcut = All.Rcut[0];
  asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
  if(((1 << ptype) & (PLACEHIGHRESREGION)))
    {
      rcut = All.Rcut[1];
      asmth = All.Asmth[1];
    }
#endif
  rcut2 = rcut * rcut;

  asmthfac = 0.5 / asmth * (NTAB / 3.0);

#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
  h3_inv = h_inv * h_inv * h_inv;
#endif
  no = All.MaxPart;             /* root node */

  while(no >= 0)
    {
      if(no < All.MaxPart)
        {
          /* the index of the node is the index of the particle */
          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
#ifdef PERIODIC
          dx = NEAREST(dx);
          dy = NEAREST(dy);
          dz = NEAREST(dz);
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          mass = P[no].Mass;
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node */
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can
                                                 * continue at this point
                                                 */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

          mass = nop->u.d.mass;

          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
#ifdef PERIODIC
          dx = NEAREST(dx);
          dy = NEAREST(dy);
          dz = NEAREST(dz);
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          if(r2 > rcut2)
            {
              /* check whether we can stop walking along this branch */
              eff_dist = rcut + 0.5 * nop->len;
#ifdef PERIODIC
              dist = NEAREST(nop->center[0] - pos_x);
#else
              dist = nop->center[0] - pos_x;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
#ifdef PERIODIC
              dist = NEAREST(nop->center[1] - pos_y);
#else
              dist = nop->center[1] - pos_y;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
#ifdef PERIODIC
              dist = NEAREST(nop->center[2] - pos_z);
#else
              dist = nop->center[2] - pos_z;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
          /*check if any portion the cell lies withing the intercation range */
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* check in addition whether we lie inside the cell */

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(987);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5 signals 
      that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif
          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        fac = mass / (r2 * r);
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
          h3_inv = h_inv * h_inv * h_inv;
#endif
          u = r * h_inv;
          if(u < 0.5)
            fac = mass * h3_inv * (10.666666666667 + u * u * (32.0 * u - 38.4));
          else
            fac =
              mass * h3_inv * (21.333333333333 - 48.0 * u +
                               38.4 * u * u - 10.666666666667 * u * u * u - 0.066
      666666667 / (u * u * u));
        }

      tabindex = (int) (asmthfac * r);

      if(tabindex < NTAB)
        {
          fac *= shortrange_table[tabindex];

          acc_x += dx * fac;
          acc_y += dy * fac;
          acc_z += dz * fac;
        
#ifdef COMPUTE_SELFINTERACTION_FORDARK
          if(no < All.MaxPart)
            {
              if ((ptype == 1 && P[no].Type == 4) || (ptype == 4 && P[no].Type ==
       1) ) /*This line has been modified for the Test1. original: if (ptype == 1 && P[
      no].Type == 1)*/
                {
                  if(r < 2.0 * All.ForceSoftening[1] && check_interaction_table(t
      argetID,P[no].ID) == 0)
                    {
                      prob = prob_of_interaction(r, targetVel, P[no].Vel, targetB
      egstep, targetEndstep);
                      if(get_random_number(P[no].ID) < prob)
                        {
                          calculate_interact_kick(targetVel, P[no].Vel, kick_targ
      et, kick_no);
                          kick_x += kick_target[0];
                          kick_y += kick_target[1];
                          kick_z += kick_target[2];
                          for(i = 0; i < 3 ; i++)
                              P[no].Vel[i] += kick_no[i];
                          si_count+=1;
                          update_interaction_table(targetID,P[no].ID);
                        }
                    }
                }
            }
#endif
          ninteractions++;
        }
    }

#ifdef COMPUTE_SELFINTERACTION_FORDARK 
  All.Nself_interactions += si_count;
#endif

  /* store result at the proper place */

  if(mode == 0)
    {
      P[target].GravAccel[0] = acc_x;
      P[target].GravAccel[1] = acc_y;
      P[target].GravAccel[2] = acc_z;
      P[target].GravCost = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      P[target].Vel[0] += kick_x;
      P[target].Vel[1] += kick_y;
      P[target].Vel[2] += kick_z;
#endif
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
      GravDataResult[target].w.Ninteractions = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      GravDataResult[target].Vel[0] = kick_x;
      GravDataResult[target].Vel[1] = kick_y;
      GravDataResult[target].Vel[2] = kick_z;
#endif
    }

  return ninteractions;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ae01e179b7686a7fe62970160b7bbdb46_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ae01e179b7686a7fe62970160b7bbdb46_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a0a9667f530dad09ebed8c0c98e5d3888}{
\index{forcetree.c@{forcetree.c}!force\_\-treefree@{force\_\-treefree}}
\index{force\_\-treefree@{force\_\-treefree}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treefree}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treefree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a0a9667f530dad09ebed8c0c98e5d3888}
This function frees the memory allocated for the tree, i.e. it frees the space allocated by the function \hyperlink{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2}{force\_\-treeallocate()}. 

Definition at line 2892 of file forcetree.c.



References Extnodes\_\-base, Father, Nextnode, and Nodes\_\-base.



Referenced by pmforce\_\-periodic(), and pmpotential\_\-periodic().




\begin{DoxyCode}
{
  free(Father);
  free(Nextnode);
  free(Extnodes_base);
  free(Nodes_base);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a0a9667f530dad09ebed8c0c98e5d3888_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ab8e5d4fed349d96c6d4f55897473ce19}{
\index{forcetree.c@{forcetree.c}!force\_\-treeupdate\_\-pseudos@{force\_\-treeupdate\_\-pseudos}}
\index{force\_\-treeupdate\_\-pseudos@{force\_\-treeupdate\_\-pseudos}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-treeupdate\_\-pseudos}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeupdate\_\-pseudos (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ab8e5d4fed349d96c6d4f55897473ce19}
This function updates the top-\/level tree after the multipole moments of the pseudo-\/particles have been updated. 

Definition at line 732 of file forcetree.c.



References All, NODE::d, DomainMoment, DomainMyLast, DomainNodeIndex, Extnodes, FLOAT, global\_\-data\_\-all\_\-processes::ForceSoftening, DomainNODE::mass, Nodes, NTopleaves, DomainNODE::s, NODE::u, DomainNODE::vs, and extNODE::vs.



Referenced by force\_\-update\_\-pseudoparticles().




\begin{DoxyCode}
{
  int i, k, no;
  FLOAT sold[3], vsold[3], snew[3], vsnew[3], massold, massnew, mm;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
  int maxsofttype, diffsoftflag;
#else
  FLOAT maxsoft;
#endif
#endif

  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        for(k = 0; k < 3; k++)
          {
            sold[k] = Nodes[no].u.d.s[k];
            vsold[k] = Extnodes[no].vs[k];
          }
        massold = Nodes[no].u.d.mass;

        for(k = 0; k < 3; k++)
          {
            snew[k] = DomainMoment[i].s[k];
            vsnew[k] = DomainMoment[i].vs[k];
          }
        massnew = DomainMoment[i].mass;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
        maxsofttype = (DomainMoment[i].bitflags >> 2) & 7;
        diffsoftflag = (DomainMoment[i].bitflags >> 5) & 1;
#else
        maxsoft = DomainMoment[i].maxsoft;
#endif
#endif
        do
          {
            mm = Nodes[no].u.d.mass + massnew - massold;
            for(k = 0; k < 3; k++)
              {
                if(mm > 0)
                  {
                    Nodes[no].u.d.s[k] =
                      (Nodes[no].u.d.mass * Nodes[no].u.d.s[k] + massnew * snew[k
      ] - massold * sold[k]) / mm;
                    Extnodes[no].vs[k] =
                      (Nodes[no].u.d.mass * Extnodes[no].vs[k] + massnew * vsnew[
      k] -
                       massold * vsold[k]) / mm;
                  }
              }
            Nodes[no].u.d.mass = mm;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
            diffsoftflag |= (Nodes[no].u.d.bitflags >> 5) & 1;

            if(maxsofttype == 7)
              maxsofttype = (Nodes[no].u.d.bitflags >> 2) & 7;
            else
              {
                if(((Nodes[no].u.d.bitflags >> 2) & 7) != 7)
                  {
                    if(All.ForceSoftening[((Nodes[no].u.d.bitflags >> 2) & 7)] >
                       All.ForceSoftening[maxsofttype])
                      {
                        maxsofttype = ((Nodes[no].u.d.bitflags >> 2) & 7);
                        diffsoftflag = 1;
                      }
                    else
                      {
                        if(All.ForceSoftening[((Nodes[no].u.d.bitflags >> 2) & 7)
      ] <
                           All.ForceSoftening[maxsofttype])
                          diffsoftflag = 1;
                      }
                  }
              }

            Nodes[no].u.d.bitflags = (Nodes[no].u.d.bitflags & 3) + 4 * maxsoftty
      pe + 32 * diffsoftflag;
#else
            if(Nodes[no].maxsoft < maxsoft)
              Nodes[no].maxsoft = maxsoft;
            maxsoft = Nodes[no].maxsoft;
#endif
#endif
            no = Nodes[no].u.d.father;

          }
        while(no >= 0);
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab8e5d4fed349d96c6d4f55897473ce19_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a4764c1fb83a956c1712345538630854c}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-hmax@{force\_\-update\_\-hmax}}
\index{force\_\-update\_\-hmax@{force\_\-update\_\-hmax}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-hmax}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-hmax (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a4764c1fb83a956c1712345538630854c}
This function updates the hmax-\/values in tree nodes that hold SPH particles. These values are needed to find all neighbors in the hydro-\/force computation. Since the Hsml-\/values are potentially changed in the SPH-\/denity computation, \hyperlink{forcetree_8c_a4764c1fb83a956c1712345538630854c}{force\_\-update\_\-hmax()} should be carried out just before the hydrodynamical SPH forces are computed, i.e. after \hyperlink{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density()}. 

Definition at line 1014 of file forcetree.c.



References DomainEndList, DomainHmax, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, Extnodes, FLOAT, force\_\-update\_\-node\_\-hmax\_\-local(), force\_\-update\_\-node\_\-hmax\_\-toptree(), extNODE::hmax, NTask, PTask, TAG\_\-HMAX, and ThisTask.



Referenced by compute\_\-accelerations().




\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  force_update_node_hmax_local();

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      DomainHmax[i] = Extnodes[no].hmax;
    }

  /* share the hmax-data of the pseudo-particles accross CPUs */

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainHmax[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_HMAX,
                     &DomainHmax[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_HMAX, MPI_COMM_WORLD, &status);
    }


  force_update_node_hmax_toptree();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a4764c1fb83a956c1712345538630854c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a4764c1fb83a956c1712345538630854c_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a04fb647ef783d5baeb9275d806c08365}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-len@{force\_\-update\_\-len}}
\index{force\_\-update\_\-len@{force\_\-update\_\-len}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-len}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-len (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a04fb647ef783d5baeb9275d806c08365}
This function updates the side-\/length of tree nodes in case the tree is not reconstructed, but only drifted. The grouping of particles to tree nodes is not changed in this case, but some tree nodes may need to be enlarged because particles moved out of their original bounds. 

Definition at line 885 of file forcetree.c.



References DomainEndList, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, DomainTreeNodeLen, FLOAT, force\_\-update\_\-node\_\-len\_\-local(), force\_\-update\_\-node\_\-len\_\-toptree(), NODE::len, Nodes, NTask, PTask, TAG\_\-NODELEN, and ThisTask.



Referenced by move\_\-particles().




\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  force_update_node_len_local();

  /* first update the side-lengths of all local nodes */
  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      DomainTreeNodeLen[i] = Nodes[no].len;
    }

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainTreeNodeLen[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_NODELEN,
                     &DomainTreeNodeLen[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_NODELEN, MPI_COMM_WORLD, &status);
    }

  /* Finally, we update the top-level tree. */
  force_update_node_len_toptree();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=386pt]{forcetree_8c_a04fb647ef783d5baeb9275d806c08365_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a04fb647ef783d5baeb9275d806c08365_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a4c108b1da2bc4f2620f62aeab90c1074}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-node\_\-hmax\_\-local@{force\_\-update\_\-node\_\-hmax\_\-local}}
\index{force\_\-update\_\-node\_\-hmax\_\-local@{force\_\-update\_\-node\_\-hmax\_\-local}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-node\_\-hmax\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-hmax\_\-local (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a4c108b1da2bc4f2620f62aeab90c1074}
This routine updates the hmax-\/values of local tree nodes. 

Definition at line 1051 of file forcetree.c.



References NODE::d, Extnodes, Father, extNODE::hmax, sph\_\-particle\_\-data::Hsml, N\_\-gas, Nodes, SphP, and NODE::u.



Referenced by force\_\-update\_\-hmax().




\begin{DoxyCode}
{
  int i, p, no;

  for(i = 0; i < N_gas; i++)
    {

      no = Father[i];

      if(SphP[i].Hsml > Extnodes[no].hmax)
        {

          Extnodes[no].hmax = SphP[i].Hsml;
          p = Nodes[no].u.d.father;

          while(p >= 0)
            {
              if(Extnodes[no].hmax > Extnodes[p].hmax)
                {
                  Extnodes[p].hmax = Extnodes[no].hmax;
                  no = p;
                  p = Nodes[p].u.d.father;
                }
              else
                break;
            }
        }

    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a4c108b1da2bc4f2620f62aeab90c1074_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ac3f5945bb7c73936ef49af1507265afe}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-node\_\-hmax\_\-toptree@{force\_\-update\_\-node\_\-hmax\_\-toptree}}
\index{force\_\-update\_\-node\_\-hmax\_\-toptree@{force\_\-update\_\-node\_\-hmax\_\-toptree}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-node\_\-hmax\_\-toptree}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-hmax\_\-toptree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ac3f5945bb7c73936ef49af1507265afe}
This function recursively sets the hmax-\/values of the top-\/level tree. 

Definition at line 1087 of file forcetree.c.



References NODE::d, DomainHmax, DomainMyLast, DomainNodeIndex, Extnodes, extNODE::hmax, Nodes, NTopleaves, and NODE::u.



Referenced by force\_\-update\_\-hmax().




\begin{DoxyCode}
{

  int i, no, p;


  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        if(Extnodes[no].hmax < DomainHmax[i])
          Extnodes[no].hmax = DomainHmax[i];

        p = Nodes[no].u.d.father;

        while(p >= 0)
          {
            if(Extnodes[no].hmax > Extnodes[p].hmax)
              {
                Extnodes[p].hmax = Extnodes[no].hmax;
                no = p;
                p = Nodes[p].u.d.father;
              }
            else
              break;
          }
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ac3f5945bb7c73936ef49af1507265afe_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a4592b750f8555f580691103acf1e5366}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-node\_\-len\_\-local@{force\_\-update\_\-node\_\-len\_\-local}}
\index{force\_\-update\_\-node\_\-len\_\-local@{force\_\-update\_\-node\_\-len\_\-local}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-node\_\-len\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-len\_\-local (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a4592b750f8555f580691103acf1e5366}
This function recursively enlarges nodes such that they always contain all their daughter nodes and daughter particles. 

Definition at line 923 of file forcetree.c.



References NODE::center, NODE::d, Father, FLOAT, NODE::len, Nodes, NumPart, P, particle\_\-data::Pos, and NODE::u.



Referenced by force\_\-update\_\-len().




\begin{DoxyCode}
{
  int i, p, k, no;
  FLOAT dist, distmax;

  for(i = 0; i < NumPart; i++)
    {
      no = Father[i];

      for(k = 0, distmax = 0; k < 3; k++)
        {
          dist = P[i].Pos[k] - Nodes[no].center[k];
          if(dist < 0)
            dist = -dist;
          if(dist > distmax)
            distmax = dist;
        }

      if(distmax + distmax > Nodes[no].len)
        {
          Nodes[no].len = distmax + distmax;
          p = Nodes[no].u.d.father;

          while(p >= 0)
            {
              distmax = Nodes[p].center[0] - Nodes[no].center[0];
              if(distmax < 0)
                distmax = -distmax;
              distmax = distmax + distmax + Nodes[no].len;

              if(0.999999 * distmax > Nodes[p].len)
                {
                  Nodes[p].len = distmax;
                  no = p;
                  p = Nodes[p].u.d.father;
                }
              else
                break;
            }
        }
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a4592b750f8555f580691103acf1e5366_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_a5f85438d619d63c812c8e05faf1f0074}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-node\_\-len\_\-toptree@{force\_\-update\_\-node\_\-len\_\-toptree}}
\index{force\_\-update\_\-node\_\-len\_\-toptree@{force\_\-update\_\-node\_\-len\_\-toptree}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-node\_\-len\_\-toptree}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-len\_\-toptree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_a5f85438d619d63c812c8e05faf1f0074}
This function recursively enlarges nodes of the top-\/level tree such that they always contain all their daughter nodes. 

Definition at line 970 of file forcetree.c.



References NODE::center, NODE::d, DomainMyLast, DomainNodeIndex, DomainTreeNodeLen, FLOAT, NODE::len, Nodes, NTopleaves, and NODE::u.



Referenced by force\_\-update\_\-len().




\begin{DoxyCode}
{
  int i, no, p;
  FLOAT distmax;

  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        if(Nodes[no].len < DomainTreeNodeLen[i])
          Nodes[no].len = DomainTreeNodeLen[i];

        p = Nodes[no].u.d.father;

        while(p >= 0)
          {
            distmax = Nodes[p].center[0] - Nodes[no].center[0];
            if(distmax < 0)
              distmax = -distmax;
            distmax = distmax + distmax + Nodes[no].len;

            if(0.999999 * distmax > Nodes[p].len)
              {
                Nodes[p].len = distmax;
                no = p;
                p = Nodes[p].u.d.father;
              }
            else
              break;
          }
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_a5f85438d619d63c812c8e05faf1f0074_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_ab745c54c805d07ad255a3f86ff77e18d}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-node\_\-recursive@{force\_\-update\_\-node\_\-recursive}}
\index{force\_\-update\_\-node\_\-recursive@{force\_\-update\_\-node\_\-recursive}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-node\_\-recursive}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-recursive (
\begin{DoxyParamCaption}
\item[{int}]{ no, }
\item[{int}]{ sib, }
\item[{int}]{ father}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_ab745c54c805d07ad255a3f86ff77e18d}
this routine determines the multipole moments for a given internal node and all its subnodes using a recursive computation. The result is stored in the Nodes\mbox{[}\mbox{]} structure in the sequence of this tree-\/walk.

Note that the bitflags-\/variable for each node is used to store in the lowest bits some special information: Bit 0 flags whether the node belongs to the top-\/level tree corresponding to the domain decomposition, while Bit 1 signals whether the top-\/level node is dependent on local mass.

If UNEQUALSOFTENINGS is set, bits 2-\/4 give the particle type with the maximum softening among the particles in the node, and bit 5 flags whether the node contains any particles with lower softening than that. 

Definition at line 422 of file forcetree.c.



References All, NODE::center, NODE::d, Extnodes, Father, FLOAT, force\_\-update\_\-node\_\-recursive(), global\_\-data\_\-all\_\-processes::ForceSoftening, extNODE::hmax, sph\_\-particle\_\-data::Hsml, last, particle\_\-data::Mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nextnode, Nodes, P, particle\_\-data::Pos, SphP, NODE::suns, particle\_\-data::Type, NODE::u, particle\_\-data::Vel, and extNODE::vs.



Referenced by force\_\-treebuild\_\-single(), and force\_\-update\_\-node\_\-recursive().




\begin{DoxyCode}
{
  int j, jj, p, pp, nextsib, suns[8];
  FLOAT hmax;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
  int maxsofttype, diffsoftflag;
#else
  FLOAT maxsoft;
#endif
#endif
  struct particle_data *pa;
  double s[3], vs[3], mass;

  if(no >= All.MaxPart && no < All.MaxPart + MaxNodes)  /* internal node */
    {
      for(j = 0; j < 8; j++)
        suns[j] = Nodes[no].u.suns[j];  /* this "backup" is necessary because the
       nextnode entry will
                                           overwrite one element (union!) */
      if(last >= 0)
        {
          if(last >= All.MaxPart)
            {
              if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
                Nextnode[last - MaxNodes] = no;
              else
                Nodes[last].u.d.nextnode = no;
            }
          else
            Nextnode[last] = no;
        }

      last = no;

      mass = 0;
      s[0] = 0;
      s[1] = 0;
      s[2] = 0;
      vs[0] = 0;
      vs[1] = 0;
      vs[2] = 0;
      hmax = 0;
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      maxsofttype = 7;
      diffsoftflag = 0;
#else
      maxsoft = 0;
#endif
#endif

      for(j = 0; j < 8; j++)
        {
          if((p = suns[j]) >= 0)
            {
              /* check if we have a sibling on the same level */
              for(jj = j + 1; jj < 8; jj++)
                if((pp = suns[jj]) >= 0)
                  break;

              if(jj < 8)        /* yes, we do */
                nextsib = pp;
              else
                nextsib = sib;

              force_update_node_recursive(p, nextsib, no);


              if(p >= All.MaxPart)      /* an internal node or pseudo particle */
      
                {
                  if(p >= All.MaxPart + MaxNodes)       /* a pseudo particle */
                    {
                      /* nothing to be done here because the mass of the
                       * pseudo-particle is still zero. This will be changed
                       * later.
                       */
                    }
                  else
                    {
                      mass += Nodes[p].u.d.mass;
                      s[0] += Nodes[p].u.d.mass * Nodes[p].u.d.s[0];
                      s[1] += Nodes[p].u.d.mass * Nodes[p].u.d.s[1];
                      s[2] += Nodes[p].u.d.mass * Nodes[p].u.d.s[2];
                      vs[0] += Nodes[p].u.d.mass * Extnodes[p].vs[0];
                      vs[1] += Nodes[p].u.d.mass * Extnodes[p].vs[1];
                      vs[2] += Nodes[p].u.d.mass * Extnodes[p].vs[2];

                      if(Extnodes[p].hmax > hmax)
                        hmax = Extnodes[p].hmax;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
                      diffsoftflag |= (Nodes[p].u.d.bitflags >> 5) & 1;

                      if(maxsofttype == 7)
                        {
                          maxsofttype = (Nodes[p].u.d.bitflags >> 2) & 7;
                        }
                      else
                        {
                          if(((Nodes[p].u.d.bitflags >> 2) & 7) != 7)
                            {
                              if(All.ForceSoftening[((Nodes[p].u.d.bitflags >> 2)
       & 7)] >
                                 All.ForceSoftening[maxsofttype])
                                {
                                  maxsofttype = ((Nodes[p].u.d.bitflags >> 2) & 7
      );
                                  diffsoftflag = 1;
                                }
                              else
                                {
                                  if(All.ForceSoftening[((Nodes[p].u.d.bitflags >
      > 2) & 7)] <
                                     All.ForceSoftening[maxsofttype])
                                    diffsoftflag = 1;
                                }
                            }
                        }
#else
                      if(Nodes[p].maxsoft > maxsoft)
                        maxsoft = Nodes[p].maxsoft;
#endif
#endif
                    }
                }
              else              /* a particle */
                {
                  pa = &P[p];

                  mass += pa->Mass;
                  s[0] += pa->Mass * pa->Pos[0];
                  s[1] += pa->Mass * pa->Pos[1];
                  s[2] += pa->Mass * pa->Pos[2];
                  vs[0] += pa->Mass * pa->Vel[0];
                  vs[1] += pa->Mass * pa->Vel[1];
                  vs[2] += pa->Mass * pa->Vel[2];

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
                  if(maxsofttype == 7)
                    {
                      maxsofttype = pa->Type;
                    }
                  else
                    {
                      if(All.ForceSoftening[pa->Type] > All.ForceSoftening[maxsof
      ttype])
                        {
                          maxsofttype = pa->Type;
                          diffsoftflag = 1;
                        }
                      else
                        {
                          if(All.ForceSoftening[pa->Type] < All.ForceSoftening[ma
      xsofttype])
                            diffsoftflag = 1;
                        }
                    }
#else
                  if(pa->Type == 0)
                    {
                      if(SphP[p].Hsml > maxsoft)
                        maxsoft = SphP[p].Hsml;
                    }
                  else
                    {
                      if(All.ForceSoftening[pa->Type] > maxsoft)
                        maxsoft = All.ForceSoftening[pa->Type];
                    }
#endif
#endif
                  if(pa->Type == 0)
                    if(SphP[p].Hsml > hmax)
                      hmax = SphP[p].Hsml;
                }
            }
        }


      if(mass)
        {
          s[0] /= mass;
          s[1] /= mass;
          s[2] /= mass;
          vs[0] /= mass;
          vs[1] /= mass;
          vs[2] /= mass;
        }
      else
        {
          s[0] = Nodes[no].center[0];
          s[1] = Nodes[no].center[1];
          s[2] = Nodes[no].center[2];
        }

      Nodes[no].u.d.s[0] = s[0];
      Nodes[no].u.d.s[1] = s[1];
      Nodes[no].u.d.s[2] = s[2];
      Nodes[no].u.d.mass = mass;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      Nodes[no].u.d.bitflags = 4 * maxsofttype + 32 * diffsoftflag;
#else
      Nodes[no].u.d.bitflags = 0;
      Nodes[no].maxsoft = maxsoft;
#endif
#else
      Nodes[no].u.d.bitflags = 0;
#endif


      Extnodes[no].vs[0] = vs[0];
      Extnodes[no].vs[1] = vs[1];
      Extnodes[no].vs[2] = vs[2];
      Extnodes[no].hmax = hmax;

      Nodes[no].u.d.sibling = sib;
      Nodes[no].u.d.father = father;
    }
  else                          /* single particle or pseudo particle */
    {
      if(last >= 0)
        {
          if(last >= All.MaxPart)
            {
              if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
                Nextnode[last - MaxNodes] = no;
              else
                Nodes[last].u.d.nextnode = no;
            }
          else
            Nextnode[last] = no;
        }

      last = no;

      if(no < All.MaxPart)      /* only set it for single particles */
        Father[no] = father;
    }

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=238pt]{forcetree_8c_ab745c54c805d07ad255a3f86ff77e18d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_ab745c54c805d07ad255a3f86ff77e18d_icgraph}
\end{center}
\end{figure}


\hypertarget{forcetree_8c_af9a7e3a922557e089da5d7ee1dde89a0}{
\index{forcetree.c@{forcetree.c}!force\_\-update\_\-pseudoparticles@{force\_\-update\_\-pseudoparticles}}
\index{force\_\-update\_\-pseudoparticles@{force\_\-update\_\-pseudoparticles}!forcetree.c@{forcetree.c}}
\subsubsection[{force\_\-update\_\-pseudoparticles}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-pseudoparticles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{forcetree_8c_af9a7e3a922557e089da5d7ee1dde89a0}
This function updates the multipole moments of the pseudo-\/particles that represent the mass distribution on different CPUs. For that purpose, it first exchanges the necessary data, and then updates the top-\/level tree accordingly. The detailed implementation of these two tasks is done in separate functions. 

Definition at line 671 of file forcetree.c.



References force\_\-exchange\_\-pseudodata(), and force\_\-treeupdate\_\-pseudos().



Referenced by force\_\-treebuild(), and move\_\-particles().




\begin{DoxyCode}
{
  force_exchange_pseudodata();

  force_treeupdate_pseudos();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_af9a7e3a922557e089da5d7ee1dde89a0_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{forcetree_8c_af9a7e3a922557e089da5d7ee1dde89a0_icgraph}
\end{center}
\end{figure}




\subsection{Variable Documentation}
\hypertarget{forcetree_8c_af6350369fa0c71cba122f936412fcb4d}{
\index{forcetree.c@{forcetree.c}!fac\_\-intp@{fac\_\-intp}}
\index{fac\_\-intp@{fac\_\-intp}!forcetree.c@{forcetree.c}}
\subsubsection[{fac\_\-intp}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf fac\_\-intp}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_af6350369fa0c71cba122f936412fcb4d}


Definition at line 53 of file forcetree.c.



Referenced by ewald\_\-corr(), ewald\_\-init(), ewald\_\-pot\_\-corr(), and force\_\-treeevaluate\_\-ewald\_\-correction().

\hypertarget{forcetree_8c_aa5cc9e7d836cdcf307f7640533e5e928}{
\index{forcetree.c@{forcetree.c}!fcorrx@{fcorrx}}
\index{fcorrx@{fcorrx}!forcetree.c@{forcetree.c}}
\subsubsection[{fcorrx}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf fcorrx}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_aa5cc9e7d836cdcf307f7640533e5e928}
3D lock-\/up table for Ewald correction to force and potential. Only one octant is stored, the rest constructed by using the symmetry 

Definition at line 49 of file forcetree.c.



Referenced by ewald\_\-corr(), ewald\_\-init(), and force\_\-treeevaluate\_\-ewald\_\-correction().

\hypertarget{forcetree_8c_ac7d44a9c9f475423540e3acd8bca75d3}{
\index{forcetree.c@{forcetree.c}!fcorry@{fcorry}}
\index{fcorry@{fcorry}!forcetree.c@{forcetree.c}}
\subsubsection[{fcorry}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf fcorry}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_ac7d44a9c9f475423540e3acd8bca75d3}


Definition at line 50 of file forcetree.c.



Referenced by ewald\_\-corr(), ewald\_\-init(), and force\_\-treeevaluate\_\-ewald\_\-correction().

\hypertarget{forcetree_8c_aa4f6ad92e563dd2a0d0b324452b051f6}{
\index{forcetree.c@{forcetree.c}!fcorrz@{fcorrz}}
\index{fcorrz@{fcorrz}!forcetree.c@{forcetree.c}}
\subsubsection[{fcorrz}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf fcorrz}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_aa4f6ad92e563dd2a0d0b324452b051f6}


Definition at line 51 of file forcetree.c.



Referenced by ewald\_\-corr(), ewald\_\-init(), and force\_\-treeevaluate\_\-ewald\_\-correction().

\hypertarget{forcetree_8c_a37ea0ff529d9c7e76f1f7895bde01183}{
\index{forcetree.c@{forcetree.c}!first\_\-flag@{first\_\-flag}}
\index{first\_\-flag@{first\_\-flag}!forcetree.c@{forcetree.c}}
\subsubsection[{first\_\-flag}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf first\_\-flag} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_a37ea0ff529d9c7e76f1f7895bde01183}
toggles after first tree-\/memory allocation, has only influence on log-\/files 

Definition at line 36 of file forcetree.c.



Referenced by force\_\-treeallocate().

\hypertarget{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}{
\index{forcetree.c@{forcetree.c}!last@{last}}
\index{last@{last}!forcetree.c@{forcetree.c}}
\subsubsection[{last}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf last}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}
auxialiary variable used to set-\/up non-\/recursive walk 

Definition at line 26 of file forcetree.c.



Referenced by force\_\-treebuild\_\-single(), and force\_\-update\_\-node\_\-recursive().

\hypertarget{forcetree_8c_a7a88fa4a0ea6d18436481c44288646a0}{
\index{forcetree.c@{forcetree.c}!potcorr@{potcorr}}
\index{potcorr@{potcorr}!forcetree.c@{forcetree.c}}
\subsubsection[{potcorr}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf potcorr}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\mbox{[}64+1\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_a7a88fa4a0ea6d18436481c44288646a0}


Definition at line 52 of file forcetree.c.



Referenced by ewald\_\-init(), and ewald\_\-pot\_\-corr().

\hypertarget{forcetree_8c_a76b621ce2fa9c17911a62495174029eb}{
\index{forcetree.c@{forcetree.c}!shortrange\_\-table@{shortrange\_\-table}}
\index{shortrange\_\-table@{shortrange\_\-table}!forcetree.c@{forcetree.c}}
\subsubsection[{shortrange\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf shortrange\_\-table}\mbox{[}1000\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_a76b621ce2fa9c17911a62495174029eb}


Definition at line 33 of file forcetree.c.



Referenced by force\_\-treeallocate(), and force\_\-treeevaluate\_\-shortrange().

\hypertarget{forcetree_8c_a196b7c27d03bd3ecc1259b2f67017fbe}{
\index{forcetree.c@{forcetree.c}!shortrange\_\-table\_\-potential@{shortrange\_\-table\_\-potential}}
\index{shortrange\_\-table\_\-potential@{shortrange\_\-table\_\-potential}!forcetree.c@{forcetree.c}}
\subsubsection[{shortrange\_\-table\_\-potential}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf shortrange\_\-table\_\-potential}\mbox{[}1000\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_a196b7c27d03bd3ecc1259b2f67017fbe}


Definition at line 33 of file forcetree.c.



Referenced by force\_\-treeallocate(), and force\_\-treeevaluate\_\-potential\_\-shortrange().

\hypertarget{forcetree_8c_abe941030bf66a95df993b617bffefd9b}{
\index{forcetree.c@{forcetree.c}!tabfac@{tabfac}}
\index{tabfac@{tabfac}!forcetree.c@{forcetree.c}}
\subsubsection[{tabfac}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf tabfac}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{forcetree_8c_abe941030bf66a95df993b617bffefd9b}
variables for short-\/range lookup table 

Definition at line 33 of file forcetree.c.



Referenced by force\_\-treeallocate().

