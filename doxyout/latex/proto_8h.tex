\hypertarget{proto_8h}{
\section{proto.h File Reference}
\label{proto_8h}\index{proto.h@{proto.h}}
}


this file contains all function prototypes of the code  


{\ttfamily \#include \char`\"{}allvars.h\char`\"{}}\par
{\ttfamily \#include $<$hdf5.h$>$}\par
Include dependency graph for proto.h:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=286pt]{proto_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{proto_8h_a05e5a546d63684b55d2457aa56efdd06}{advance\_\-and\_\-find\_\-timesteps} (void)
\item 
void \hyperlink{proto_8h_a9e761db39213af33ba28aeed461f1a5a}{allocate\_\-commbuffers} (void)
\item 
void \hyperlink{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7}{allocate\_\-memory} (void)
\item 
void \hyperlink{proto_8h_aceeb5c8909331b90ea8345e0fc853f82}{begrun} (void)
\item 
int \hyperlink{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e}{blockpresent} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr)
\item 
void \hyperlink{proto_8h_adf560a3f7c53865f7edbf9ff3b16c8fd}{catch\_\-abort} (int sig)
\item 
void \hyperlink{proto_8h_a690d62711b56d77e574ae4dd38fb72f0}{catch\_\-fatal} (int sig)
\item 
void \hyperlink{proto_8h_a1b96c5b41f1209ee91cd369f01a52352}{check\_\-omega} (void)
\item 
void \hyperlink{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}{close\_\-outputfiles} (void)
\item 
int \hyperlink{proto_8h_af3ffb253e14a79419d1effeee1b7261d}{compare\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a147f9422f4bca4666608da992486b417}{compute\_\-accelerations} (int mode)
\item 
void \hyperlink{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1}{compute\_\-global\_\-quantities\_\-of\_\-system} (void)
\item 
void \hyperlink{proto_8h_a04474459731219f9601aaefedb37ab27}{compute\_\-potential} (void)
\item 
int \hyperlink{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1}{dens\_\-compare\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density} (void)
\item 
void \hyperlink{proto_8h_aaeec847fb319935d1a6e765ffbb9c6d9}{density\_\-decouple} (void)
\item 
void \hyperlink{proto_8h_a19f7a07621c698ae894f53836e9ff03c}{density\_\-evaluate} (int i, int mode)
\item 
void \hyperlink{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab}{distribute\_\-file} (int nfiles, int firstfile, int firsttask, int lasttask, int $\ast$filenr, int $\ast$master, int $\ast$\hyperlink{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}{last})
\item 
double \hyperlink{proto_8h_ac5e72d197cde6d71017e89db9b986b85}{dmax} (double, double)
\item 
double \hyperlink{proto_8h_a128779c23a7c6e9cca2374c5e7c91483}{dmin} (double, double)
\item 
void \hyperlink{proto_8h_adda9e167a16a53d1aa40180406950446}{do\_\-box\_\-wrapping} (void)
\item 
void \hyperlink{proto_8h_ae8e3aa408eaab9544cb7f93e69185492}{domain\_\-Decomposition} (void)
\item 
int \hyperlink{proto_8h_a5b596de46669fab5e125f163d44edc37}{domain\_\-compare\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
int \hyperlink{proto_8h_a381621bc90438c5a50826bfdac8e4700}{domain\_\-compare\_\-toplist} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a77c115c3aa2069d0eb8521329be0483c}{domain\_\-countToGo} (void)
\item 
void \hyperlink{proto_8h_a647e0c1a76b7f064ed5d201662f364bf}{domain\_\-decompose} (void)
\item 
void \hyperlink{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729}{domain\_\-determineTopTree} (void)
\item 
void \hyperlink{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca}{domain\_\-exchangeParticles} (int partner, int sphflag, int send\_\-count, int recv\_\-count)
\item 
void \hyperlink{proto_8h_a0e758ec7eef32fc7180092547f5a11b9}{domain\_\-findExchangeNumbers} (int task, int partner, int sphflag, int $\ast$send, int $\ast$recv)
\item 
void \hyperlink{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e}{domain\_\-findExtent} (void)
\item 
int \hyperlink{proto_8h_a412d5d8810751249cc8dcd9e219e4e57}{domain\_\-findSplit} (int cpustart, int ncpu, int first, int \hyperlink{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}{last})
\item 
void \hyperlink{proto_8h_a89c54187117b91d4270a4f0c406ce2ba}{domain\_\-shiftSplit} (void)
\item 
void \hyperlink{proto_8h_a25aada0d3751c2afd2a376151d1d917e}{domain\_\-sumCost} (void)
\item 
void \hyperlink{proto_8h_a606de536756a67ad8f79f1135009195e}{domain\_\-topsplit} (int node, \hyperlink{allvars_8h_a63f10772bd5776dcb4b6301f425e0d26}{peanokey} startkey)
\item 
void \hyperlink{proto_8h_aa5001f9be833c4673392b40e7be3a421}{domain\_\-topsplit\_\-local} (int node, \hyperlink{allvars_8h_a63f10772bd5776dcb4b6301f425e0d26}{peanokey} startkey)
\item 
double \hyperlink{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e}{drift\_\-integ} (double a, void $\ast$param)
\item 
void \hyperlink{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0}{dump\_\-particles} (void)
\item 
void \hyperlink{proto_8h_a3757efb7e470353080a128388ccebec9}{empty\_\-read\_\-buffer} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr, int offset, int pc, int type)
\item 
void \hyperlink{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d}{endrun} (int)
\item 
void \hyperlink{proto_8h_ae903322da17c6875ab606b032b918099}{energy\_\-statistics} (void)
\item 
void \hyperlink{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d}{every\_\-timestep\_\-stuff} (void)
\item 
void \hyperlink{proto_8h_ad8b8e212e593e1795f6ba522239086fc}{ewald\_\-corr} (double dx, double dy, double dz, double $\ast$fper)
\item 
void \hyperlink{proto_8h_a0c4d2bd0695737095313d7dc47ce120c}{ewald\_\-force} (int ii, int jj, int kk, double x\mbox{[}3\mbox{]}, double force\mbox{[}3\mbox{]})
\item 
void \hyperlink{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6}{ewald\_\-init} (void)
\item 
double \hyperlink{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58}{ewald\_\-pot\_\-corr} (double dx, double dy, double dz)
\item 
double \hyperlink{proto_8h_a4a219224b239f0c20497e54ae421f134}{ewald\_\-psi} (double x\mbox{[}3\mbox{]})
\item 
void \hyperlink{proto_8h_a10281a87abe1e07d6ca603de6a533345}{fill\_\-Tab\_\-IO\_\-Labels} (void)
\item 
void \hyperlink{proto_8h_aea8fa222a10c4796687c6ff25550cd74}{fill\_\-write\_\-buffer} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr, int $\ast$pindex, int pc, int type)
\item 
void \hyperlink{proto_8h_a78ed439b8a1cb93647a2b9de998d9269}{find\_\-dt\_\-displacement\_\-constraint} (double hfac)
\item 
int \hyperlink{proto_8h_ac028b474d53a40e79377b7ae5dde636a}{find\_\-files} (char $\ast$fname)
\item 
int \hyperlink{proto_8h_a532b4637166ab194c1b1d0dee9f003f2}{find\_\-next\_\-outputtime} (int time)
\item 
void \hyperlink{proto_8h_ad52604af910b3e1677718d863ab09391}{find\_\-next\_\-sync\_\-point\_\-and\_\-drift} (void)
\item 
void \hyperlink{proto_8h_a8eaedfa5c6d72bca79b465003679ed89}{force\_\-create\_\-empty\_\-nodes} (int no, int topnode, int bits, int x, int y, int z, int $\ast$nodecount, int $\ast$nextfree)
\item 
void \hyperlink{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb}{force\_\-exchange\_\-pseudodata} (void)
\item 
void \hyperlink{proto_8h_a947a734f3bbba14d4092c7480880d3c7}{force\_\-flag\_\-localnodes} (void)
\item 
void \hyperlink{proto_8h_ad9e0a57b7577d64a315c142e197d292d}{force\_\-insert\_\-pseudo\_\-particles} (void)
\item 
void \hyperlink{proto_8h_ae809fba68f599de9874f593b77d0bbfd}{force\_\-setupnonrecursive} (int no)
\item 
void \hyperlink{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2}{force\_\-treeallocate} (int maxnodes, int maxpart)
\item 
int \hyperlink{proto_8h_a10f92098e86f82baec9f84a283f4c9e5}{force\_\-treebuild} (int npart)
\item 
int \hyperlink{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6}{force\_\-treebuild\_\-single} (int npart)
\item 
int \hyperlink{proto_8h_a59ae74ef51d6a7065605638422489391}{force\_\-treeevaluate} (int target, int mode, double $\ast$ewaldcountsum)
\item 
int \hyperlink{proto_8h_a0ec221b2517893874b12dc366bfe0da8}{force\_\-treeevaluate\_\-direct} (int target, int mode)
\item 
int \hyperlink{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f}{force\_\-treeevaluate\_\-ewald\_\-correction} (int target, int mode, double pos\_\-x, double pos\_\-y, double pos\_\-z, double aold)
\item 
void \hyperlink{proto_8h_a804166b1847da509d8fe57072b40d5f9}{force\_\-treeevaluate\_\-potential} (int target, int type)
\item 
void \hyperlink{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7}{force\_\-treeevaluate\_\-potential\_\-shortrange} (int target, int mode)
\item 
int \hyperlink{proto_8h_ae01e179b7686a7fe62970160b7bbdb46}{force\_\-treeevaluate\_\-shortrange} (int target, int mode)
\item 
void \hyperlink{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888}{force\_\-treefree} (void)
\item 
void \hyperlink{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19}{force\_\-treeupdate\_\-pseudos} (void)
\item 
void \hyperlink{proto_8h_a4764c1fb83a956c1712345538630854c}{force\_\-update\_\-hmax} (void)
\item 
void \hyperlink{proto_8h_a04fb647ef783d5baeb9275d806c08365}{force\_\-update\_\-len} (void)
\item 
void \hyperlink{proto_8h_a0292cb282788bf4e4f06636096c5abdf}{force\_\-update\_\-node} (int no, int flag)
\item 
void \hyperlink{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074}{force\_\-update\_\-node\_\-hmax\_\-local} (void)
\item 
void \hyperlink{proto_8h_ac3f5945bb7c73936ef49af1507265afe}{force\_\-update\_\-node\_\-hmax\_\-toptree} (void)
\item 
void \hyperlink{proto_8h_a4592b750f8555f580691103acf1e5366}{force\_\-update\_\-node\_\-len\_\-local} (void)
\item 
void \hyperlink{proto_8h_a5f85438d619d63c812c8e05faf1f0074}{force\_\-update\_\-node\_\-len\_\-toptree} (void)
\item 
void \hyperlink{proto_8h_ab745c54c805d07ad255a3f86ff77e18d}{force\_\-update\_\-node\_\-recursive} (int no, int sib, int father)
\item 
void \hyperlink{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0}{force\_\-update\_\-pseudoparticles} (void)
\item 
void \hyperlink{proto_8h_a207b80df2a123bc29295a0d496186d70}{force\_\-update\_\-size\_\-of\_\-parent\_\-node} (int no)
\item 
void \hyperlink{proto_8h_a99877ff0dc6228eabf8f959569f2771e}{free\_\-memory} (void)
\item 
int \hyperlink{proto_8h_a49492470fcccf9d05bf51993f281f16c}{get\_\-bytes\_\-per\_\-blockelement} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr)
\item 
void \hyperlink{proto_8h_a4d30ce1aad9c69d5af676a6a13173686}{get\_\-dataset\_\-name} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr, char $\ast$buf)
\item 
int \hyperlink{proto_8h_acdf59daa02f065452a596cf88b4de1a1}{get\_\-datatype\_\-in\_\-block} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr)
\item 
double \hyperlink{proto_8h_adadb384299eb936596574417d4b6b28c}{get\_\-drift\_\-factor} (int time0, int time1)
\item 
double \hyperlink{proto_8h_a29057b821b850ab54b318d7339633059}{get\_\-gravkick\_\-factor} (int time0, int time1)
\item 
double \hyperlink{proto_8h_ace65dca1556185b12c7f22427724c90c}{get\_\-hydrokick\_\-factor} (int time0, int time1)
\item 
int \hyperlink{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9}{get\_\-particles\_\-in\_\-block} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr, int $\ast$typelist)
\item 
double \hyperlink{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05}{get\_\-random\_\-number} (int id)
\item 
int \hyperlink{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8}{get\_\-timestep} (int p, double $\ast$a, int flag)
\item 
int \hyperlink{proto_8h_a3892776d6528c51f720d2a48deb2486f}{get\_\-values\_\-per\_\-blockelement} (enum \hyperlink{allvars_8h_a3f7452ec51c4f746e7070abd666147d8}{iofields} blocknr)
\item 
int \hyperlink{proto_8h_ae9c157451dcc4cdbe02813141df2be42}{grav\_\-tree\_\-compare\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79}{gravity\_\-forcetest} (void)
\item 
void \hyperlink{proto_8h_ac559dc2aeb21d5a379a3751bea7736af}{gravity\_\-tree} (void)
\item 
void \hyperlink{proto_8h_a483c8f5e73b8445bbb44e3bab59f2f1d}{gravity\_\-tree\_\-shortrange} (void)
\item 
double \hyperlink{proto_8h_a2eafe05fb12d7f9d954d5b501e186051}{gravkick\_\-integ} (double a, void $\ast$param)
\item 
int \hyperlink{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a}{hydro\_\-compare\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e}{hydro\_\-evaluate} (int target, int mode)
\item 
void \hyperlink{proto_8h_a6789381bce7d1c316df8ecf04b47a607}{hydro\_\-force} (void)
\item 
double \hyperlink{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d}{hydrokick\_\-integ} (double a, void $\ast$param)
\item 
int \hyperlink{proto_8h_a05ba897ffe0dfe737254a09c91c50d10}{imax} (int, int)
\item 
int \hyperlink{proto_8h_af52841aeeb1b5bf6787e1e2036088644}{imin} (int, int)
\item 
void \hyperlink{proto_8h_a2858154e2009b0e6e616f313177762bc}{init} (void)
\item 
void \hyperlink{proto_8h_aea1f81063199abb9d89802b444098018}{init\_\-drift\_\-table} (void)
\item 
void \hyperlink{proto_8h_a5052a0489feb425d7d910e57d7ad8102}{init\_\-peano\_\-map} (void)
\item 
void \hyperlink{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25}{long\_\-range\_\-force} (void)
\item 
void \hyperlink{proto_8h_af52079f2c63002aca9463ba0b13727df}{long\_\-range\_\-init} (void)
\item 
void \hyperlink{proto_8h_ad295b3023b3d8fad337637a640362262}{long\_\-range\_\-init\_\-regionsize} (void)
\item 
void \hyperlink{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31}{move\_\-particles} (int time0, int time1)
\item 
size\_\-t \hyperlink{proto_8h_a1609620c03f6b0068601735c42e3c660}{my\_\-fread} (void $\ast$ptr, size\_\-t size, size\_\-t nmemb, FILE $\ast$stream)
\item 
size\_\-t \hyperlink{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21}{my\_\-fwrite} (void $\ast$ptr, size\_\-t size, size\_\-t nmemb, FILE $\ast$stream)
\item 
int \hyperlink{proto_8h_a72ee1196e73c7c6e8683d35e4692d840}{ngb\_\-clear\_\-buf} (float searchcenter\mbox{[}3\mbox{]}, float hguess, int numngb)
\item 
void \hyperlink{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55}{ngb\_\-treeallocate} (int npart)
\item 
void \hyperlink{proto_8h_ac56af97a1dbbbbb07db8207246852f79}{ngb\_\-treebuild} (void)
\item 
int \hyperlink{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd}{ngb\_\-treefind\_\-pairs} (float searchcenter\mbox{[}3\mbox{]}, float hsml, int $\ast$startnode)
\item 
int \hyperlink{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8}{ngb\_\-treefind\_\-variable} (float searchcenter\mbox{[}3\mbox{]}, float hguess, int $\ast$startnode)
\item 
void \hyperlink{proto_8h_aab22cf240079ef5846d83729e4565f97}{ngb\_\-treefree} (void)
\item 
void \hyperlink{proto_8h_ab68e970cf33f44c3ff421fc2ea6e9290}{ngb\_\-treesearch} (int)
\item 
void \hyperlink{proto_8h_ad387916b04773b495483e10f3d24e9d6}{ngb\_\-treesearch\_\-pairs} (int)
\item 
void \hyperlink{proto_8h_a6895b316b66ff5f9f78910d65823bf00}{ngb\_\-update\_\-nodes} (void)
\item 
void \hyperlink{proto_8h_a6f629274f7b036874c743fb81d58ce68}{open\_\-outputfiles} (void)
\item 
\hyperlink{allvars_8h_a63f10772bd5776dcb4b6301f425e0d26}{peanokey} \hyperlink{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df}{peano\_\-hilbert\_\-key} (int x, int y, int z, int bits)
\item 
void \hyperlink{proto_8h_af3e45a4293584b3fe28e83af75c6ed71}{peano\_\-hilbert\_\-order} (void)
\item 
void \hyperlink{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0}{pm\_\-init\_\-nonperiodic} (void)
\item 
void \hyperlink{proto_8h_ac8030592010e755c61e6ee358ee0895d}{pm\_\-init\_\-nonperiodic\_\-allocate} (int dimprod)
\item 
void \hyperlink{proto_8h_afd73e48ecc5be43d057dd718f78d187d}{pm\_\-init\_\-nonperiodic\_\-free} (void)
\item 
void \hyperlink{proto_8h_a13e381f05efdb739cf5026384e908409}{pm\_\-init\_\-periodic} (void)
\item 
void \hyperlink{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e}{pm\_\-init\_\-periodic\_\-allocate} (int dimprod)
\item 
void \hyperlink{proto_8h_a259e6f8400ee889c64bc667334060742}{pm\_\-init\_\-periodic\_\-free} (void)
\item 
void \hyperlink{proto_8h_a57f2f415791cd83ace42bff59b2feb97}{pm\_\-init\_\-regionsize} (void)
\item 
void \hyperlink{proto_8h_ae3950c19708f6a2886dd32897efa10c4}{pm\_\-setup\_\-nonperiodic\_\-kernel} (void)
\item 
int \hyperlink{proto_8h_a8821224474d8690f0db99b8cfab3a8fc}{pmforce\_\-nonperiodic} (int grnr)
\item 
void \hyperlink{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b}{pmforce\_\-periodic} (void)
\item 
int \hyperlink{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9}{pmpotential\_\-nonperiodic} (int grnr)
\item 
void \hyperlink{proto_8h_a7938f2181f23d56ac46f3625d1a855a0}{pmpotential\_\-periodic} (void)
\item 
double \hyperlink{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e}{pow} (double, double)
\item 
void \hyperlink{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1}{read\_\-file} (char $\ast$fname, int readTask, int lastTask)
\item 
void \hyperlink{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9}{read\_\-header\_\-attributes\_\-in\_\-hdf5} (char $\ast$fname)
\item 
void \hyperlink{proto_8h_a150344fdc0c6e132aecdb6c646529df1}{read\_\-ic} (char $\ast$fname)
\item 
int \hyperlink{proto_8h_a849a294ac908c933ffb82dc4319af513}{read\_\-outputlist} (char $\ast$fname)
\item 
void \hyperlink{proto_8h_a952eae1977b498c4fdfabed1742a3ba2}{read\_\-parameter\_\-file} (char $\ast$fname)
\item 
void \hyperlink{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98}{readjust\_\-timebase} (double TimeMax\_\-old, double TimeMax\_\-new)
\item 
void \hyperlink{proto_8h_af744cef873e3093ba2924da8265d1711}{reorder\_\-gas} (void)
\item 
void \hyperlink{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba}{reorder\_\-particles} (void)
\item 
void \hyperlink{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}{restart} (int mod)
\item 
void \hyperlink{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2}{run} (void)
\item 
void \hyperlink{proto_8h_a523730833804b6d92aa7f4dd474805c5}{savepositions} (int num)
\item 
double \hyperlink{proto_8h_ad24c35a2016ce428248988795c1d3174}{second} (void)
\item 
void \hyperlink{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135}{seed\_\-glass} (void)
\item 
void \hyperlink{proto_8h_a9cb45ef22cae101906f021fb7a23afbe}{set\_\-random\_\-numbers} (void)
\item 
void \hyperlink{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91}{set\_\-softenings} (void)
\item 
void \hyperlink{proto_8h_aba986f6be1d66945199c7ea43e5c9610}{set\_\-units} (void)
\item 
void \hyperlink{proto_8h_abca44f066552d38c44a1cd6020d349d5}{setup\_\-smoothinglengths} (void)
\item 
void \hyperlink{proto_8h_ad47ac005519641e0cfc423c3802d3ef2}{statistics} (void)
\item 
void \hyperlink{proto_8h_a869daac8b2af5667db265026f09fb9d8}{terminate\_\-processes} (void)
\item 
double \hyperlink{proto_8h_a890645bdc4536bd797ca53028072e30d}{timediff} (double t0, double t1)
\item 
void \hyperlink{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf}{write\_\-header\_\-attributes\_\-in\_\-hdf5} (hid\_\-t handle)
\item 
void \hyperlink{proto_8h_a48b0ed3a843924501df8ed871e08e77c}{write\_\-file} (char $\ast$fname, int readTask, int lastTask)
\item 
void \hyperlink{proto_8h_a38a8b7521229c82f0f4146f60b88d9c5}{write\_\-pid\_\-file} (void)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
this file contains all function prototypes of the code 

Definition in file \hyperlink{proto_8h_source}{proto.h}.



\subsection{Function Documentation}
\hypertarget{proto_8h_a05e5a546d63684b55d2457aa56efdd06}{
\index{proto.h@{proto.h}!advance\_\-and\_\-find\_\-timesteps@{advance\_\-and\_\-find\_\-timesteps}}
\index{advance\_\-and\_\-find\_\-timesteps@{advance\_\-and\_\-find\_\-timesteps}!proto.h@{proto.h}}
\subsubsection[{advance\_\-and\_\-find\_\-timesteps}]{\setlength{\rightskip}{0pt plus 5cm}void advance\_\-and\_\-find\_\-timesteps (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a05e5a546d63684b55d2457aa56efdd06}
This function advances the system in momentum space, i.e. it does apply the 'kick' operation after the forces have been computed. Additionally, it assigns new timesteps to particles. At start-\/up, a half-\/timestep is carried out, as well as at the end of the simulation. In between, the half-\/step kick that ends the previous timestep and the half-\/step kick for the new timestep are combined into one operation. 

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 



Definition at line 24 of file timestep.c.



References a3inv, All, atime, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-TimeLine, NODE::d, dt\_\-displacement, sph\_\-particle\_\-data::DtEntropy, sph\_\-particle\_\-data::Entropy, Extnodes, fac1, fac2, fac3, Father, find\_\-dt\_\-displacement\_\-constraint(), Flag\_\-FullStep, FLOAT, global\_\-data\_\-all\_\-processes::G, GAMMA, GAMMA\_\-MINUS1, get\_\-gravkick\_\-factor(), get\_\-hydrokick\_\-factor(), get\_\-random\_\-number(), get\_\-timestep(), particle\_\-data::GravAccel, particle\_\-data::GravPM, global\_\-data\_\-all\_\-processes::Hubble, hubble\_\-a, sph\_\-particle\_\-data::HydroAccel, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, global\_\-data\_\-all\_\-processes::MinEgySpec, Nodes, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-begstep, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, particle\_\-data::Pos, pow(), second(), SphP, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, TIMEBASE, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, timediff(), global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, NODE::u, particle\_\-data::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by run().




\begin{DoxyCode}
{
  int i, j, no, ti_step, ti_min, tend, tstart;
  double dt_entr, dt_entr2, dt_gravkick, dt_hydrokick, dt_gravkick2, dt_hydrokick
      2, t0, t1;
  double minentropy, aphys;
  FLOAT dv[3];

#ifdef FLEXSTEPS
  int ti_grp;
#endif
#if defined(PSEUDOSYMMETRIC) && !defined(FLEXSTEPS)
  double apred, prob;
  int ti_step2;
#endif
#ifdef PMGRID
  double dt_gravkickA, dt_gravkickB;
#endif
#ifdef MAKEGLASS
  double disp, dispmax, globmax, dmean, fac, disp2sum, globdisp2sum;
#endif

  t0 = second();

  if(All.ComovingIntegrationOn)
    {
      fac1 = 1 / (All.Time * All.Time);
      fac2 = 1 / pow(All.Time, 3 * GAMMA - 2);
      fac3 = pow(All.Time, 3 * (1 - GAMMA) / 2.0);
      hubble_a = All.Omega0 / (All.Time * All.Time * All.Time)
        + (1 - All.Omega0 - All.OmegaLambda) / (All.Time * All.Time) + All.
      OmegaLambda;

      hubble_a = All.Hubble * sqrt(hubble_a);
      a3inv = 1 / (All.Time * All.Time * All.Time);
      atime = All.Time;
    }
  else
    fac1 = fac2 = fac3 = hubble_a = a3inv = atime = 1;

#ifdef NOPMSTEPADJUSTMENT
  dt_displacement = All.MaxSizeTimestep;
#else
  if(Flag_FullStep || dt_displacement == 0)
    find_dt_displacement_constraint(hubble_a * atime * atime);
#endif

#ifdef PMGRID
  if(All.ComovingIntegrationOn)
    dt_gravkickB = get_gravkick_factor(All.PM_Ti_begstep, All.Ti_Current) -
      get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
  else
    dt_gravkickB = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep) / 2)
       * All.Timebase_interval;

  if(All.PM_Ti_endstep == All.Ti_Current)       /* need to do long-range kick */
    {
      /* make sure that we reconstruct the domain/tree next time because we don't
       kick the tree nodes in this case */
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
    }
#endif


#ifdef MAKEGLASS
  for(i = 0, dispmax = 0, disp2sum = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          P[i].GravPM[j] *= -1;
          P[i].GravAccel[j] *= -1;
          P[i].GravAccel[j] += P[i].GravPM[j];
          P[i].GravPM[j] = 0;
        }

      disp = sqrt(P[i].GravAccel[0] * P[i].GravAccel[0] +
                  P[i].GravAccel[1] * P[i].GravAccel[1] + P[i].GravAccel[2] * P[i
      ].GravAccel[2]);

      disp *= 2.0 / (3 * All.Hubble * All.Hubble);

      disp2sum += disp * disp;

      if(disp > dispmax)
        dispmax = disp;
    }

  MPI_Allreduce(&dispmax, &globmax, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
  MPI_Allreduce(&disp2sum, &globdisp2sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD)
      ;

  dmean = pow(P[0].Mass / (All.Omega0 * 3 * All.Hubble * All.Hubble / (8 * M_PI *
       All.G)), 1.0 / 3);

  if(globmax > dmean)
    fac = dmean / globmax;
  else
    fac = 1.0;

  if(ThisTask == 0)
    {
      printf("\nglass-making:  dmean= %g  global disp-maximum= %g  rms= %g\n\n",
             dmean, globmax, sqrt(globdisp2sum / All.TotNumPart));
      fflush(stdout);
    }

  for(i = 0, dispmax = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          P[i].Vel[j] = 0;
          P[i].Pos[j] += fac * P[i].GravAccel[j] * 2.0 / (3 * All.Hubble * All.
      Hubble);
          P[i].GravAccel[j] = 0;
        }
    }
#endif




  /* Now assign new timesteps and kick */

#ifdef FLEXSTEPS
  if((All.Ti_Current % (4 * All.PresentMinStep)) == 0)
    if(All.PresentMinStep < TIMEBASE)
      All.PresentMinStep *= 2;

  for(i = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          ti_step = get_timestep(i, &aphys, 0);

          /* make it a power 2 subdivision */
          ti_min = TIMEBASE;
          while(ti_min > ti_step)
            ti_min >>= 1;
          ti_step = ti_min;

          if(ti_step < All.PresentMinStep)
            All.PresentMinStep = ti_step;
        }
    }

  ti_step = All.PresentMinStep;
  MPI_Allreduce(&ti_step, &All.PresentMinStep, 1, MPI_INT, MPI_MIN, MPI_COMM_WORL
      D);

  if(dt_displacement < All.MaxSizeTimestep)
    ti_step = (int) (dt_displacement / All.Timebase_interval);
  else
    ti_step = (int) (All.MaxSizeTimestep / All.Timebase_interval);

  /* make it a power 2 subdivision */
  ti_min = TIMEBASE;
  while(ti_min > ti_step)
    ti_min >>= 1;
  All.PresentMaxStep = ti_min;


  if(ThisTask == 0)
    printf("Syn Range = %g  PresentMinStep = %d  PresentMaxStep = %d \n",
           (double) All.PresentMaxStep / All.PresentMinStep, All.PresentMinStep, 
      All.PresentMaxStep);

#endif


  for(i = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          ti_step = get_timestep(i, &aphys, 0);

          /* make it a power 2 subdivision */
          ti_min = TIMEBASE;
          while(ti_min > ti_step)
            ti_min >>= 1;
          ti_step = ti_min;

#ifdef FLEXSTEPS
          ti_grp = P[i].FlexStepGrp % All.PresentMaxStep;
          ti_grp = (ti_grp / All.PresentMinStep) * All.PresentMinStep;
          ti_step = ((P[i].Ti_endstep + ti_grp + ti_step) / ti_step) * ti_step - 
      (P[i].Ti_endstep + ti_grp);
#else

#ifdef PSEUDOSYMMETRIC
          if(P[i].Type != 0)
            {
              if(P[i].Ti_endstep > P[i].Ti_begstep)
                {
                  apred = aphys + ((aphys - P[i].AphysOld) / (P[i].Ti_endstep - 
      P[i].Ti_begstep)) * ti_step;
                  if(fabs(apred - aphys) < 0.5 * aphys)
                    {
                      ti_step2 = get_timestep(i, &apred, -1);
                      ti_min = TIMEBASE;
                      while(ti_min > ti_step2)
                        ti_min >>= 1;
                      ti_step2 = ti_min;

                      if(ti_step2 < ti_step)
                        {
                          get_timestep(i, &apred, ti_step);
                          prob =
                            ((apred - aphys) / (aphys - P[i].AphysOld) * (P[i].
      Ti_endstep -
                                                                          P[i].
      Ti_begstep)) / ti_step;
                          if(prob < get_random_number(P[i].ID))
                            ti_step /= 2;
                        }
                      else if(ti_step2 > ti_step)
                        {
                          get_timestep(i, &apred, 2 * ti_step);
                          prob =
                            ((apred - aphys) / (aphys - P[i].AphysOld) * (P[i].
      Ti_endstep -
                                                                          P[i].
      Ti_begstep)) / ti_step;
                          if(prob < get_random_number(P[i].ID + 1))
                            ti_step *= 2;
                        }
                    }
                }
              P[i].AphysOld = aphys;
            }
#endif

#ifdef SYNCHRONIZATION
          if(ti_step > (P[i].Ti_endstep - P[i].Ti_begstep))     /* timestep wants
       to increase */
            {
              if(((TIMEBASE - P[i].Ti_endstep) % ti_step) > 0)
                ti_step = P[i].Ti_endstep - P[i].Ti_begstep;    /* leave at old s
      tep */
            }
#endif
#endif /* end of FLEXSTEPS */

          if(All.Ti_Current == TIMEBASE)        /* we here finish the last timest
      ep. */
            ti_step = 0;

          if((TIMEBASE - All.Ti_Current) < ti_step)     /* check that we don't ru
      n beyond the end */
            ti_step = TIMEBASE - All.Ti_Current;

          tstart = (P[i].Ti_begstep + P[i].Ti_endstep) / 2;     /* midpoint of ol
      d step */
          tend = P[i].Ti_endstep + ti_step / 2; /* midpoint of new step */

          if(All.ComovingIntegrationOn)
            {
              dt_entr = (tend - tstart) * All.Timebase_interval;
              dt_entr2 = (tend - P[i].Ti_endstep) * All.Timebase_interval;
              dt_gravkick = get_gravkick_factor(tstart, tend);
              dt_hydrokick = get_hydrokick_factor(tstart, tend);
              dt_gravkick2 = get_gravkick_factor(P[i].Ti_endstep, tend);
              dt_hydrokick2 = get_hydrokick_factor(P[i].Ti_endstep, tend);
            }
          else
            {
              dt_entr = dt_gravkick = dt_hydrokick = (tend - tstart) * All.
      Timebase_interval;
              dt_gravkick2 = dt_hydrokick2 = dt_entr2 = (tend - P[i].Ti_endstep) 
      * All.Timebase_interval;
            }

          P[i].Ti_begstep = P[i].Ti_endstep;
          P[i].Ti_endstep = P[i].Ti_begstep + ti_step;


          /* do the kick */

          for(j = 0; j < 3; j++)
            {
              dv[j] = P[i].GravAccel[j] * dt_gravkick;
              P[i].Vel[j] += dv[j];
            }

          if(P[i].Type == 0)    /* SPH stuff */
            {
              for(j = 0; j < 3; j++)
                {
                  dv[j] += SphP[i].HydroAccel[j] * dt_hydrokick;
                  P[i].Vel[j] += SphP[i].HydroAccel[j] * dt_hydrokick;

                  SphP[i].VelPred[j] =
                    P[i].Vel[j] - dt_gravkick2 * P[i].GravAccel[j] - dt_hydrokick
      2 * SphP[i].HydroAccel[j];
#ifdef PMGRID
                  SphP[i].VelPred[j] += P[i].GravPM[j] * dt_gravkickB;
#endif
                }

              /* In case of cooling, we prevent that the entropy (and
                 hence temperature decreases by more than a factor 0.5 */

              if(SphP[i].DtEntropy * dt_entr > -0.5 * SphP[i].Entropy)
                SphP[i].Entropy += SphP[i].DtEntropy * dt_entr;
              else
                SphP[i].Entropy *= 0.5;

              if(All.MinEgySpec)
                {
                  minentropy = All.MinEgySpec * GAMMA_MINUS1 / pow(SphP[i].Densit
      y * a3inv, GAMMA_MINUS1);
                  if(SphP[i].Entropy < minentropy)
                    {
                      SphP[i].Entropy = minentropy;
                      SphP[i].DtEntropy = 0;
                    }
                }

              /* In case the timestep increases in the new step, we
                 make sure that we do not 'overcool' when deriving
                 predicted temperatures. The maximum timespan over
                 which prediction can occur is ti_step/2, i.e. from
                 the middle to the end of the current step */

              dt_entr = ti_step / 2 * All.Timebase_interval;
              if(SphP[i].Entropy + SphP[i].DtEntropy * dt_entr < 0.5 * SphP[i].En
      tropy)
                SphP[i].DtEntropy = -0.5 * SphP[i].Entropy / dt_entr;
            }


          /* if tree is not going to be reconstructed, kick parent nodes dynamica
      lly.
           */
          if(All.NumForcesSinceLastDomainDecomp < All.TotNumPart * All.
      TreeDomainUpdateFrequency)
            {
              no = Father[i];
              while(no >= 0)
                {
                  for(j = 0; j < 3; j++)
                    Extnodes[no].vs[j] += dv[j] * P[i].Mass / Nodes[no].u.d.mass;
      

                  no = Nodes[no].u.d.father;
                }
            }
        }
    }



#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)       /* need to do long-range kick */
    {
      ti_step = TIMEBASE;
      while(ti_step > (dt_displacement / All.Timebase_interval))
        ti_step >>= 1;

      if(ti_step > (All.PM_Ti_endstep - All.PM_Ti_begstep))     /* PM-timestep wa
      nts to increase */
        {
          /* we only increase if an integer number of steps will bring us to the 
      end */
          if(((TIMEBASE - All.PM_Ti_endstep) % ti_step) > 0)
            ti_step = All.PM_Ti_endstep - All.PM_Ti_begstep;    /* leave at old s
      tep */
        }

      if(All.Ti_Current == TIMEBASE)    /* we here finish the last timestep. */
        ti_step = 0;

      tstart = (All.PM_Ti_begstep + All.PM_Ti_endstep) / 2;
      tend = All.PM_Ti_endstep + ti_step / 2;

      if(All.ComovingIntegrationOn)
        dt_gravkick = get_gravkick_factor(tstart, tend);
      else
        dt_gravkick = (tend - tstart) * All.Timebase_interval;

      All.PM_Ti_begstep = All.PM_Ti_endstep;
      All.PM_Ti_endstep = All.PM_Ti_begstep + ti_step;

      if(All.ComovingIntegrationOn)
        dt_gravkickB = -get_gravkick_factor(All.PM_Ti_begstep, (All.
      PM_Ti_begstep + All.PM_Ti_endstep) / 2);
      else
        dt_gravkickB =
          -((All.PM_Ti_begstep + All.PM_Ti_endstep) / 2 - All.PM_Ti_begstep) * 
      All.Timebase_interval;

      for(i = 0; i < NumPart; i++)
        {
          for(j = 0; j < 3; j++)        /* do the kick */
            P[i].Vel[j] += P[i].GravPM[j] * dt_gravkick;

          if(P[i].Type == 0)
            {
              if(All.ComovingIntegrationOn)
                {
                  dt_gravkickA = get_gravkick_factor(P[i].Ti_begstep, All.
      Ti_Current) -
                    get_gravkick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i].
      Ti_endstep) / 2);
                  dt_hydrokick = get_hydrokick_factor(P[i].Ti_begstep, All.
      Ti_Current) -
                    get_hydrokick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i]
      .Ti_endstep) / 2);
                }
              else
                dt_gravkickA = dt_hydrokick =
                  (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * 
      All.Timebase_interval;

              for(j = 0; j < 3; j++)
                SphP[i].VelPred[j] = P[i].Vel[j]
                  + P[i].GravAccel[j] * dt_gravkickA
                  + SphP[i].HydroAccel[j] * dt_hydrokick + P[i].GravPM[j] * dt_gr
      avkickB;
            }
        }
    }
#endif

  t1 = second();
  All.CPU_TimeLine += timediff(t0, t1);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a05e5a546d63684b55d2457aa56efdd06_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=382pt]{proto_8h_a05e5a546d63684b55d2457aa56efdd06_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9e761db39213af33ba28aeed461f1a5a}{
\index{proto.h@{proto.h}!allocate\_\-commbuffers@{allocate\_\-commbuffers}}
\index{allocate\_\-commbuffers@{allocate\_\-commbuffers}!proto.h@{proto.h}}
\subsubsection[{allocate\_\-commbuffers}]{\setlength{\rightskip}{0pt plus 5cm}void allocate\_\-commbuffers (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a9e761db39213af33ba28aeed461f1a5a}
Allocates a number of small buffers and arrays, the largest one being the communication buffer. The communication buffer itself is mapped onto various tables used in the different parts of the force algorithms. We further allocate space for the top-\/level tree nodes, and auxiliary arrays for the domain decomposition algorithm. 

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition 



Definition at line 19 of file allocate.c.



References All, global\_\-data\_\-all\_\-processes::BufferSize, global\_\-data\_\-all\_\-processes::BunchSizeDensity, global\_\-data\_\-all\_\-processes::BunchSizeDomain, global\_\-data\_\-all\_\-processes::BunchSizeForce, global\_\-data\_\-all\_\-processes::BunchSizeHydro, CommBuffer, DensDataGet, DensDataIn, DensDataPartialResult, DensDataResult, DomainCount, DomainCountSph, DomainEndList, DomainHmax, DomainKeyBuf, DomainMoment, DomainNodeIndex, DomainPartBuf, DomainSphBuf, DomainStartList, DomainTask, DomainTreeNodeLen, DomainWork, endrun(), Exportflag, FLOAT, GravDataGet, GravDataIn, GravDataIndexTable, GravDataOut, GravDataResult, HydroDataGet, HydroDataIn, HydroDataPartialResult, HydroDataResult, MAXTOPNODES, NTask, ThisTask, and TopNodes.



Referenced by begrun().




\begin{DoxyCode}
{
  size_t bytes;

  Exportflag = malloc(NTask * sizeof(char));
  DomainStartList = malloc(NTask * sizeof(int));
  DomainEndList = malloc(NTask * sizeof(int));

  TopNodes = malloc(MAXTOPNODES * sizeof(struct topnode_data));

  DomainWork = malloc(MAXTOPNODES * sizeof(double));
  DomainCount = malloc(MAXTOPNODES * sizeof(int));
  DomainCountSph = malloc(MAXTOPNODES * sizeof(int));
  DomainTask = malloc(MAXTOPNODES * sizeof(int));
  DomainNodeIndex = malloc(MAXTOPNODES * sizeof(int));
  DomainTreeNodeLen = malloc(MAXTOPNODES * sizeof(FLOAT));
  DomainHmax = malloc(MAXTOPNODES * sizeof(FLOAT));
  DomainMoment = malloc(MAXTOPNODES * sizeof(struct DomainNODE));

  if(!(CommBuffer = malloc(bytes = All.BufferSize * 1024 * 1024)))
    {
      printf("failed to allocate memory for `CommBuffer' (%g MB).\n", bytes / (10
      24.0 * 1024.0));
      endrun(2);
    }

  All.BunchSizeForce =
    (All.BufferSize * 1024 * 1024) / (sizeof(struct gravdata_index) + 2 * sizeof(
      struct gravdata_in));

  if(All.BunchSizeForce & 1)
    All.BunchSizeForce -= 1;    /* make sure that All.BunchSizeForce is an even n
      umber 
                                   --> 8-byte alignment for 64bit processors */

  GravDataIndexTable = (struct gravdata_index *) CommBuffer;
  GravDataIn = (struct gravdata_in *) (GravDataIndexTable + All.BunchSizeForce);
  GravDataGet = GravDataIn + All.BunchSizeForce;
  GravDataOut = GravDataIn;     /* this will overwrite the GravDataIn-Table */
  GravDataResult = GravDataGet; /* this will overwrite the GravDataGet-Table */


  All.BunchSizeDensity =
    (All.BufferSize * 1024 * 1024) / (2 * sizeof(struct densdata_in) + 2 * sizeof
      (struct densdata_out));

  DensDataIn = (struct densdata_in *) CommBuffer;
  DensDataGet = DensDataIn + All.BunchSizeDensity;
  DensDataResult = (struct densdata_out *) (DensDataGet + All.BunchSizeDensity);
  DensDataPartialResult = DensDataResult + All.BunchSizeDensity;

  All.BunchSizeHydro =
    (All.BufferSize * 1024 * 1024) / (2 * sizeof(struct hydrodata_in) + 2 * sizeo
      f(struct hydrodata_out));

  HydroDataIn = (struct hydrodata_in *) CommBuffer;
  HydroDataGet = HydroDataIn + All.BunchSizeHydro;
  HydroDataResult = (struct hydrodata_out *) (HydroDataGet + All.BunchSizeHydro);
      
  HydroDataPartialResult = HydroDataResult + All.BunchSizeHydro;

  All.BunchSizeDomain =
    (All.BufferSize * 1024 * 1024) / (sizeof(struct particle_data) + sizeof(struc
      t sph_particle_data) +
                                      sizeof(peanokey));

  if(All.BunchSizeDomain & 1)
    All.BunchSizeDomain -= 1;   /* make sure that All.BunchSizeDomain is even 
                                   --> 8-byte alignment of DomainKeyBuf for 64bit
       processors */

  DomainPartBuf = (struct particle_data *) CommBuffer;
  DomainSphBuf = (struct sph_particle_data *) (DomainPartBuf + All.
      BunchSizeDomain);
  DomainKeyBuf = (peanokey *) (DomainSphBuf + All.BunchSizeDomain);


  if(ThisTask == 0)
    {
      printf("\nAllocated %d MByte communication buffer per processor.\n\n", All.
      BufferSize);
      printf("Communication buffer has room for %d particles in gravity computati
      on\n", All.BunchSizeForce);
      printf("Communication buffer has room for %d particles in density computati
      on\n", All.BunchSizeDensity);
      printf("Communication buffer has room for %d particles in hydro computation
      \n", All.BunchSizeHydro);
      printf("Communication buffer has room for %d particles in domain decomposit
      ion\n", All.BunchSizeDomain);
      printf("\n");
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a9e761db39213af33ba28aeed461f1a5a_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=368pt]{proto_8h_a9e761db39213af33ba28aeed461f1a5a_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7}{
\index{proto.h@{proto.h}!allocate\_\-memory@{allocate\_\-memory}}
\index{allocate\_\-memory@{allocate\_\-memory}!proto.h@{proto.h}}
\subsubsection[{allocate\_\-memory}]{\setlength{\rightskip}{0pt plus 5cm}void allocate\_\-memory (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7}
This routine allocates memory for particle storage, both the collisionless and the SPH particles. 

Definition at line 103 of file allocate.c.



References All, endrun(), global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MaxPartSph, P, SphP, and ThisTask.



Referenced by read\_\-file(), and restart().




\begin{DoxyCode}
{
  size_t bytes;
  double bytes_tot = 0;

  if(All.MaxPart > 0)
    {
      if(!(P = malloc(bytes = All.MaxPart * sizeof(struct particle_data))))
        {
          printf("failed to allocate memory for `P' (%g MB).\n", bytes / (1024.0 
      * 1024.0));
          endrun(1);
        }
      bytes_tot += bytes;

      if(ThisTask == 0)
        printf("\nAllocated %g MByte for particle storage. %lu\n\n", bytes_tot / 
      (1024.0 * 1024.0), sizeof(struct particle_data));
    }

  if(All.MaxPartSph > 0)
    {
      bytes_tot = 0;

      if(!(SphP = malloc(bytes = All.MaxPartSph * sizeof(struct 
      sph_particle_data))))
        {
          printf("failed to allocate memory for `SphP' (%g MB) %lu.\n", bytes / (
      1024.0 * 1024.0), sizeof(struct sph_particle_data));
          endrun(1);
        }
      bytes_tot += bytes;

      if(ThisTask == 0)
        printf("Allocated %g MByte for storage of SPH data. %lu\n\n", bytes_tot /
       (1024.0 * 1024.0), sizeof(struct sph_particle_data));
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aceeb5c8909331b90ea8345e0fc853f82}{
\index{proto.h@{proto.h}!begrun@{begrun}}
\index{begrun@{begrun}!proto.h@{proto.h}}
\subsubsection[{begrun}]{\setlength{\rightskip}{0pt plus 5cm}void begrun (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aceeb5c8909331b90ea8345e0fc853f82}
This function performs the initial set-\/up of the simulation. First, the parameterfile is set, then routines for setting units, reading ICs/restart-\/files are called, auxialiary memory is allocated, etc. 

$<$ code version string 



Definition at line 28 of file begrun.c.



References All, allocate\_\-commbuffers(), global\_\-data\_\-all\_\-processes::ArtBulkViscConst, global\_\-data\_\-all\_\-processes::BufferSize, global\_\-data\_\-all\_\-processes::BunchSizeDensity, global\_\-data\_\-all\_\-processes::BunchSizeDomain, global\_\-data\_\-all\_\-processes::BunchSizeForce, global\_\-data\_\-all\_\-processes::BunchSizeHydro, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CourantFac, global\_\-data\_\-all\_\-processes::CpuFile, CPUThisRun, global\_\-data\_\-all\_\-processes::CpuTimeBetRestartFile, global\_\-data\_\-all\_\-processes::EnergyFile, global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolIntAccuracy, ewald\_\-init(), find\_\-next\_\-outputtime(), GADGETVERSION, global\_\-data\_\-all\_\-processes::InfoFile, init(), init\_\-drift\_\-table(), init\_\-geofactor\_\-table(), long\_\-range\_\-init(), long\_\-range\_\-init\_\-regionsize(), global\_\-data\_\-all\_\-processes::MaxNumNgbDeviation, global\_\-data\_\-all\_\-processes::MaxRMSDisplacementFac, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, global\_\-data\_\-all\_\-processes::MinSizeTimestep, NTask, global\_\-data\_\-all\_\-processes::NumFilesPerSnapshot, global\_\-data\_\-all\_\-processes::NumFilesWrittenInParallel, open\_\-outputfiles(), global\_\-data\_\-all\_\-processes::OutputDir, global\_\-data\_\-all\_\-processes::OutputListFilename, global\_\-data\_\-all\_\-processes::OutputListLength, global\_\-data\_\-all\_\-processes::OutputListOn, global\_\-data\_\-all\_\-processes::OutputListTimes, ParameterFile, random\_\-generator, read\_\-parameter\_\-file(), readjust\_\-timebase(), restart(), global\_\-data\_\-all\_\-processes::RestartFile, RestartFlag, global\_\-data\_\-all\_\-processes::ResubmitCommand, global\_\-data\_\-all\_\-processes::ResubmitOn, set\_\-random\_\-numbers(), set\_\-units(), global\_\-data\_\-all\_\-processes::SnapFormat, global\_\-data\_\-all\_\-processes::SnapshotFileBase, ThisTask, global\_\-data\_\-all\_\-processes::Ti\_\-Current, global\_\-data\_\-all\_\-processes::Ti\_\-nextoutput, global\_\-data\_\-all\_\-processes::TimeBetSnapshot, global\_\-data\_\-all\_\-processes::TimeBetStatistics, global\_\-data\_\-all\_\-processes::TimeLastRestartFile, global\_\-data\_\-all\_\-processes::TimeLimitCPU, global\_\-data\_\-all\_\-processes::TimeMax, global\_\-data\_\-all\_\-processes::TimingsFile, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, global\_\-data\_\-all\_\-processes::TypeOfOpeningCriterion, and global\_\-data\_\-all\_\-processes::TypeOfTimestepCriterion.



Referenced by main().




\begin{DoxyCode}
{
  struct global_data_all_processes all;

  if(ThisTask == 0)
    {
      printf("\nThis is Gadget, version `%s'.\n", GADGETVERSION);
      printf("\nRunning on %d processors.\n", NTask);
    }

  read_parameter_file(ParameterFile);   /* ... read in parameters for this run */
      

  allocate_commbuffers();       /* ... allocate buffer-memory for particle 
                                   exchange during force computation */
  set_units();

#if defined(PERIODIC) && (!defined(PMGRID) || defined(FORCETEST))
  ewald_init();
#endif

  open_outputfiles();

  random_generator = gsl_rng_alloc(gsl_rng_ranlxd1);
  gsl_rng_set(random_generator, 42);    /* start-up seed */

#ifdef PMGRID
  long_range_init();
#endif

  All.TimeLastRestartFile = CPUThisRun;

  if(RestartFlag == 0 || RestartFlag == 2)
    {
      set_random_numbers();

      init();                   /* ... read in initial model */
    }
  else
    {
      all = All;                /* save global variables. (will be read from rest
      art file) */

      restart(RestartFlag);     /* ... read restart file. Note: This also resets 
      
                                   all variables in the struct `All'. 
                                   However, during the run, some variables in the
       parameter
                                   file are allowed to be changed, if desired. Th
      ese need to 
                                   copied in the way below.
                                   Note:  All.PartAllocFactor is treated in resta
      rt() separately.  
                                 */

      All.MinSizeTimestep = all.MinSizeTimestep;
      All.MaxSizeTimestep = all.MaxSizeTimestep;
      All.BufferSize = all.BufferSize;
      All.BunchSizeForce = all.BunchSizeForce;
      All.BunchSizeDensity = all.BunchSizeDensity;
      All.BunchSizeHydro = all.BunchSizeHydro;
      All.BunchSizeDomain = all.BunchSizeDomain;

      All.TimeLimitCPU = all.TimeLimitCPU;
      All.ResubmitOn = all.ResubmitOn;
      All.TimeBetSnapshot = all.TimeBetSnapshot;
      All.TimeBetStatistics = all.TimeBetStatistics;
      All.CpuTimeBetRestartFile = all.CpuTimeBetRestartFile;
      All.ErrTolIntAccuracy = all.ErrTolIntAccuracy;
      All.MaxRMSDisplacementFac = all.MaxRMSDisplacementFac;

      All.ErrTolForceAcc = all.ErrTolForceAcc;

      All.TypeOfTimestepCriterion = all.TypeOfTimestepCriterion;
      All.TypeOfOpeningCriterion = all.TypeOfOpeningCriterion;
      All.NumFilesWrittenInParallel = all.NumFilesWrittenInParallel;
      All.TreeDomainUpdateFrequency = all.TreeDomainUpdateFrequency;

      All.SnapFormat = all.SnapFormat;
      All.NumFilesPerSnapshot = all.NumFilesPerSnapshot;
      All.MaxNumNgbDeviation = all.MaxNumNgbDeviation;
      All.ArtBulkViscConst = all.ArtBulkViscConst;


      All.OutputListOn = all.OutputListOn;
      All.CourantFac = all.CourantFac;

      All.OutputListLength = all.OutputListLength;
      memcpy(All.OutputListTimes, all.OutputListTimes, sizeof(double) * All.
      OutputListLength);


      strcpy(All.ResubmitCommand, all.ResubmitCommand);
      strcpy(All.OutputListFilename, all.OutputListFilename);
      strcpy(All.OutputDir, all.OutputDir);
      strcpy(All.RestartFile, all.RestartFile);
      strcpy(All.EnergyFile, all.EnergyFile);
      strcpy(All.InfoFile, all.InfoFile);
      strcpy(All.CpuFile, all.CpuFile);
      strcpy(All.TimingsFile, all.TimingsFile);
      strcpy(All.SnapshotFileBase, all.SnapshotFileBase);

      if(All.TimeMax != all.TimeMax)
        readjust_timebase(All.TimeMax, all.TimeMax);
    }

#ifdef PMGRID
  long_range_init_regionsize();
#endif
 
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  init_geofactor_table();
#endif
 
  if(All.ComovingIntegrationOn)
    init_drift_table();

  if(RestartFlag == 2)
    All.Ti_nextoutput = find_next_outputtime(All.Ti_Current + 1);
  else
    All.Ti_nextoutput = find_next_outputtime(All.Ti_Current);


  All.TimeLastRestartFile = CPUThisRun;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aceeb5c8909331b90ea8345e0fc853f82_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=208pt]{proto_8h_aceeb5c8909331b90ea8345e0fc853f82_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e}{
\index{proto.h@{proto.h}!blockpresent@{blockpresent}}
\index{blockpresent@{blockpresent}!proto.h@{proto.h}}
\subsubsection[{blockpresent}]{\setlength{\rightskip}{0pt plus 5cm}int blockpresent (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e}
This function tells whether or not a given block in the output file is present, depending on the type of simulation run and the compile-\/time options. If one wants to add a new output-\/block, this function should be augmented accordingly. 

Definition at line 532 of file io.c.



References IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-POT, and IO\_\-TSTP.



Referenced by read\_\-file(), and write\_\-file().




\begin{DoxyCode}
{

#ifndef OUTPUTPOTENTIAL
  if(blocknr == IO_POT)
    return 0;
#endif

#ifndef OUTPUTACCELERATION
  if(blocknr == IO_ACCEL)
    return 0;
#endif

#ifndef OUTPUTCHANGEOFENTROPY
  if(blocknr == IO_DTENTR)
    return 0;
#endif

#ifndef OUTPUTTIMESTEP
  if(blocknr == IO_TSTP)
    return 0;
#endif

  return 1;                     /* default: present */
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_adf560a3f7c53865f7edbf9ff3b16c8fd}{
\index{proto.h@{proto.h}!catch\_\-abort@{catch\_\-abort}}
\index{catch\_\-abort@{catch\_\-abort}!proto.h@{proto.h}}
\subsubsection[{catch\_\-abort}]{\setlength{\rightskip}{0pt plus 5cm}void catch\_\-abort (
\begin{DoxyParamCaption}
\item[{int}]{ sig}
\end{DoxyParamCaption}
)}}
\label{proto_8h_adf560a3f7c53865f7edbf9ff3b16c8fd}
\hypertarget{proto_8h_a690d62711b56d77e574ae4dd38fb72f0}{
\index{proto.h@{proto.h}!catch\_\-fatal@{catch\_\-fatal}}
\index{catch\_\-fatal@{catch\_\-fatal}!proto.h@{proto.h}}
\subsubsection[{catch\_\-fatal}]{\setlength{\rightskip}{0pt plus 5cm}void catch\_\-fatal (
\begin{DoxyParamCaption}
\item[{int}]{ sig}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a690d62711b56d77e574ae4dd38fb72f0}
\hypertarget{proto_8h_a1b96c5b41f1209ee91cd369f01a52352}{
\index{proto.h@{proto.h}!check\_\-omega@{check\_\-omega}}
\index{check\_\-omega@{check\_\-omega}!proto.h@{proto.h}}
\subsubsection[{check\_\-omega}]{\setlength{\rightskip}{0pt plus 5cm}void check\_\-omega (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a1b96c5b41f1209ee91cd369f01a52352}
This routine computes the mass content of the box and compares it to the specified value of Omega-\/matter. If discrepant, the run is terminated. 

Definition at line 169 of file init.c.



References All, global\_\-data\_\-all\_\-processes::BoxSize, endrun(), global\_\-data\_\-all\_\-processes::G, global\_\-data\_\-all\_\-processes::Hubble, state\_\-of\_\-system::Mass, NumPart, global\_\-data\_\-all\_\-processes::Omega0, P, and ThisTask.



Referenced by init().




\begin{DoxyCode}
{
  double mass = 0, masstot, omega;
  int i;

  for(i = 0; i < NumPart; i++)
    mass += P[i].Mass;

  MPI_Allreduce(&mass, &masstot, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);

  omega =
    masstot / (All.BoxSize * All.BoxSize * All.BoxSize) / (3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G));

  if(fabs(omega - All.Omega0) > 1.0e-3)
    {
      if(ThisTask == 0)
        {
          printf("\n\nI've found something odd!\n");
          printf
            ("The mass content accounts only for Omega=%g,\nbut you specified Ome
      ga=%g in the parameterfile.\n",
             omega, All.Omega0);
          printf("\nI better stop.\n");

          fflush(stdout);
        }
      endrun(1);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a1b96c5b41f1209ee91cd369f01a52352_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=396pt]{proto_8h_a1b96c5b41f1209ee91cd369f01a52352_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}{
\index{proto.h@{proto.h}!close\_\-outputfiles@{close\_\-outputfiles}}
\index{close\_\-outputfiles@{close\_\-outputfiles}!proto.h@{proto.h}}
\subsubsection[{close\_\-outputfiles}]{\setlength{\rightskip}{0pt plus 5cm}void close\_\-outputfiles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}
This function closes the global log-\/files. 

Definition at line 261 of file begrun.c.



References FdCPU, FdEnergy, FdForceTest, FdInfo, FdTimings, and ThisTask.



Referenced by run().




\begin{DoxyCode}
{
  if(ThisTask != 0)             /* only the root processor writes to the log file
      s */
    return;

  fclose(FdCPU);
  fclose(FdInfo);
  fclose(FdEnergy);
  fclose(FdTimings);
#ifdef FORCETEST
  fclose(FdForceTest);
#endif
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af3ffb253e14a79419d1effeee1b7261d}{
\index{proto.h@{proto.h}!compare\_\-key@{compare\_\-key}}
\index{compare\_\-key@{compare\_\-key}!proto.h@{proto.h}}
\subsubsection[{compare\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int compare\_\-key (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af3ffb253e14a79419d1effeee1b7261d}
This function is a comparison kernel for sorting the Peano-\/Hilbert keys. 

Definition at line 98 of file peano.c.



Referenced by peano\_\-hilbert\_\-order().




\begin{DoxyCode}
{
  if(((struct peano_hilbert_data *) a)->key < (((struct peano_hilbert_data *) b)-
      >key))
    return -1;

  if(((struct peano_hilbert_data *) a)->key > (((struct peano_hilbert_data *) b)-
      >key))
    return +1;

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af3ffb253e14a79419d1effeee1b7261d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a147f9422f4bca4666608da992486b417}{
\index{proto.h@{proto.h}!compute\_\-accelerations@{compute\_\-accelerations}}
\index{compute\_\-accelerations@{compute\_\-accelerations}!proto.h@{proto.h}}
\subsubsection[{compute\_\-accelerations}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-accelerations (
\begin{DoxyParamCaption}
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a147f9422f4bca4666608da992486b417}
This routine computes the accelerations for all active particles. First, the long-\/range PM force is computed if the TreePM algorithm is used and a \char`\"{}big\char`\"{} PM step is done. Next, the gravitational tree forces are computed. This also constructs the tree, if needed.

If gas particles are present, the density-\/loop for active SPH particles is carried out. This includes an iteration on the correct number of neighbours. Finally, the hydrodynamical forces are added. 

Definition at line 24 of file accel.c.



References All, global\_\-data\_\-all\_\-processes::CPU\_\-Gravity, global\_\-data\_\-all\_\-processes::CPU\_\-Hydro, global\_\-data\_\-all\_\-processes::CPU\_\-PM, global\_\-data\_\-all\_\-processes::CPU\_\-Predict, density(), force\_\-update\_\-hmax(), gravity\_\-forcetest(), gravity\_\-tree(), hydro\_\-force(), long\_\-range\_\-force(), global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, second(), ThisTask, global\_\-data\_\-all\_\-processes::Ti\_\-Current, timediff(), global\_\-data\_\-all\_\-processes::TotN\_\-gas, and global\_\-data\_\-all\_\-processes::TypeOfOpeningCriterion.



Referenced by run().




\begin{DoxyCode}
{
  double tstart, tend;

  if(ThisTask == 0)
    {
      printf("Start force computation...\n");
      fflush(stdout);
    }

#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)
    {
      tstart = second();
      long_range_force();
      tend = second();
      All.CPU_PM += timediff(tstart, tend);
    }
#endif

  tstart = second();            /* measure the time for the full force computatio
      n */

  gravity_tree();               /* computes gravity accel. */

  if(All.TypeOfOpeningCriterion == 1 && All.Ti_Current == 0)
    gravity_tree();             /* For the first timestep, we redo it
                                 * to allow usage of relative opening
                                 * criterion for consistent accuracy.
                                 */
  tend = second();
  All.CPU_Gravity += timediff(tstart, tend);

#ifdef FORCETEST
  gravity_forcetest();
#endif

  if(All.TotN_gas > 0)
    {
      if(ThisTask == 0)
        {
          printf("Start density computation...\n");
          fflush(stdout);
        }

      tstart = second();
      density();                /* computes density, and pressure */
      tend = second();
      All.CPU_Hydro += timediff(tstart, tend);

      tstart = second();
      force_update_hmax();      /* tell the tree nodes the new SPH smoothing leng
      th such that they are guaranteed to hold the correct max(Hsml) */
      tend = second();
      All.CPU_Predict += timediff(tstart, tend);


      if(ThisTask == 0)
        {
          printf("Start hydro-force computation...\n");
          fflush(stdout);
        }

      tstart = second();
      hydro_force();            /* adds hydrodynamical accelerations and computes
       viscous entropy injection  */
      tend = second();
      All.CPU_Hydro += timediff(tstart, tend);
    }

  if(ThisTask == 0)
    {
      printf("force computation done.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a147f9422f4bca4666608da992486b417_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=354pt]{proto_8h_a147f9422f4bca4666608da992486b417_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1}{
\index{proto.h@{proto.h}!compute\_\-global\_\-quantities\_\-of\_\-system@{compute\_\-global\_\-quantities\_\-of\_\-system}}
\index{compute\_\-global\_\-quantities\_\-of\_\-system@{compute\_\-global\_\-quantities\_\-of\_\-system}!proto.h@{proto.h}}
\subsubsection[{compute\_\-global\_\-quantities\_\-of\_\-system}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-global\_\-quantities\_\-of\_\-system (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1}
This routine computes various global properties of the particle distribution and stores the result in the struct `SysState'. Currently, not all the information that's computed here is actually used (e.g. momentum is not really used anywhere), just the energies are written to a log-\/file every once in a while. 

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 



Definition at line 22 of file global.c.



References All, state\_\-of\_\-system::AngMomentum, state\_\-of\_\-system::AngMomentumComp, state\_\-of\_\-system::CenterOfMass, state\_\-of\_\-system::CenterOfMassComp, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, sph\_\-particle\_\-data::DtEntropy, state\_\-of\_\-system::EnergyInt, state\_\-of\_\-system::EnergyIntComp, state\_\-of\_\-system::EnergyKin, state\_\-of\_\-system::EnergyKinComp, state\_\-of\_\-system::EnergyPot, state\_\-of\_\-system::EnergyPotComp, state\_\-of\_\-system::EnergyTot, state\_\-of\_\-system::EnergyTotComp, sph\_\-particle\_\-data::Entropy, GAMMA\_\-MINUS1, get\_\-gravkick\_\-factor(), get\_\-hydrokick\_\-factor(), particle\_\-data::GravAccel, sph\_\-particle\_\-data::HydroAccel, state\_\-of\_\-system::Mass, particle\_\-data::Mass, state\_\-of\_\-system::MassComp, state\_\-of\_\-system::Momentum, state\_\-of\_\-system::MomentumComp, NumPart, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-begstep, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, particle\_\-data::Pos, particle\_\-data::Potential, pow(), SphP, SysState, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, particle\_\-data::Type, and particle\_\-data::Vel.



Referenced by energy\_\-statistics().




\begin{DoxyCode}
{
  int i, j, n;
  struct state_of_system sys;
  double a1, a2, a3;
  double entr = 0, egyspec, vel[3];
  double dt_entr, dt_gravkick, dt_hydrokick;



  if(All.ComovingIntegrationOn)
    {
      a1 = All.Time;
      a2 = All.Time * All.Time;
      a3 = All.Time * All.Time * All.Time;
    }
  else
    {
      a1 = a2 = a3 = 1;
    }


  for(n = 0; n < 6; n++)
    {
      sys.MassComp[n] = sys.EnergyKinComp[n] = sys.EnergyPotComp[n] = sys.EnergyI
      ntComp[n] = 0;

      for(j = 0; j < 4; j++)
        sys.CenterOfMassComp[n][j] = sys.MomentumComp[n][j] = sys.AngMomentumComp
      [n][j] = 0;
    }

  for(i = 0; i < NumPart; i++)
    {
      sys.MassComp[P[i].Type] += P[i].Mass;

      sys.EnergyPotComp[P[i].Type] += 0.5 * P[i].Mass * P[i].Potential / a1;

      if(All.ComovingIntegrationOn)
        {
          dt_entr = (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * 
      All.Timebase_interval;
          dt_gravkick = get_gravkick_factor(P[i].Ti_begstep, All.Ti_Current) -
            get_gravkick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i].Ti_endst
      ep) / 2);
          dt_hydrokick = get_hydrokick_factor(P[i].Ti_begstep, All.Ti_Current) -
            get_hydrokick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i].Ti_ends
      tep) / 2);
        }
      else
        dt_entr = dt_gravkick = dt_hydrokick =
          (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * All.
      Timebase_interval;

      for(j = 0; j < 3; j++)
        {
          vel[j] = P[i].Vel[j] + P[i].GravAccel[j] * dt_gravkick;
          if(P[i].Type == 0)
            vel[j] += SphP[i].HydroAccel[j] * dt_hydrokick;
        }
      if(P[i].Type == 0)
        entr = SphP[i].Entropy + SphP[i].DtEntropy * dt_entr;

#ifdef PMGRID
      if(All.ComovingIntegrationOn)
        dt_gravkick = get_gravkick_factor(All.PM_Ti_begstep, All.Ti_Current) -
          get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
      else
        dt_gravkick = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep) /
       2) * All.Timebase_interval;

      for(j = 0; j < 3; j++)
        vel[j] += P[i].GravPM[j] * dt_gravkick;
#endif

      sys.EnergyKinComp[P[i].Type] +=
        0.5 * P[i].Mass * (vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]) /
       a2;

      if(P[i].Type == 0)
        {
#ifdef ISOTHERM_EQS
          egyspec = entr;
#else
          egyspec = entr / (GAMMA_MINUS1) * pow(SphP[i].Density / a3, 
      GAMMA_MINUS1);
#endif
          sys.EnergyIntComp[0] += P[i].Mass * egyspec;
        }



      for(j = 0; j < 3; j++)
        {
          sys.MomentumComp[P[i].Type][j] += P[i].Mass * vel[j];
          sys.CenterOfMassComp[P[i].Type][j] += P[i].Mass * P[i].Pos[j];
        }

      sys.AngMomentumComp[P[i].Type][0] += P[i].Mass * (P[i].Pos[1] * vel[2] - P[
      i].Pos[2] * vel[1]);
      sys.AngMomentumComp[P[i].Type][1] += P[i].Mass * (P[i].Pos[2] * vel[0] - P[
      i].Pos[0] * vel[2]);
      sys.AngMomentumComp[P[i].Type][2] += P[i].Mass * (P[i].Pos[0] * vel[1] - P[
      i].Pos[1] * vel[0]);
    }


  /* some the stuff over all processors */
  MPI_Reduce(&sys.MassComp[0], &SysState.MassComp[0], 6, MPI_DOUBLE, MPI_SUM, 0, 
      MPI_COMM_WORLD);
  MPI_Reduce(&sys.EnergyPotComp[0], &SysState.EnergyPotComp[0], 6, MPI_DOUBLE, MP
      I_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&sys.EnergyIntComp[0], &SysState.EnergyIntComp[0], 6, MPI_DOUBLE, MP
      I_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&sys.EnergyKinComp[0], &SysState.EnergyKinComp[0], 6, MPI_DOUBLE, MP
      I_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&sys.MomentumComp[0][0], &SysState.MomentumComp[0][0], 6 * 4, MPI_DO
      UBLE, MPI_SUM, 0,
             MPI_COMM_WORLD);
  MPI_Reduce(&sys.AngMomentumComp[0][0], &SysState.AngMomentumComp[0][0], 6 * 4, 
      MPI_DOUBLE, MPI_SUM, 0,
             MPI_COMM_WORLD);
  MPI_Reduce(&sys.CenterOfMassComp[0][0], &SysState.CenterOfMassComp[0][0], 6 * 4
      , MPI_DOUBLE, MPI_SUM, 0,
             MPI_COMM_WORLD);


  if(ThisTask == 0)
    {
      for(i = 0; i < 6; i++)
        SysState.EnergyTotComp[i] = SysState.EnergyKinComp[i] +
          SysState.EnergyPotComp[i] + SysState.EnergyIntComp[i];

      SysState.Mass = SysState.EnergyKin = SysState.EnergyPot = SysState.
      EnergyInt = SysState.EnergyTot = 0;

      for(j = 0; j < 3; j++)
        SysState.Momentum[j] = SysState.AngMomentum[j] = SysState.CenterOfMass[j]
       = 0;

      for(i = 0; i < 6; i++)
        {
          SysState.Mass += SysState.MassComp[i];
          SysState.EnergyKin += SysState.EnergyKinComp[i];
          SysState.EnergyPot += SysState.EnergyPotComp[i];
          SysState.EnergyInt += SysState.EnergyIntComp[i];
          SysState.EnergyTot += SysState.EnergyTotComp[i];

          for(j = 0; j < 3; j++)
            {
              SysState.Momentum[j] += SysState.MomentumComp[i][j];
              SysState.AngMomentum[j] += SysState.AngMomentumComp[i][j];
              SysState.CenterOfMass[j] += SysState.CenterOfMassComp[i][j];
            }
        }

      for(i = 0; i < 6; i++)
        for(j = 0; j < 3; j++)
          if(SysState.MassComp[i] > 0)
            SysState.CenterOfMassComp[i][j] /= SysState.MassComp[i];

      for(j = 0; j < 3; j++)
        if(SysState.Mass > 0)
          SysState.CenterOfMass[j] /= SysState.Mass;

      for(i = 0; i < 6; i++)
        {
          SysState.CenterOfMassComp[i][3] = SysState.MomentumComp[i][3] = 
      SysState.AngMomentumComp[i][3] = 0;
          for(j = 0; j < 3; j++)
            {
              SysState.CenterOfMassComp[i][3] +=
                SysState.CenterOfMassComp[i][j] * SysState.CenterOfMassComp[i][j]
      ;
              SysState.MomentumComp[i][3] += SysState.MomentumComp[i][j] * 
      SysState.MomentumComp[i][j];
              SysState.AngMomentumComp[i][3] +=
                SysState.AngMomentumComp[i][j] * SysState.AngMomentumComp[i][j];
            }
          SysState.CenterOfMassComp[i][3] = sqrt(SysState.CenterOfMassComp[i][3])
      ;
          SysState.MomentumComp[i][3] = sqrt(SysState.MomentumComp[i][3]);
          SysState.AngMomentumComp[i][3] = sqrt(SysState.AngMomentumComp[i][3]);
        }

      SysState.CenterOfMass[3] = SysState.Momentum[3] = SysState.AngMomentum[3] =
       0;

      for(j = 0; j < 3; j++)
        {
          SysState.CenterOfMass[3] += SysState.CenterOfMass[j] * SysState.
      CenterOfMass[j];
          SysState.Momentum[3] += SysState.Momentum[j] * SysState.Momentum[j];
          SysState.AngMomentum[3] += SysState.AngMomentum[j] * SysState.
      AngMomentum[j];
        }

      SysState.CenterOfMass[3] = sqrt(SysState.CenterOfMass[3]);
      SysState.Momentum[3] = sqrt(SysState.Momentum[3]);
      SysState.AngMomentum[3] = sqrt(SysState.AngMomentum[3]);
    }

  /* give everyone the result, maybe the want to do something with it */
  MPI_Bcast(&SysState, sizeof(struct state_of_system), MPI_BYTE, 0, MPI_COMM_WORL
      D);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a04474459731219f9601aaefedb37ab27}{
\index{proto.h@{proto.h}!compute\_\-potential@{compute\_\-potential}}
\index{compute\_\-potential@{compute\_\-potential}!proto.h@{proto.h}}
\subsubsection[{compute\_\-potential}]{\setlength{\rightskip}{0pt plus 5cm}void compute\_\-potential (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a04474459731219f9601aaefedb37ab27}
This function computes the gravitational potential for ALL the particles. First, the (short-\/range) tree potential is computed, and then, if needed, the long range PM potential is added. 

Definition at line 22 of file potential.c.



References All, global\_\-data\_\-all\_\-processes::BunchSizeForce, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-Potential, global\_\-data\_\-all\_\-processes::CPU\_\-TreeConstruction, endrun(), Exportflag, force\_\-treebuild(), force\_\-treeevaluate\_\-potential(), force\_\-treeevaluate\_\-potential\_\-shortrange(), global\_\-data\_\-all\_\-processes::G, grav\_\-tree\_\-compare\_\-key(), GravDataGet, GravDataIn, GravDataIndexTable, GravDataOut, GravDataResult, sph\_\-particle\_\-data::Hsml, global\_\-data\_\-all\_\-processes::Hubble, gravdata\_\-index::Index, particle\_\-data::Mass, NTask, NumPart, particle\_\-data::OldAcc, gravdata\_\-in::OldAcc, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, P, global\_\-data\_\-all\_\-processes::PeriodicBoundariesOn, pm\_\-init\_\-regionsize(), pm\_\-setup\_\-nonperiodic\_\-kernel(), pmpotential\_\-nonperiodic(), pmpotential\_\-periodic(), particle\_\-data::Pos, gravdata\_\-in::Pos, gravdata\_\-in::Potential, particle\_\-data::Potential, pow(), PTask, second(), set\_\-softenings(), global\_\-data\_\-all\_\-processes::SofteningTable, gravdata\_\-index::SortIndex, SphP, TAG\_\-POTENTIAL\_\-A, TAG\_\-POTENTIAL\_\-B, gravdata\_\-index::Task, ThisTask, timediff(), TreeReconstructFlag, particle\_\-data::Type, gravdata\_\-in::u, and gravdata\_\-in::w.



Referenced by find\_\-next\_\-sync\_\-point\_\-and\_\-drift(), and run().




\begin{DoxyCode}
{
  int i;

#ifndef NOGRAVITY
  long long ntot, ntotleft;
  int j, k, level, sendTask, recvTask;
  int ndone;
  int maxfill, ngrp, place, nexport;
  int *nsend, *noffset, *nsend_local, *nbuffer, *ndonelist, *numlist;
  double fac;
  double t0, t1, tstart, tend;
  MPI_Status status;
  double r2;

  t0 = second();

  if(All.ComovingIntegrationOn)
    set_softenings();

  if(ThisTask == 0)
    {
      printf("Start computation of potential for all particles...\n");
      fflush(stdout);
    }


  tstart = second();
  if(TreeReconstructFlag)
    {
      if(ThisTask == 0)
        printf("Tree construction.\n");

      force_treebuild(NumPart);

      TreeReconstructFlag = 0;

      if(ThisTask == 0)
        printf("Tree construction done.\n");
    }
  tend = second();
  All.CPU_TreeConstruction += timediff(tstart, tend);

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumPart, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);

  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common l
      ist */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  i = 0;                        /* beginn with this index */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      for(nexport = 0, ndone = 0; i < NumPart && nexport < All.BunchSizeForce - N
      Task; i++)
        {
          ndone++;

          for(j = 0; j < NTask; j++)
            Exportflag[j] = 0;

#ifndef PMGRID
          force_treeevaluate_potential(i, 0);
#else
          force_treeevaluate_potential_shortrange(i, 0);
#endif

          for(j = 0; j < NTask; j++)
            {
              if(Exportflag[j])
                {
                  for(k = 0; k < 3; k++)
                    GravDataGet[nexport].u.Pos[k] = P[i].Pos[k];
#ifdef UNEQUALSOFTENINGS
                  GravDataGet[nexport].Type = P[i].Type;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
                  if(P[i].Type == 0)
                    GravDataGet[nexport].Soft = SphP[i].Hsml;
#endif
#endif
                  GravDataGet[nexport].w.OldAcc = P[i].OldAcc;

                  GravDataIndexTable[nexport].Task = j;
                  GravDataIndexTable[nexport].Index = i;
                  GravDataIndexTable[nexport].SortIndex = nexport;

                  nexport++;
                  nsend_local[j]++;
                }
            }
        }

      qsort(GravDataIndexTable, nexport, sizeof(struct gravdata_index), 
      grav_tree_compare_key);

      for(j = 0; j < nexport; j++)
        GravDataIn[j] = GravDataGet[GravDataIndexTable[j].SortIndex];

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, MPI_COMM_
      WORLD);

      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&GravDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in), MPI_BYTE,
                                   recvTask, TAG_POTENTIAL_A,
                                   &GravDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct gravdata_in), MPI_BYTE,
                                   recvTask, TAG_POTENTIAL_A, MPI_COMM_WORLD, &st
      atus);
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          for(j = 0; j < nbuffer[ThisTask]; j++)
            {
#ifndef PMGRID
              force_treeevaluate_potential(j, 1);
#else
              force_treeevaluate_potential_shortrange(j, 1);
#endif
            }


          /* get the result */
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&GravDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct gravdata_in),
                                   MPI_BYTE, recvTask, TAG_POTENTIAL_B,
                                   &GravDataOut[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in),
                                   MPI_BYTE, recvTask, TAG_POTENTIAL_B, MPI_COMM_
      WORLD, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          place = GravDataIndexTable[noffset[recvTask] + j].
      Index;

                          P[place].Potential += GravDataOut[j + noffset[recvTask]
      ].u.Potential;
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          level = ngrp - 1;
        }

      MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD);
      for(j = 0; j < NTask; j++)
        ntotleft -= ndonelist[j];
    }

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* add correction to exclude self-potential */

  for(i = 0; i < NumPart; i++)
    {
      /* remove self-potential */
      P[i].Potential += P[i].Mass / All.SofteningTable[P[i].Type];

      if(All.ComovingIntegrationOn)
        if(All.PeriodicBoundariesOn)
          P[i].Potential -= 2.8372975 * pow(P[i].Mass, 2.0 / 3) *
            pow(All.Omega0 * 3 * All.Hubble * All.Hubble / (8 * M_PI * All.G), 1.
      0 / 3);
    }


  /* multiply with the gravitational constant */

  for(i = 0; i < NumPart; i++)
    P[i].Potential *= All.G;


#ifdef PMGRID

#ifdef PERIODIC
  pmpotential_periodic();
#ifdef PLACEHIGHRESREGION
  i = pmpotential_nonperiodic(1);
  if(i == 1)  /* this is returned if a particle lied outside allowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmpotential_nonperiodic(1);   /* try again */
    }
  if(i == 1)
    endrun(88686);
#endif
#else
  i = pmpotential_nonperiodic(0);
  if(i == 1)                    /* this is returned if a particle lied outside al
      lowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmpotential_nonperiodic(0);   /* try again */
    }
  if(i == 1)
    endrun(88687);
#ifdef PLACEHIGHRESREGION
  i = pmpotential_nonperiodic(1);
  if(i == 1)                    /* this is returned if a particle lied outside al
      lowed range */
    {
      pm_init_regionsize();

      i = pmpotential_nonperiodic(1);
    }
  if(i != 0)
    endrun(88688);
#endif
#endif

#endif



  if(All.ComovingIntegrationOn)
    {
#ifndef PERIODIC
      fac = -0.5 * All.Omega0 * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        {
          for(k = 0, r2 = 0; k < 3; k++)
            r2 += P[i].Pos[k] * P[i].Pos[k];

          P[i].Potential += fac * r2;
        }
#endif
    }
  else
    {
      fac = -0.5 * All.OmegaLambda * All.Hubble * All.Hubble;
      if(fac != 0)
        {
          for(i = 0; i < NumPart; i++)
            {
              for(k = 0, r2 = 0; k < 3; k++)
                r2 += P[i].Pos[k] * P[i].Pos[k];

              P[i].Potential += fac * r2;
            }
        }
    }


  if(ThisTask == 0)
    {
      printf("potential done.\n");
      fflush(stdout);
    }

  t1 = second();

  All.CPU_Potential += timediff(t0, t1);

#else
  for(i = 0; i < NumPart; i++)
    P[i].Potential = 0;
#endif
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a04474459731219f9601aaefedb37ab27_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a04474459731219f9601aaefedb37ab27_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1}{
\index{proto.h@{proto.h}!dens\_\-compare\_\-key@{dens\_\-compare\_\-key}}
\index{dens\_\-compare\_\-key@{dens\_\-compare\_\-key}!proto.h@{proto.h}}
\subsubsection[{dens\_\-compare\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int dens\_\-compare\_\-key (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1}
This routine is a comparison kernel used in a sort routine to group particles that are exported to the same processor. 

Definition at line 607 of file density.c.



Referenced by density().




\begin{DoxyCode}
{
  if(((struct densdata_in *) a)->Task < (((struct densdata_in *) b)->Task))
    return -1;

  if(((struct densdata_in *) a)->Task > (((struct densdata_in *) b)->Task))
    return +1;

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c}{
\index{proto.h@{proto.h}!density@{density}}
\index{density@{density}!proto.h@{proto.h}}
\subsubsection[{density}]{\setlength{\rightskip}{0pt plus 5cm}void density (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c}
This function computes the local density for each active SPH particle, the number of neighbours in the current smoothing radius, and the divergence and curl of the velocity field. The pressure is updated as well. If a particle with its smoothing region is fully inside the local domain, it is not exported to the other processors. The function also detects particles that have a number of neighbours outside the allowed tolerance range. For these particles, the smoothing length is adjusted accordingly, and the density computation is executed again. Note that the smoothing length is not allowed to fall below the lower bound set by MinGasHsml. 

$<$ For 3D-\/normalized kernel

$<$ adiabatic index of simulated gas

$<$ maxmimum number of steps for SPH neighbour iteration

$<$ For 3D-\/normalized kernel

$<$ For 3D-\/normalized kernel

$<$ maxmimum number of steps for SPH neighbour iteration 



Definition at line 56 of file density.c.



References All, boxHalf, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, global\_\-data\_\-all\_\-processes::BoxSize, boxSize, boxSize\_\-X, boxSize\_\-Y, boxSize\_\-Z, global\_\-data\_\-all\_\-processes::BunchSizeDensity, global\_\-data\_\-all\_\-processes::CPU\_\-EnsureNgb, global\_\-data\_\-all\_\-processes::CPU\_\-HydCommSumm, global\_\-data\_\-all\_\-processes::CPU\_\-HydCompWalk, global\_\-data\_\-all\_\-processes::CPU\_\-HydImbalance, sph\_\-particle\_\-data::CurlVel, dens\_\-compare\_\-key(), DensDataGet, DensDataIn, DensDataPartialResult, DensDataResult, sph\_\-particle\_\-data::Density, density\_\-evaluate(), global\_\-data\_\-all\_\-processes::DesNumNgb, densdata\_\-out::DhsmlDensity, sph\_\-particle\_\-data::DhsmlDensityFactor, densdata\_\-out::Div, sph\_\-particle\_\-data::DivVel, dmax(), sph\_\-particle\_\-data::DtEntropy, endrun(), sph\_\-particle\_\-data::Entropy, Exportflag, GAMMA, sph\_\-particle\_\-data::Hsml, densdata\_\-in::Hsml, densdata\_\-in::Index, sph\_\-particle\_\-data::Left, MAXITER, global\_\-data\_\-all\_\-processes::MaxNumNgbDeviation, global\_\-data\_\-all\_\-processes::MinGasHsml, N\_\-gas, densdata\_\-out::Ngb, NTask, NUMDIMS, sph\_\-particle\_\-data::NumNgb, NumPart, NumSphUpdate, P, particle\_\-data::Pos, densdata\_\-in::Pos, pow(), sph\_\-particle\_\-data::Pressure, PTask, densdata\_\-out::Rho, sph\_\-particle\_\-data::Right, densdata\_\-out::Rot, sph\_\-particle\_\-data::Rot, second(), SphP, TAG\_\-DENS\_\-A, TAG\_\-DENS\_\-B, densdata\_\-in::Task, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, timediff(), densdata\_\-in::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by compute\_\-accelerations(), and setup\_\-smoothinglengths().




\begin{DoxyCode}
{
  long long ntot, ntotleft;
  int *noffset, *nbuffer, *nsend, *nsend_local, *numlist, *ndonelist;
  int i, j, n, ndone, npleft, maxfill, source, iter = 0;
  int level, ngrp, sendTask, recvTask, place, nexport;
  double dt_entr, tstart, tend, tstart_ngb = 0, tend_ngb = 0;
  double sumt, sumcomm, timengb, sumtimengb;
  double timecomp = 0, timeimbalance = 0, timecommsumm = 0, sumimbalance;
  MPI_Status status;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif


  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common l
      ist */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  for(n = 0, NumSphUpdate = 0; n < N_gas; n++)
    {
      SphP[n].Left = SphP[n].Right = 0;

      if(P[n].Ti_endstep == All.Ti_Current)
        NumSphUpdate++;
    }

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumSphUpdate, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);



  /* we will repeat the whole thing for those particles where we didn't
   * find enough neighbours
   */
  do
    {
      i = 0;                    /* beginn with this index */
      ntotleft = ntot;          /* particles left for all tasks together */

      while(ntotleft > 0)
        {
          for(j = 0; j < NTask; j++)
            nsend_local[j] = 0;

          /* do local particles and prepare export list */
          tstart = second();
          for(nexport = 0, ndone = 0; i < N_gas && nexport < All.
      BunchSizeDensity - NTask; i++)
            if(P[i].Ti_endstep == All.Ti_Current)
              {
                ndone++;

                for(j = 0; j < NTask; j++)
                  Exportflag[j] = 0;

                density_evaluate(i, 0);

                for(j = 0; j < NTask; j++)
                  {
                    if(Exportflag[j])
                      {
                        DensDataIn[nexport].Pos[0] = P[i].Pos[0];
                        DensDataIn[nexport].Pos[1] = P[i].Pos[1];
                        DensDataIn[nexport].Pos[2] = P[i].Pos[2];
                        DensDataIn[nexport].Vel[0] = SphP[i].VelPred[0];
                        DensDataIn[nexport].Vel[1] = SphP[i].VelPred[1];
                        DensDataIn[nexport].Vel[2] = SphP[i].VelPred[2];
                        DensDataIn[nexport].Hsml = SphP[i].Hsml;
                        DensDataIn[nexport].Index = i;
                        DensDataIn[nexport].Task = j;
                        nexport++;
                        nsend_local[j]++;
                      }
                  }
              }
          tend = second();
          timecomp += timediff(tstart, tend);

          qsort(DensDataIn, nexport, sizeof(struct densdata_in), 
      dens_compare_key);

          for(j = 1, noffset[0] = 0; j < NTask; j++)
            noffset[j] = noffset[j - 1] + nsend_local[j - 1];

          tstart = second();

          MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, MPI_C
      OMM_WORLD);

          tend = second();
          timeimbalance += timediff(tstart, tend);


          /* now do the particles that need to be exported */

          for(level = 1; level < (1 << PTask); level++)
            {
              tstart = second();
              for(j = 0; j < NTask; j++)
                nbuffer[j] = 0;
              for(ngrp = level; ngrp < (1 << PTask); ngrp++)
                {
                  maxfill = 0;
                  for(j = 0; j < NTask; j++)
                    {
                      if((j ^ ngrp) < NTask)
                        if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                          maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                    }
                  if(maxfill >= All.BunchSizeDensity)
                    break;

                  sendTask = ThisTask;
                  recvTask = ThisTask ^ ngrp;

                  if(recvTask < NTask)
                    {
                      if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask
       * NTask + ThisTask] > 0)
                        {
                          /* get the particles */
                          MPI_Sendrecv(&DensDataIn[noffset[recvTask]],
                                       nsend_local[recvTask] * sizeof(struct 
      densdata_in), MPI_BYTE,
                                       recvTask, TAG_DENS_A,
                                       &DensDataGet[nbuffer[ThisTask]],
                                       nsend[recvTask * NTask + ThisTask] * sizeo
      f(struct densdata_in),
                                       MPI_BYTE, recvTask, TAG_DENS_A, MPI_COMM_W
      ORLD, &status);
                        }
                    }

                  for(j = 0; j < NTask; j++)
                    if((j ^ ngrp) < NTask)
                      nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
                }
              tend = second();
              timecommsumm += timediff(tstart, tend);


              tstart = second();
              for(j = 0; j < nbuffer[ThisTask]; j++)
                density_evaluate(j, 1);
              tend = second();
              timecomp += timediff(tstart, tend);

              /* do a block to explicitly measure imbalance */
              tstart = second();
              MPI_Barrier(MPI_COMM_WORLD);
              tend = second();
              timeimbalance += timediff(tstart, tend);

              /* get the result */
              tstart = second();
              for(j = 0; j < NTask; j++)
                nbuffer[j] = 0;
              for(ngrp = level; ngrp < (1 << PTask); ngrp++)
                {
                  maxfill = 0;
                  for(j = 0; j < NTask; j++)
                    {
                      if((j ^ ngrp) < NTask)
                        if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                          maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                    }
                  if(maxfill >= All.BunchSizeDensity)
                    break;

                  sendTask = ThisTask;
                  recvTask = ThisTask ^ ngrp;

                  if(recvTask < NTask)
                    {
                      if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask
       * NTask + ThisTask] > 0)
                        {
                          /* send the results */
                          MPI_Sendrecv(&DensDataResult[nbuffer[ThisTask]],
                                       nsend[recvTask * NTask + ThisTask] * sizeo
      f(struct densdata_out),
                                       MPI_BYTE, recvTask, TAG_DENS_B,
                                       &DensDataPartialResult[noffset[recvTask]],
      
                                       nsend_local[recvTask] * sizeof(struct 
      densdata_out),
                                       MPI_BYTE, recvTask, TAG_DENS_B, MPI_COMM_W
      ORLD, &status);

                          /* add the result to the particles */
                          for(j = 0; j < nsend_local[recvTask]; j++)
                            {
                              source = j + noffset[recvTask];
                              place = DensDataIn[source].Index;

                              SphP[place].NumNgb += DensDataPartialResult[source]
      .Ngb;
                              SphP[place].Density += DensDataPartialResult[source
      ].Rho;
                              SphP[place].DivVel += DensDataPartialResult[source]
      .Div;

                              SphP[place].DhsmlDensityFactor += 
      DensDataPartialResult[source].DhsmlDensity;

                              SphP[place].Rot[0] += DensDataPartialResult[source]
      .Rot[0];
                              SphP[place].Rot[1] += DensDataPartialResult[source]
      .Rot[1];
                              SphP[place].Rot[2] += DensDataPartialResult[source]
      .Rot[2];
                            }
                        }
                    }

                  for(j = 0; j < NTask; j++)
                    if((j ^ ngrp) < NTask)
                      nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
                }
              tend = second();
              timecommsumm += timediff(tstart, tend);

              level = ngrp - 1;
            }

          MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD
      );
          for(j = 0; j < NTask; j++)
            ntotleft -= ndonelist[j];
        }



      /* do final operations on results */
      tstart = second();
      for(i = 0, npleft = 0; i < N_gas; i++)
        {
          if(P[i].Ti_endstep == All.Ti_Current)
            {
              {
                SphP[i].DhsmlDensityFactor =
                  1 / (1 + SphP[i].Hsml * SphP[i].DhsmlDensityFactor / (NUMDIMS *
       SphP[i].Density));

                SphP[i].CurlVel = sqrt(SphP[i].Rot[0] * SphP[i].Rot[0] +
                                       SphP[i].Rot[1] * SphP[i].Rot[1] +
                                       SphP[i].Rot[2] * SphP[i].Rot[2]) / SphP[i]
      .Density;

                SphP[i].DivVel /= SphP[i].Density;

                dt_entr = (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) /
       2) * All.Timebase_interval;

                SphP[i].Pressure =
                  (SphP[i].Entropy + SphP[i].DtEntropy * dt_entr) * pow(SphP[i].D
      ensity, GAMMA);
              }


              /* now check whether we had enough neighbours */

              if(SphP[i].NumNgb < (All.DesNumNgb - All.MaxNumNgbDeviation) ||
                 (SphP[i].NumNgb > (All.DesNumNgb + All.MaxNumNgbDeviation)
                  && SphP[i].Hsml > (1.01 * All.MinGasHsml)))
                {
                  /* need to redo this particle */
                  npleft++;

                  if(SphP[i].Left > 0 && SphP[i].Right > 0)
                    if((SphP[i].Right - SphP[i].Left) < 1.0e-3 * SphP[i].Left)
                      {
                        /* this one should be ok */
                        npleft--;
                        P[i].Ti_endstep = -P[i].Ti_endstep - 1; /* Mark as inacti
      ve */
                        continue;
                      }

                  if(SphP[i].NumNgb < (All.DesNumNgb - All.MaxNumNgbDeviation))
                    SphP[i].Left = dmax(SphP[i].Hsml, SphP[i].Left);
                  else
                    {
                      if(SphP[i].Right != 0)
                        {
                          if(SphP[i].Hsml < SphP[i].Right)
                            SphP[i].Right = SphP[i].Hsml;
                        }
                      else
                        SphP[i].Right = SphP[i].Hsml;
                    }

                  if(iter >= MAXITER - 10)
                    {
                      printf
                        ("i=%d task=%d ID=%d Hsml=%g Left=%g Right=%g Ngbs=%g Rig
      ht-Left=%g\n   pos=(%g|%g|%g)\n",
                         i, ThisTask, (int) P[i].ID, SphP[i].Hsml, SphP[i].Left, 
      SphP[i].Right,
                         (float) SphP[i].NumNgb, SphP[i].Right - SphP[i].Left, P[
      i].Pos[0], P[i].Pos[1],
                         P[i].Pos[2]);
                      fflush(stdout);
                    }

                  if(SphP[i].Right > 0 && SphP[i].Left > 0)
                    SphP[i].Hsml = pow(0.5 * (pow(SphP[i].Left, 3) + pow(SphP[i].
      Right, 3)), 1.0 / 3);
                  else
                    {
                      if(SphP[i].Right == 0 && SphP[i].Left == 0)
                        endrun(8188);   /* can't occur */

                      if(SphP[i].Right == 0 && SphP[i].Left > 0)
                        {
                          if(P[i].Type == 0 && fabs(SphP[i].NumNgb - All.
      DesNumNgb) < 0.5 * All.DesNumNgb)
                            {
                              SphP[i].Hsml *=
                                1 - (SphP[i].NumNgb -
                                     All.DesNumNgb) / (NUMDIMS * SphP[i].NumNgb) 
      * SphP[i].DhsmlDensityFactor;
                            }
                          else
                            SphP[i].Hsml *= 1.26;
                        }

                      if(SphP[i].Right > 0 && SphP[i].Left == 0)
                        {
                          if(P[i].Type == 0 && fabs(SphP[i].NumNgb - All.
      DesNumNgb) < 0.5 * All.DesNumNgb)
                            {
                              SphP[i].Hsml *=
                                1 - (SphP[i].NumNgb -
                                     All.DesNumNgb) / (NUMDIMS * SphP[i].NumNgb) 
      * SphP[i].DhsmlDensityFactor;
                            }
                          else
                            SphP[i].Hsml /= 1.26;
                        }
                    }

                  if(SphP[i].Hsml < All.MinGasHsml)
                    SphP[i].Hsml = All.MinGasHsml;
                }
              else
                P[i].Ti_endstep = -P[i].Ti_endstep - 1; /* Mark as inactive */
            }
        }
      tend = second();
      timecomp += timediff(tstart, tend);


      numlist = malloc(NTask * sizeof(int) * NTask);
      MPI_Allgather(&npleft, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
      for(i = 0, ntot = 0; i < NTask; i++)
        ntot += numlist[i];
      free(numlist);

      if(ntot > 0)
        {
          if(iter == 0)
            tstart_ngb = second();

          iter++;

          if(iter > 0 && ThisTask == 0)
            {
              printf("ngb iteration %d: need to repeat for %d%09d particles.\n", 
      iter,
                     (int) (ntot / 1000000000), (int) (ntot % 1000000000));
              fflush(stdout);
            }

          if(iter > MAXITER)
            {
              printf("failed to converge in neighbour iteration in density()\n");
      
              fflush(stdout);
              endrun(1155);
            }
        }
      else
        tend_ngb = second();
    }
  while(ntot > 0);


  /* mark as active again */
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* collect some timing information */
  if(iter > 0)
    timengb = timediff(tstart_ngb, tend_ngb);
  else
    timengb = 0;

  MPI_Reduce(&timengb, &sumtimengb, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecomp, &sumt, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecommsumm, &sumcomm, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
      
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_W
      ORLD);

  if(ThisTask == 0)
    {
      All.CPU_HydCompWalk += sumt / NTask;
      All.CPU_HydCommSumm += sumcomm / NTask;
      All.CPU_HydImbalance += sumimbalance / NTask;
      All.CPU_EnsureNgb += sumtimengb / NTask;
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aaeec847fb319935d1a6e765ffbb9c6d9}{
\index{proto.h@{proto.h}!density\_\-decouple@{density\_\-decouple}}
\index{density\_\-decouple@{density\_\-decouple}!proto.h@{proto.h}}
\subsubsection[{density\_\-decouple}]{\setlength{\rightskip}{0pt plus 5cm}void density\_\-decouple (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aaeec847fb319935d1a6e765ffbb9c6d9}
\hypertarget{proto_8h_a19f7a07621c698ae894f53836e9ff03c}{
\index{proto.h@{proto.h}!density\_\-evaluate@{density\_\-evaluate}}
\index{density\_\-evaluate@{density\_\-evaluate}!proto.h@{proto.h}}
\subsubsection[{density\_\-evaluate}]{\setlength{\rightskip}{0pt plus 5cm}void density\_\-evaluate (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a19f7a07621c698ae894f53836e9ff03c}
This function represents the core of the SPH density computation. The target particle may either be local, or reside in the communication buffer. 

$<$ Coefficients for SPH spline kernel and its derivative

$<$ Coefficient for kernel normalization. Note: 4.0/3 $\ast$ PI = 4.188790204786

$<$ For 3D-\/normalized kernel 



Definition at line 467 of file density.c.



References All, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, DensDataGet, DensDataResult, sph\_\-particle\_\-data::Density, densdata\_\-out::DhsmlDensity, sph\_\-particle\_\-data::DhsmlDensityFactor, densdata\_\-out::Div, sph\_\-particle\_\-data::DivVel, FLOAT, densdata\_\-in::Hsml, sph\_\-particle\_\-data::Hsml, KERNEL\_\-COEFF\_\-1, KERNEL\_\-COEFF\_\-2, KERNEL\_\-COEFF\_\-3, KERNEL\_\-COEFF\_\-5, KERNEL\_\-COEFF\_\-6, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MaxPart, densdata\_\-out::Ngb, ngb\_\-treefind\_\-variable(), Ngblist, NORM\_\-COEFF, NUMDIMS, sph\_\-particle\_\-data::NumNgb, P, densdata\_\-in::Pos, particle\_\-data::Pos, densdata\_\-out::Rho, densdata\_\-out::Rot, sph\_\-particle\_\-data::Rot, SphP, densdata\_\-in::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by density().




\begin{DoxyCode}
{
  int j, n, startnode, numngb, numngb_inbox;
  double h, h2, fac, hinv, hinv3, hinv4;
  double rho, divv, wk, dwk;
  double dx, dy, dz, r, r2, u, mass_j;
  double dvx, dvy, dvz, rotv[3];
  double weighted_numngb, dhsmlrho;
  FLOAT *pos, *vel;

  if(mode == 0)
    {
      pos = P[target].Pos;
      vel = SphP[target].VelPred;
      h = SphP[target].Hsml;
    }
  else
    {
      pos = DensDataGet[target].Pos;
      vel = DensDataGet[target].Vel;
      h = DensDataGet[target].Hsml;
    }

  h2 = h * h;
  hinv = 1.0 / h;
#ifndef  TWODIMS
  hinv3 = hinv * hinv * hinv;
#else
  hinv3 = hinv * hinv / boxSize_Z;
#endif
  hinv4 = hinv3 * hinv;

  rho = divv = rotv[0] = rotv[1] = rotv[2] = 0;
  weighted_numngb = 0;
  dhsmlrho = 0;

  startnode = All.MaxPart;
  numngb = 0;
  do
    {
      numngb_inbox = ngb_treefind_variable(&pos[0], h, &startnode);

      for(n = 0; n < numngb_inbox; n++)
        {
          j = Ngblist[n];

          dx = pos[0] - P[j].Pos[0];
          dy = pos[1] - P[j].Pos[1];
          dz = pos[2] - P[j].Pos[2];

#ifdef PERIODIC                 /*  now find the closest image in the given box s
      ize  */
          if(dx > boxHalf_X)
            dx -= boxSize_X;
          if(dx < -boxHalf_X)
            dx += boxSize_X;
          if(dy > boxHalf_Y)
            dy -= boxSize_Y;
          if(dy < -boxHalf_Y)
            dy += boxSize_Y;
          if(dz > boxHalf_Z)
            dz -= boxSize_Z;
          if(dz < -boxHalf_Z)
            dz += boxSize_Z;
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          if(r2 < h2)
            {
              numngb++;

              r = sqrt(r2);

              u = r * hinv;

              if(u < 0.5)
                {
                  wk = hinv3 * (KERNEL_COEFF_1 + KERNEL_COEFF_2 * (u - 1) * u * u
      );
                  dwk = hinv4 * u * (KERNEL_COEFF_3 * u - KERNEL_COEFF_4);
                }
              else
                {
                  wk = hinv3 * KERNEL_COEFF_5 * (1.0 - u) * (1.0 - u) * (1.0 - u)
      ;
                  dwk = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                }

              mass_j = P[j].Mass;

              rho += mass_j * wk;

              weighted_numngb += NORM_COEFF * wk / hinv3;

              dhsmlrho += -mass_j * (NUMDIMS * hinv * wk + u * dwk);

              if(r > 0)
                {
                  fac = mass_j * dwk / r;

                  dvx = vel[0] - SphP[j].VelPred[0];
                  dvy = vel[1] - SphP[j].VelPred[1];
                  dvz = vel[2] - SphP[j].VelPred[2];

                  divv -= fac * (dx * dvx + dy * dvy + dz * dvz);

                  rotv[0] += fac * (dz * dvy - dy * dvz);
                  rotv[1] += fac * (dx * dvz - dz * dvx);
                  rotv[2] += fac * (dy * dvx - dx * dvy);
                }
            }
        }
    }
  while(startnode >= 0);

  if(mode == 0)
    {
      SphP[target].NumNgb = weighted_numngb;
      SphP[target].Density = rho;
      SphP[target].DivVel = divv;
      SphP[target].DhsmlDensityFactor = dhsmlrho;
      SphP[target].Rot[0] = rotv[0];
      SphP[target].Rot[1] = rotv[1];
      SphP[target].Rot[2] = rotv[2];
    }
  else
    {
      DensDataResult[target].Rho = rho;
      DensDataResult[target].Div = divv;
      DensDataResult[target].Ngb = weighted_numngb;
      DensDataResult[target].DhsmlDensity = dhsmlrho;
      DensDataResult[target].Rot[0] = rotv[0];
      DensDataResult[target].Rot[1] = rotv[1];
      DensDataResult[target].Rot[2] = rotv[2];
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a19f7a07621c698ae894f53836e9ff03c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a19f7a07621c698ae894f53836e9ff03c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab}{
\index{proto.h@{proto.h}!distribute\_\-file@{distribute\_\-file}}
\index{distribute\_\-file@{distribute\_\-file}!proto.h@{proto.h}}
\subsubsection[{distribute\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void distribute\_\-file (
\begin{DoxyParamCaption}
\item[{int}]{ nfiles, }
\item[{int}]{ firstfile, }
\item[{int}]{ firsttask, }
\item[{int}]{ lasttask, }
\item[{int $\ast$}]{ filenr, }
\item[{int $\ast$}]{ master, }
\item[{int $\ast$}]{ last}
\end{DoxyParamCaption}
)}}
\label{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab}
This function assigns a certain number of files to processors, such that each processor is exactly assigned to one file, and the number of cpus per file is as homogenous as possible. The number of files may at most be equal to the number of processors. 

Definition at line 724 of file read\_\-ic.c.



References distribute\_\-file(), and ThisTask.



Referenced by distribute\_\-file(), read\_\-ic(), and savepositions().




\begin{DoxyCode}
{
  int ntask, filesleft, filesright, tasksleft, tasksright;

  if(nfiles > 1)
    {
      ntask = lasttask - firsttask + 1;

      filesleft = (((double) (ntask / 2)) / ntask) * nfiles;
      if(filesleft <= 0)
        filesleft = 1;
      if(filesleft >= nfiles)
        filesleft = nfiles - 1;

      filesright = nfiles - filesleft;

      tasksleft = ntask / 2;
      tasksright = ntask - tasksleft;

      distribute_file(filesleft, firstfile, firsttask, firsttask + tasksleft - 1,
       filenr, master, last);
      distribute_file(filesright, firstfile + filesleft, firsttask + tasksleft, l
      asttask, filenr, master,
                      last);
    }
  else
    {
      if(ThisTask >= firsttask && ThisTask <= lasttask)
        {
          *filenr = firstfile;
          *master = firsttask;
          *last = lasttask;
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=160pt]{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac5e72d197cde6d71017e89db9b986b85}{
\index{proto.h@{proto.h}!dmax@{dmax}}
\index{dmax@{dmax}!proto.h@{proto.h}}
\subsubsection[{dmax}]{\setlength{\rightskip}{0pt plus 5cm}double dmax (
\begin{DoxyParamCaption}
\item[{double}]{ x, }
\item[{double}]{ y}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ac5e72d197cde6d71017e89db9b986b85}
returns the maximum of two double 

Definition at line 91 of file system.c.



Referenced by density(), domain\_\-findSplit(), domain\_\-shiftSplit(), fill\_\-write\_\-buffer(), force\_\-treeevaluate\_\-direct(), and read\_\-ic().




\begin{DoxyCode}
{
  if(x > y)
    return x;
  else
    return y;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac5e72d197cde6d71017e89db9b986b85_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a128779c23a7c6e9cca2374c5e7c91483}{
\index{proto.h@{proto.h}!dmin@{dmin}}
\index{dmin@{dmin}!proto.h@{proto.h}}
\subsubsection[{dmin}]{\setlength{\rightskip}{0pt plus 5cm}double dmin (
\begin{DoxyParamCaption}
\item[{double}]{ x, }
\item[{double}]{ y}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a128779c23a7c6e9cca2374c5e7c91483}
returns the minimum of two double 

Definition at line 101 of file system.c.



Referenced by hydro\_\-evaluate().




\begin{DoxyCode}
{
  if(x < y)
    return x;
  else
    return y;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a128779c23a7c6e9cca2374c5e7c91483_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_adda9e167a16a53d1aa40180406950446}{
\index{proto.h@{proto.h}!do\_\-box\_\-wrapping@{do\_\-box\_\-wrapping}}
\index{do\_\-box\_\-wrapping@{do\_\-box\_\-wrapping}!proto.h@{proto.h}}
\subsubsection[{do\_\-box\_\-wrapping}]{\setlength{\rightskip}{0pt plus 5cm}void do\_\-box\_\-wrapping (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_adda9e167a16a53d1aa40180406950446}
This function makes sure that all particle coordinates (Pos) are periodically mapped onto the interval \mbox{[}0, BoxSize\mbox{]}. After this function has been called, a new domain decomposition should be done, which will also force a new tree construction. 

Definition at line 103 of file predict.c.



References All, global\_\-data\_\-all\_\-processes::BoxSize, NumPart, P, and particle\_\-data::Pos.



Referenced by domain\_\-Decomposition().




\begin{DoxyCode}
{
  int i, j;
  double boxsize[3];

  for(j = 0; j < 3; j++)
    boxsize[j] = All.BoxSize;

#ifdef LONG_X
  boxsize[0] *= LONG_X;
#endif
#ifdef LONG_Y
  boxsize[1] *= LONG_Y;
#endif
#ifdef LONG_Z
  boxsize[2] *= LONG_Z;
#endif

  for(i = 0; i < NumPart; i++)
    for(j = 0; j < 3; j++)
      {
        while(P[i].Pos[j] < 0)
          P[i].Pos[j] += boxsize[j];

        while(P[i].Pos[j] >= boxsize[j])
          P[i].Pos[j] -= boxsize[j];
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_adda9e167a16a53d1aa40180406950446_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5b596de46669fab5e125f163d44edc37}{
\index{proto.h@{proto.h}!domain\_\-compare\_\-key@{domain\_\-compare\_\-key}}
\index{domain\_\-compare\_\-key@{domain\_\-compare\_\-key}!proto.h@{proto.h}}
\subsubsection[{domain\_\-compare\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int domain\_\-compare\_\-key (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a5b596de46669fab5e125f163d44edc37}
This is a comparison kernel used in a sort routine. 

Definition at line 1119 of file domain.c.



Referenced by domain\_\-determineTopTree().




\begin{DoxyCode}
{
  if(*(peanokey *) a < *(peanokey *) b)
    return -1;

  if(*(peanokey *) a > *(peanokey *) b)
    return +1;

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a5b596de46669fab5e125f163d44edc37_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a381621bc90438c5a50826bfdac8e4700}{
\index{proto.h@{proto.h}!domain\_\-compare\_\-toplist@{domain\_\-compare\_\-toplist}}
\index{domain\_\-compare\_\-toplist@{domain\_\-compare\_\-toplist}!proto.h@{proto.h}}
\subsubsection[{domain\_\-compare\_\-toplist}]{\setlength{\rightskip}{0pt plus 5cm}int domain\_\-compare\_\-toplist (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a381621bc90438c5a50826bfdac8e4700}
This is a comparison kernel used in a sort routine. 

Definition at line 1106 of file domain.c.



References topnode\_\-exchange::Startkey.



Referenced by domain\_\-determineTopTree().




\begin{DoxyCode}
{
  if(((struct topnode_exchange *) a)->Startkey < (((struct topnode_exchange *) b)
      ->Startkey))
    return -1;

  if(((struct topnode_exchange *) a)->Startkey > (((struct topnode_exchange *) b)
      ->Startkey))
    return +1;

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a381621bc90438c5a50826bfdac8e4700_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a77c115c3aa2069d0eb8521329be0483c}{
\index{proto.h@{proto.h}!domain\_\-countToGo@{domain\_\-countToGo}}
\index{domain\_\-countToGo@{domain\_\-countToGo}!proto.h@{proto.h}}
\subsubsection[{domain\_\-countToGo}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-countToGo (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a77c115c3aa2069d0eb8521329be0483c}
This function determines how many particles that are currently stored on the local CPU have to be moved off according to the domain decomposition. 

Definition at line 729 of file domain.c.



References topnode\_\-data::Daughter, DomainTask, Key, topnode\_\-data::Leaf, local\_\-toGo, local\_\-toGoSph, NTask, NumPart, P, topnode\_\-data::StartKey, ThisTask, toGo, toGoSph, and TopNodes.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int n, no;

  for(n = 0; n < NTask; n++)
    {
      local_toGo[n] = 0;
      local_toGoSph[n] = 0;
    }

  for(n = 0; n < NumPart; n++)
    {
      no = 0;

      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (Key[n] - TopNodes[no].StartKey) / (
      TopNodes[no].Size / 8);

      no = TopNodes[no].Leaf;

      if(DomainTask[no] != ThisTask)
        {
          local_toGo[DomainTask[no]] += 1;
          if(P[n].Type == 0)
            local_toGoSph[DomainTask[no]] += 1;
        }
    }

  MPI_Allgather(local_toGo, NTask, MPI_INT, toGo, NTask, MPI_INT, MPI_COMM_WORLD)
      ;
  MPI_Allgather(local_toGoSph, NTask, MPI_INT, toGoSph, NTask, MPI_INT, MPI_COMM_
      WORLD);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a77c115c3aa2069d0eb8521329be0483c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a647e0c1a76b7f064ed5d201662f364bf}{
\index{proto.h@{proto.h}!domain\_\-decompose@{domain\_\-decompose}}
\index{domain\_\-decompose@{domain\_\-decompose}!proto.h@{proto.h}}
\subsubsection[{domain\_\-decompose}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-decompose (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a647e0c1a76b7f064ed5d201662f364bf}
This function carries out the actual domain decomposition for all particle types. It will try to balance the work-\/load for each domain, as estimated based on the P\mbox{[}i\mbox{]}-\/GravCost values. The decomposition will respect the maximum allowed memory-\/imbalance given by the value of PartAllocFactor. 

Definition at line 154 of file domain.c.



References All, domain\_\-countToGo(), domain\_\-determineTopTree(), domain\_\-exchangeParticles(), domain\_\-findExchangeNumbers(), domain\_\-findExtent(), domain\_\-findSplit(), domain\_\-shiftSplit(), domain\_\-sumCost(), DomainEndList, DomainMyLast, DomainMyStart, DomainStartList, endrun(), list\_\-load, list\_\-N\_\-gas, list\_\-NumPart, list\_\-work, maxload, NTask, NTopleaves, Ntype, NtypeLocal, NumPart, P, PTask, global\_\-data\_\-all\_\-processes::SofteningTable, ThisTask, toGo, toGoSph, and global\_\-data\_\-all\_\-processes::TotN\_\-gas.



Referenced by domain\_\-Decomposition().




\begin{DoxyCode}
{
  int i, j, status;
  int ngrp, task, partner, sendcount, recvcount;
  long long sumtogo, sumload;
  int maxload, *temp;
  double sumwork, maxwork;

  for(i = 0; i < 6; i++)
    NtypeLocal[i] = 0;

  for(i = 0; i < NumPart; i++)
    NtypeLocal[P[i].Type]++;

  /* because Ntype[] is of type `long long', we cannot do a simple
   * MPI_Allreduce() to sum the total particle numbers 
   */
  temp = malloc(NTask * 6 * sizeof(int));
  MPI_Allgather(NtypeLocal, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
  for(i = 0; i < 6; i++)
    {
      Ntype[i] = 0;
      for(j = 0; j < NTask; j++)
        Ntype[i] += temp[j * 6 + i];
    }
  free(temp);

#ifndef UNEQUALSOFTENINGS
  for(i = 0; i < 6; i++)
    if(Ntype[i] > 0)
      break;

  for(ngrp = i + 1; ngrp < 6; ngrp++)
    {
      if(Ntype[ngrp] > 0)
        if(All.SofteningTable[ngrp] != All.SofteningTable[i])
          {
            if(ThisTask == 0)
              {
                fprintf(stdout, "Code was not compiled with UNEQUALSOFTENINGS, bu
      t some of the\n");
                fprintf(stdout, "softening lengths are unequal nevertheless.\n");
      
                fprintf(stdout, "This is not allowed.\n");
              }
            endrun(0);
          }
    }
#endif


  /* determine global dimensions of domain grid */
  domain_findExtent();

  domain_determineTopTree();

  /* determine cost distribution in domain grid */
  domain_sumCost();

  /* find the split of the domain grid recursively */
  status = domain_findSplit(0, NTask, 0, NTopleaves - 1);
  if(status != 0)
    {
      if(ThisTask == 0)
        printf("\nNo domain decomposition that stays within memory bounds is poss
      ible.\n");
      endrun(0);
    }

  /* now try to improve the work-load balance of the split */
  domain_shiftSplit();

  DomainMyStart = DomainStartList[ThisTask];
  DomainMyLast = DomainEndList[ThisTask];

  if(ThisTask == 0)
    {
      sumload = maxload = 0;
      sumwork = maxwork = 0;
      for(i = 0; i < NTask; i++)
        {
          sumload += list_load[i];
          sumwork += list_work[i];

          if(list_load[i] > maxload)
            maxload = list_load[i];

          if(list_work[i] > maxwork)
            maxwork = list_work[i];
        }

      printf("work-load balance=%g   memory-balance=%g\n",
             maxwork / (sumwork / NTask), maxload / (((double) sumload) / NTask))
      ;
    }


  /* determine for each cpu how many particles have to be shifted to other cpus *
      /
  domain_countToGo();

  for(i = 0, sumtogo = 0; i < NTask * NTask; i++)
    sumtogo += toGo[i];

  while(sumtogo > 0)
    {
      if(ThisTask == 0)
        {
          printf("exchange of %d%09d particles\n", (int) (sumtogo / 1000000000),
                 (int) (sumtogo % 1000000000));
          fflush(stdout);
        }

      for(ngrp = 1; ngrp < (1 << PTask); ngrp++)
        {
          for(task = 0; task < NTask; task++)
            {
              partner = task ^ ngrp;

              if(partner < NTask && task < partner)
                {
                  /* treat SPH separately */
                  if(All.TotN_gas > 0)
                    {
                      domain_findExchangeNumbers(task, partner, 1, &sendcount, &r
      ecvcount);

                      list_NumPart[task] += recvcount - sendcount;
                      list_NumPart[partner] -= recvcount - sendcount;
                      list_N_gas[task] += recvcount - sendcount;
                      list_N_gas[partner] -= recvcount - sendcount;

                      toGo[task * NTask + partner] -= sendcount;
                      toGo[partner * NTask + task] -= recvcount;
                      toGoSph[task * NTask + partner] -= sendcount;
                      toGoSph[partner * NTask + task] -= recvcount;

                      if(task == ThisTask)      /* actually carry out the exchang
      e */
                        domain_exchangeParticles(partner, 1, sendcount, recvcount
      );
                      if(partner == ThisTask)
                        domain_exchangeParticles(task, 1, recvcount, sendcount);
                    }

                  domain_findExchangeNumbers(task, partner, 0, &sendcount, &recvc
      ount);

                  list_NumPart[task] += recvcount - sendcount;
                  list_NumPart[partner] -= recvcount - sendcount;

                  toGo[task * NTask + partner] -= sendcount;
                  toGo[partner * NTask + task] -= recvcount;

                  if(task == ThisTask)  /* actually carry out the exchange */
                    domain_exchangeParticles(partner, 0, sendcount, recvcount);
                  if(partner == ThisTask)
                    domain_exchangeParticles(task, 0, recvcount, sendcount);
                }
            }
        }

      for(i = 0, sumtogo = 0; i < NTask * NTask; i++)
        sumtogo += toGo[i];
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a647e0c1a76b7f064ed5d201662f364bf_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a647e0c1a76b7f064ed5d201662f364bf_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae8e3aa408eaab9544cb7f93e69185492}{
\index{proto.h@{proto.h}!domain\_\-Decomposition@{domain\_\-Decomposition}}
\index{domain\_\-Decomposition@{domain\_\-Decomposition}!proto.h@{proto.h}}
\subsubsection[{domain\_\-Decomposition}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-Decomposition (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ae8e3aa408eaab9544cb7f93e69185492}
This is the main routine for the domain decomposition. It acts as a driver routine that allocates various temporary buffers, maps the particles back onto the periodic box if needed, and then does the domain decomposition, and a final Peano-\/Hilbert order of all particles as a tuning measure. 

Definition at line 62 of file domain.c.



References All, global\_\-data\_\-all\_\-processes::CPU\_\-Domain, global\_\-data\_\-all\_\-processes::CPU\_\-Peano, do\_\-box\_\-wrapping(), domain\_\-decompose(), Key, KeySorted, list\_\-load, list\_\-loadsph, list\_\-N\_\-gas, list\_\-NumPart, list\_\-work, local\_\-toGo, local\_\-toGoSph, maxload, maxloadsph, global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MaxPartSph, N\_\-gas, NTask, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, peano\_\-hilbert\_\-order(), global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, second(), ThisTask, global\_\-data\_\-all\_\-processes::Ti\_\-Current, timediff(), toGo, toGoSph, global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, and TreeReconstructFlag.



Referenced by find\_\-next\_\-sync\_\-point\_\-and\_\-drift(), init(), and run().




\begin{DoxyCode}
{
  double t0, t1;

#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)
    {
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
      /* to make sure that we do a domain decomposition before the PM-force is ev
      aluated.
         this is needed to make sure that the particles are wrapped into the box 
      */
    }
#endif

  /* Check whether it is really time for a new domain decomposition */
  if(All.NumForcesSinceLastDomainDecomp > All.TotNumPart * All.
      TreeDomainUpdateFrequency)
    {
      t0 = second();

#ifdef PERIODIC
      do_box_wrapping();        /* map the particles back onto the box */
#endif
      All.NumForcesSinceLastDomainDecomp = 0;
      TreeReconstructFlag = 1;  /* ensures that new tree will be constructed */

      if(ThisTask == 0)
        {
          printf("domain decomposition... \n");
          fflush(stdout);
        }

      Key = malloc(sizeof(peanokey) * All.MaxPart);
      KeySorted = malloc(sizeof(peanokey) * All.MaxPart);

      toGo = malloc(sizeof(int) * NTask * NTask);
      toGoSph = malloc(sizeof(int) * NTask * NTask);
      local_toGo = malloc(sizeof(int) * NTask);
      local_toGoSph = malloc(sizeof(int) * NTask);
      list_NumPart = malloc(sizeof(int) * NTask);
      list_N_gas = malloc(sizeof(int) * NTask);
      list_load = malloc(sizeof(int) * NTask);
      list_loadsph = malloc(sizeof(int) * NTask);
      list_work = malloc(sizeof(double) * NTask);

      MPI_Allgather(&NumPart, 1, MPI_INT, list_NumPart, 1, MPI_INT, MPI_COMM_WORL
      D);
      MPI_Allgather(&N_gas, 1, MPI_INT, list_N_gas, 1, MPI_INT, MPI_COMM_WORLD);

      maxload = All.MaxPart * REDUC_FAC;
      maxloadsph = All.MaxPartSph * REDUC_FAC;

      domain_decompose();

      free(list_work);
      free(list_loadsph);
      free(list_load);
      free(list_N_gas);
      free(list_NumPart);
      free(local_toGoSph);
      free(local_toGo);
      free(toGoSph);
      free(toGo);


      if(ThisTask == 0)
        {
          printf("domain decomposition done. \n");
          fflush(stdout);
        }

      t1 = second();
      All.CPU_Domain += timediff(t0, t1);

#ifdef PEANOHILBERT
      t0 = second();
      peano_hilbert_order();
      t1 = second();
      All.CPU_Peano += timediff(t0, t1);
#endif

      free(KeySorted);
      free(Key);
    }

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae8e3aa408eaab9544cb7f93e69185492_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae8e3aa408eaab9544cb7f93e69185492_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729}{
\index{proto.h@{proto.h}!domain\_\-determineTopTree@{domain\_\-determineTopTree}}
\index{domain\_\-determineTopTree@{domain\_\-determineTopTree}!proto.h@{proto.h}}
\subsubsection[{domain\_\-determineTopTree}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-determineTopTree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729}
This function constructs the global top-\/level tree node that is used for the domain decomposition. This is done by considering the string of Peano-\/Hilbert keys for all particles, which is recursively chopped off in pieces of eight segments until each segment holds at most a certain number of particles. 

$<$ Bits per dimension available for Peano-\/Hilbert order. Note: If peanokey is defined 0 0 int, the allowed maximum is 10. If 64-\/bit integers are used, the maximum is 21

$<$ Bits per dimension available for Peano-\/Hilbert order. Note: If peanokey is defined 0 0 0 , the allowed maximum is 10. If 64-\/bit integers are used, the maximum is 21

$<$ The number of different Peano-\/Hilbert cells

$<$ Bits per dimension available for Peano-\/Hilbert order. Note: If peanokey is defined 0 0 0 , the allowed maximum is 10. If 64-\/bit integers are used, the maximum is 21

$<$ The number of different Peano-\/Hilbert cells 



Definition at line 896 of file domain.c.



References All, BITS\_\-PER\_\-DIMENSION, topnode\_\-data::Blocks, topnode\_\-exchange::Count, topnode\_\-data::Count, topnode\_\-data::Daughter, domain\_\-compare\_\-key(), domain\_\-compare\_\-toplist(), domain\_\-topsplit(), domain\_\-topsplit\_\-local(), DomainCorner, DomainFac, Key, KeySorted, NTask, NTopnodes, NumPart, P, peano\_\-hilbert\_\-key(), topnode\_\-data::Pstart, topnode\_\-data::Size, topnode\_\-exchange::Startkey, topnode\_\-data::StartKey, toplist, toplist\_\-local, TopNodes, and global\_\-data\_\-all\_\-processes::TotNumPart.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int i, ntop_local, ntop;
  int *ntopnodelist, *ntopoffset;

  for(i = 0; i < NumPart; i++)
    {
      KeySorted[i] = Key[i] = peano_hilbert_key((P[i].Pos[0] - DomainCorner[0]) *
       DomainFac,
                                                (P[i].Pos[1] - DomainCorner[1]) *
       DomainFac,
                                                (P[i].Pos[2] - DomainCorner[2]) *
       DomainFac,
                                                BITS_PER_DIMENSION);
    }

  qsort(KeySorted, NumPart, sizeof(peanokey), domain_compare_key);

  NTopnodes = 1;
  TopNodes[0].Daughter = -1;
  TopNodes[0].Size = PEANOCELLS;
  TopNodes[0].StartKey = 0;
  TopNodes[0].Count = NumPart;
  TopNodes[0].Pstart = 0;

  domain_topsplit_local(0, 0);

  toplist_local = malloc(NTopnodes * sizeof(struct topnode_exchange));

  for(i = 0, ntop_local = 0; i < NTopnodes; i++)
    {
      if(TopNodes[i].Daughter == -1)    /* only use leaves */
        {
          toplist_local[ntop_local].Startkey = TopNodes[i].StartKey;
          toplist_local[ntop_local].Count = TopNodes[i].Count;
          ntop_local++;
        }
    }

  ntopnodelist = malloc(sizeof(int) * NTask);
  ntopoffset = malloc(sizeof(int) * NTask);

  MPI_Allgather(&ntop_local, 1, MPI_INT, ntopnodelist, 1, MPI_INT, MPI_COMM_WORLD
      );

  for(i = 0, ntop = 0, ntopoffset[0] = 0; i < NTask; i++)
    {
      ntop += ntopnodelist[i];
      if(i > 0)
        ntopoffset[i] = ntopoffset[i - 1] + ntopnodelist[i - 1];
    }


  toplist = malloc(ntop * sizeof(struct topnode_exchange));

  for(i = 0; i < NTask; i++)
    {
      ntopnodelist[i] *= sizeof(struct topnode_exchange);
      ntopoffset[i] *= sizeof(struct topnode_exchange);
    }

  MPI_Allgatherv(toplist_local, ntop_local * sizeof(struct topnode_exchange), MPI
      _BYTE,
                 toplist, ntopnodelist, ntopoffset, MPI_BYTE, MPI_COMM_WORLD);

  qsort(toplist, ntop, sizeof(struct topnode_exchange), domain_compare_toplist);

  NTopnodes = 1;
  TopNodes[0].Daughter = -1;
  TopNodes[0].Size = PEANOCELLS;
  TopNodes[0].StartKey = 0;
  TopNodes[0].Count = All.TotNumPart;
  TopNodes[0].Pstart = 0;
  TopNodes[0].Blocks = ntop;

  domain_topsplit(0, 0);

  free(toplist);
  free(ntopoffset);
  free(ntopnodelist);
  free(toplist_local);

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca}{
\index{proto.h@{proto.h}!domain\_\-exchangeParticles@{domain\_\-exchangeParticles}}
\index{domain\_\-exchangeParticles@{domain\_\-exchangeParticles}!proto.h@{proto.h}}
\subsubsection[{domain\_\-exchangeParticles}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-exchangeParticles (
\begin{DoxyParamCaption}
\item[{int}]{ partner, }
\item[{int}]{ sphflag, }
\item[{int}]{ send\_\-count, }
\item[{int}]{ recv\_\-count}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca}
This function exchanges particles between two CPUs according to the domain split. In doing this, the memory boundaries which may restrict the exhange process are observed. 

Definition at line 595 of file domain.c.



References topnode\_\-data::Daughter, DomainKeyBuf, DomainPartBuf, DomainSphBuf, DomainTask, endrun(), Key, topnode\_\-data::Leaf, N\_\-gas, NumPart, P, SphP, topnode\_\-data::StartKey, TAG\_\-KEY, TAG\_\-PDATA, TAG\_\-SPHDATA, ThisTask, and TopNodes.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int i, no, n, count, rep;
  MPI_Status status;

  for(n = 0, count = 0; count < send_count && n < NumPart; n++)
    {
      if(sphflag)
        {
          if(P[n].Type != 0)
            continue;
        }
      else
        {
          if(P[n].Type == 0)
            continue;
        }

      no = 0;

      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (Key[n] - TopNodes[no].StartKey) / (
      TopNodes[no].Size / 8);

      no = TopNodes[no].Leaf;

      if(DomainTask[no] == partner)
        {
          if(sphflag)           /* special reorder routine for SPH particles (nee
      d to stay at beginning) */
            {
              DomainPartBuf[count] = P[n];      /* copy particle and collect in c
      ontiguous memory */
              DomainKeyBuf[count] = Key[n];
              DomainSphBuf[count] = SphP[n];

              P[n] = P[N_gas - 1];
              P[N_gas - 1] = P[NumPart - 1];

              Key[n] = Key[N_gas - 1];
              Key[N_gas - 1] = Key[NumPart - 1];

              SphP[n] = SphP[N_gas - 1];

              N_gas--;
            }
          else
            {
              DomainPartBuf[count] = P[n];      /* copy particle and collect in c
      ontiguous memory */
              DomainKeyBuf[count] = Key[n];
              P[n] = P[NumPart - 1];
              Key[n] = Key[NumPart - 1];
            }

          count++;
          NumPart--;
          n--;
        }
    }

  if(count != send_count)
    {
      printf("Houston, we got a problem...\n");
      printf("ThisTask=%d count=%d send_count=%d\n", ThisTask, count, send_count)
      ;
      endrun(88);
    }

  /* transmit */

  for(rep = 0; rep < 2; rep++)
    {
      if((rep == 0 && ThisTask < partner) || (rep == 1 && ThisTask > partner))
        {
          if(send_count > 0)
            {
              MPI_Ssend(&DomainPartBuf[0], send_count * sizeof(struct 
      particle_data), MPI_BYTE, partner,
                        TAG_PDATA, MPI_COMM_WORLD);

              MPI_Ssend(&DomainKeyBuf[0], send_count * sizeof(peanokey), MPI_BYTE
      , partner, TAG_KEY,
                        MPI_COMM_WORLD);

              if(sphflag)
                MPI_Ssend(&DomainSphBuf[0], send_count * sizeof(struct 
      sph_particle_data), MPI_BYTE, partner,
                          TAG_SPHDATA, MPI_COMM_WORLD);
            }
        }

      if((rep == 1 && ThisTask < partner) || (rep == 0 && ThisTask > partner))
        {
          if(recv_count > 0)
            {
              if(sphflag)
                {
                  if((NumPart - N_gas) > recv_count)
                    {
                      for(i = 0; i < recv_count; i++)
                        {
                          P[NumPart + i] = P[N_gas + i];
                          Key[NumPart + i] = Key[N_gas + i];
                        }
                    }
                  else
                    {
                      for(i = NumPart - 1; i >= N_gas; i--)
                        {
                          P[i + recv_count] = P[i];
                          Key[i + recv_count] = Key[i];
                        }
                    }

                  MPI_Recv(&P[N_gas], recv_count * sizeof(struct particle_data), 
      MPI_BYTE, partner, TAG_PDATA,
                           MPI_COMM_WORLD, &status);
                  MPI_Recv(&Key[N_gas], recv_count * sizeof(peanokey), MPI_BYTE, 
      partner, TAG_KEY,
                           MPI_COMM_WORLD, &status);
                  MPI_Recv(&SphP[N_gas], recv_count * sizeof(struct 
      sph_particle_data), MPI_BYTE, partner,
                           TAG_SPHDATA, MPI_COMM_WORLD, &status);

                  N_gas += recv_count;
                }
              else
                {
                  MPI_Recv(&P[NumPart], recv_count * sizeof(struct particle_data)
      , MPI_BYTE, partner,
                           TAG_PDATA, MPI_COMM_WORLD, &status);
                  MPI_Recv(&Key[NumPart], recv_count * sizeof(peanokey), MPI_BYTE
      , partner,
                           TAG_KEY, MPI_COMM_WORLD, &status);
                }

              NumPart += recv_count;
            }
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0e758ec7eef32fc7180092547f5a11b9}{
\index{proto.h@{proto.h}!domain\_\-findExchangeNumbers@{domain\_\-findExchangeNumbers}}
\index{domain\_\-findExchangeNumbers@{domain\_\-findExchangeNumbers}!proto.h@{proto.h}}
\subsubsection[{domain\_\-findExchangeNumbers}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-findExchangeNumbers (
\begin{DoxyParamCaption}
\item[{int}]{ task, }
\item[{int}]{ partner, }
\item[{int}]{ sphflag, }
\item[{int $\ast$}]{ send, }
\item[{int $\ast$}]{ recv}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0e758ec7eef32fc7180092547f5a11b9}
This function counts how many particles have to be exchanged between two CPUs according to the domain split. If the CPUs are already quite full and hold data from other CPUs as well, not all the particles may be exchanged at once. In this case the communication phase has to be repeated, until enough of the third-\/party particles have been moved away such that the decomposition can be completed. 

Definition at line 534 of file domain.c.



References All, global\_\-data\_\-all\_\-processes::BunchSizeDomain, imin(), list\_\-N\_\-gas, list\_\-NumPart, global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MaxPartSph, NTask, toGo, and toGoSph.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int numpartA, numpartsphA, ntobesentA, maxsendA, maxsendA_old;
  int numpartB, numpartsphB, ntobesentB, maxsendB, maxsendB_old;

  numpartA = list_NumPart[task];
  numpartsphA = list_N_gas[task];

  numpartB = list_NumPart[partner];
  numpartsphB = list_N_gas[partner];

  if(sphflag == 1)
    {
      ntobesentA = toGoSph[task * NTask + partner];
      ntobesentB = toGoSph[partner * NTask + task];
    }
  else
    {
      ntobesentA = toGo[task * NTask + partner] - toGoSph[task * NTask + partner]
      ;
      ntobesentB = toGo[partner * NTask + task] - toGoSph[partner * NTask + task]
      ;
    }

  maxsendA = imin(ntobesentA, All.BunchSizeDomain);
  maxsendB = imin(ntobesentB, All.BunchSizeDomain);

  do
    {
      maxsendA_old = maxsendA;
      maxsendB_old = maxsendB;

      maxsendA = imin(All.MaxPart - numpartB + maxsendB, maxsendA);
      maxsendB = imin(All.MaxPart - numpartA + maxsendA, maxsendB);
    }
  while((maxsendA != maxsendA_old) || (maxsendB != maxsendB_old));


  /* now make also sure that there is enough space for SPH particeles */
  if(sphflag == 1)
    {
      do
        {
          maxsendA_old = maxsendA;
          maxsendB_old = maxsendB;

          maxsendA = imin(All.MaxPartSph - numpartsphB + maxsendB, maxsendA);
          maxsendB = imin(All.MaxPartSph - numpartsphA + maxsendA, maxsendB);
        }
      while((maxsendA != maxsendA_old) || (maxsendB != maxsendB_old));
    }

  *send = maxsendA;
  *recv = maxsendB;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_a0e758ec7eef32fc7180092547f5a11b9_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a0e758ec7eef32fc7180092547f5a11b9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e}{
\index{proto.h@{proto.h}!domain\_\-findExtent@{domain\_\-findExtent}}
\index{domain\_\-findExtent@{domain\_\-findExtent}!proto.h@{proto.h}}
\subsubsection[{domain\_\-findExtent}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-findExtent (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e}
This routine finds the extent of the global domain grid. 

$<$ Bits per dimension available for Peano-\/Hilbert order. Note: If peanokey is defined 0 0 int, the allowed maximum is 10. If 64-\/bit integers are used, the maximum is 21 



Definition at line 845 of file domain.c.



References DomainCenter, DomainCorner, DomainFac, DomainLen, NumPart, P, and particle\_\-data::Pos.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int i, j;
  double len, xmin[3], xmax[3], xmin_glob[3], xmax_glob[3];

  /* determine local extension */
  for(j = 0; j < 3; j++)
    {
      xmin[j] = MAX_REAL_NUMBER;
      xmax[j] = -MAX_REAL_NUMBER;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          if(xmin[j] > P[i].Pos[j])
            xmin[j] = P[i].Pos[j];

          if(xmax[j] < P[i].Pos[j])
            xmax[j] = P[i].Pos[j];
        }
    }

  MPI_Allreduce(xmin, xmin_glob, 3, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
  MPI_Allreduce(xmax, xmax_glob, 3, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);

  len = 0;
  for(j = 0; j < 3; j++)
    if(xmax_glob[j] - xmin_glob[j] > len)
      len = xmax_glob[j] - xmin_glob[j];

  len *= 1.001;

  for(j = 0; j < 3; j++)
    {
      DomainCenter[j] = 0.5 * (xmin_glob[j] + xmax_glob[j]);
      DomainCorner[j] = 0.5 * (xmin_glob[j] + xmax_glob[j]) - 0.5 * len;
    }

  DomainLen = len;
  DomainFac = 1.0 / len * (((peanokey) 1) << (BITS_PER_DIMENSION));
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a412d5d8810751249cc8dcd9e219e4e57}{
\index{proto.h@{proto.h}!domain\_\-findSplit@{domain\_\-findSplit}}
\index{domain\_\-findSplit@{domain\_\-findSplit}!proto.h@{proto.h}}
\subsubsection[{domain\_\-findSplit}]{\setlength{\rightskip}{0pt plus 5cm}int domain\_\-findSplit (
\begin{DoxyParamCaption}
\item[{int}]{ cpustart, }
\item[{int}]{ ncpu, }
\item[{int}]{ first, }
\item[{int}]{ last}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a412d5d8810751249cc8dcd9e219e4e57}
This function tries to find a split point in a range of cells in the domain-\/grid. The range of cells starts at 'first', and ends at 'last' (inclusively). The number of cpus that holds the range is 'ncpu', with the first cpu given by 'cpustart'. If more than 2 cpus are to be split, the function calls itself recursively. The division tries to achieve a best particle-\/load balance under the constraint that 'maxload' and 'maxloadsph' may not be exceeded, and that each cpu holds at least one cell from the domaingrid. If such a decomposition cannot be achieved, a non-\/zero error code is returned.

After successful completion, DomainMyStart\mbox{[}\mbox{]} and DomainMyLast\mbox{[}\mbox{]} contain the first and last cell of the domaingrid assigned to the local task for the given type. Also, DomainTask\mbox{[}\mbox{]} contains for each cell the task it was assigned to. 

Definition at line 327 of file domain.c.



References dmax(), domain\_\-findSplit(), DomainCount, DomainCountSph, DomainEndList, DomainStartList, DomainTask, list\_\-load, list\_\-loadsph, maxload, and maxloadsph.



Referenced by domain\_\-decompose(), and domain\_\-findSplit().




\begin{DoxyCode}
{
  int i, split, ok_left, ok_right;
  long long load, sphload, load_leftOfSplit, sphload_leftOfSplit;
  int ncpu_leftOfSplit;
  double maxAvgLoad_CurrentSplit, maxAvgLoad_NewSplit;


  ncpu_leftOfSplit = ncpu / 2;

  for(i = first, load = 0, sphload = 0; i <= last; i++)
    {
      load += DomainCount[i];
      sphload += DomainCountSph[i];
    }

  split = first + ncpu_leftOfSplit;

  for(i = first, load_leftOfSplit = sphload_leftOfSplit = 0; i < split; i++)
    {
      load_leftOfSplit += DomainCount[i];
      sphload_leftOfSplit += DomainCountSph[i];
    }

  /* find the best split point in terms of work-load balance */

  while(split < last - (ncpu - ncpu_leftOfSplit - 1) && split > 0)
    {
      maxAvgLoad_CurrentSplit =
        dmax(load_leftOfSplit / ncpu_leftOfSplit, (load - load_leftOfSplit) / (nc
      pu - ncpu_leftOfSplit));

      maxAvgLoad_NewSplit =
        dmax((load_leftOfSplit + DomainCount[split]) / ncpu_leftOfSplit,
             (load - load_leftOfSplit - DomainCount[split]) / (ncpu - ncpu_leftOf
      Split));

      if(maxAvgLoad_NewSplit <= maxAvgLoad_CurrentSplit)
        {
          load_leftOfSplit += DomainCount[split];
          sphload_leftOfSplit += DomainCountSph[split];
          split++;
        }
      else
        break;
    }


  /* we will now have to check whether this solution is possible given the restri
      ctions on the maximum load */

  for(i = first, load_leftOfSplit = 0, sphload_leftOfSplit = 0; i < split; i++)
    {
      load_leftOfSplit += DomainCount[i];
      sphload_leftOfSplit += DomainCountSph[i];
    }

  if(load_leftOfSplit > maxload * ncpu_leftOfSplit ||
     (load - load_leftOfSplit) > maxload * (ncpu - ncpu_leftOfSplit))
    {
      /* we did not find a viable split */
      return -1;
    }

  if(sphload_leftOfSplit > maxloadsph * ncpu_leftOfSplit ||
     (sphload - sphload_leftOfSplit) > maxloadsph * (ncpu - ncpu_leftOfSplit))
    {
      /* we did not find a viable split */
      return -1;
    }

  if(ncpu_leftOfSplit >= 2)
    ok_left = domain_findSplit(cpustart, ncpu_leftOfSplit, first, split - 1);
  else
    ok_left = 0;

  if((ncpu - ncpu_leftOfSplit) >= 2)
    ok_right = domain_findSplit(cpustart + ncpu_leftOfSplit, ncpu - ncpu_leftOfSp
      lit, split, last);
  else
    ok_right = 0;

  if(ok_left == 0 && ok_right == 0)
    {
      /* found a viable split */

      if(ncpu_leftOfSplit == 1)
        {
          for(i = first; i < split; i++)
            DomainTask[i] = cpustart;

          list_load[cpustart] = load_leftOfSplit;
          list_loadsph[cpustart] = sphload_leftOfSplit;
          DomainStartList[cpustart] = first;
          DomainEndList[cpustart] = split - 1;
        }

      if((ncpu - ncpu_leftOfSplit) == 1)
        {
          for(i = split; i <= last; i++)
            DomainTask[i] = cpustart + ncpu_leftOfSplit;

          list_load[cpustart + ncpu_leftOfSplit] = load - load_leftOfSplit;
          list_loadsph[cpustart + ncpu_leftOfSplit] = sphload - sphload_leftOfSpl
      it;
          DomainStartList[cpustart + ncpu_leftOfSplit] = split;
          DomainEndList[cpustart + ncpu_leftOfSplit] = last;
        }

      return 0;
    }

  /* we did not find a viable split */
  return -1;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=388pt]{proto_8h_a412d5d8810751249cc8dcd9e219e4e57_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a412d5d8810751249cc8dcd9e219e4e57_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a89c54187117b91d4270a4f0c406ce2ba}{
\index{proto.h@{proto.h}!domain\_\-shiftSplit@{domain\_\-shiftSplit}}
\index{domain\_\-shiftSplit@{domain\_\-shiftSplit}!proto.h@{proto.h}}
\subsubsection[{domain\_\-shiftSplit}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-shiftSplit (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a89c54187117b91d4270a4f0c406ce2ba}
This function tries to improve the domain decomposition found by \hyperlink{domain_8c_a412d5d8810751249cc8dcd9e219e4e57}{domain\_\-findSplit()} with respect to work-\/load balance. To this end, the boundaries in the existing domain-\/split solution (which was found by trying to balance the particle load) are shifted as long as this leads to better work-\/load while still remaining within the allowed memory-\/imbalance constraints. 

Definition at line 447 of file domain.c.



References dmax(), DomainCount, DomainCountSph, DomainEndList, DomainStartList, DomainTask, DomainWork, list\_\-load, list\_\-loadsph, list\_\-work, maxload, maxloadsph, NTask, and NTopleaves.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int i, task, iter = 0, moved;
  double maxw, newmaxw;

  for(task = 0; task < NTask; task++)
    list_work[task] = 0;

  for(i = 0; i < NTopleaves; i++)
    list_work[DomainTask[i]] += DomainWork[i];

  do
    {
      for(task = 0, moved = 0; task < NTask - 1; task++)
        {
          maxw = dmax(list_work[task], list_work[task + 1]);

          if(list_work[task] < list_work[task + 1])
            {
              newmaxw = dmax(list_work[task] + DomainWork[DomainStartList[task + 
      1]],
                             list_work[task + 1] - DomainWork[DomainStartList[tas
      k + 1]]);
              if(newmaxw <= maxw)
                {
                  if(list_load[task] + DomainCount[DomainStartList[task + 1]] <= 
      maxload)
                    {
                      if(list_loadsph[task] + DomainCountSph[DomainStartList[task
       + 1]] > maxloadsph)
                        continue;

                      /* ok, we can move one domain cell from right to left */
                      list_work[task] += DomainWork[DomainStartList[task + 1]];
                      list_load[task] += DomainCount[DomainStartList[task + 1]];
                      list_loadsph[task] += DomainCountSph[DomainStartList[task +
       1]];
                      list_work[task + 1] -= DomainWork[DomainStartList[task + 1]
      ];
                      list_load[task + 1] -= DomainCount[DomainStartList[task + 1
      ]];
                      list_loadsph[task + 1] -= DomainCountSph[DomainStartList[ta
      sk + 1]];

                      DomainTask[DomainStartList[task + 1]] = task;
                      DomainStartList[task + 1] += 1;
                      DomainEndList[task] += 1;

                      moved++;
                    }
                }
            }
          else
            {
              newmaxw = dmax(list_work[task] - DomainWork[DomainEndList[task]],
                             list_work[task + 1] + DomainWork[DomainEndList[task]
      ]);
              if(newmaxw <= maxw)
                {
                  if(list_load[task + 1] + DomainCount[DomainEndList[task]] <= 
      maxload)
                    {
                      if(list_loadsph[task + 1] + DomainCountSph[DomainEndList[ta
      sk]] > maxloadsph)
                        continue;

                      /* ok, we can move one domain cell from left to right */
                      list_work[task] -= DomainWork[DomainEndList[task]];
                      list_load[task] -= DomainCount[DomainEndList[task]];
                      list_loadsph[task] -= DomainCountSph[DomainEndList[task]];
                      list_work[task + 1] += DomainWork[DomainEndList[task]];
                      list_load[task + 1] += DomainCount[DomainEndList[task]];
                      list_loadsph[task + 1] += DomainCountSph[DomainEndList[task
      ]];

                      DomainTask[DomainEndList[task]] = task + 1;
                      DomainEndList[task] -= 1;
                      DomainStartList[task + 1] -= 1;

                      moved++;
                    }
                }

            }
        }

      iter++;
    }
  while(moved > 0 && iter < 10 * NTopleaves);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{proto_8h_a89c54187117b91d4270a4f0c406ce2ba_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a89c54187117b91d4270a4f0c406ce2ba_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a25aada0d3751c2afd2a376151d1d917e}{
\index{proto.h@{proto.h}!domain\_\-sumCost@{domain\_\-sumCost}}
\index{domain\_\-sumCost@{domain\_\-sumCost}!proto.h@{proto.h}}
\subsubsection[{domain\_\-sumCost}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-sumCost (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a25aada0d3751c2afd2a376151d1d917e}
This routine bins the particles onto the domain-\/grid, i.e. it sums up the total number of particles and the total amount of work in each of the domain-\/cells. This information forms the basis for the actual decision on the adopted domain decomposition. 

Definition at line 786 of file domain.c.



References topnode\_\-data::Daughter, domain\_\-walktoptree(), DomainCount, DomainCountSph, DomainWork, particle\_\-data::GravCost, Key, topnode\_\-data::Leaf, NTopleaves, NTopnodes, NumPart, P, topnode\_\-data::StartKey, ThisTask, and TopNodes.



Referenced by domain\_\-decompose().




\begin{DoxyCode}
{
  int i, n, no;
  double *local_DomainWork;
  int *local_DomainCount;
  int *local_DomainCountSph;

  local_DomainWork = malloc(NTopnodes * sizeof(double));
  local_DomainCount = malloc(NTopnodes * sizeof(int));
  local_DomainCountSph = malloc(NTopnodes * sizeof(int));



  NTopleaves = 0;

  domain_walktoptree(0);

  for(i = 0; i < NTopleaves; i++)
    {
      local_DomainWork[i] = 0;
      local_DomainCount[i] = 0;
      local_DomainCountSph[i] = 0;
    }

  if(ThisTask == 0)
    printf("NTopleaves= %d\n", NTopleaves);

  for(n = 0; n < NumPart; n++)
    {
      no = 0;

      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (Key[n] - TopNodes[no].StartKey) / (
      TopNodes[no].Size / 8);

      no = TopNodes[no].Leaf;

      if(P[n].Ti_endstep > P[n].Ti_begstep)
        local_DomainWork[no] += (1.0 + P[n].GravCost) / (P[n].Ti_endstep - P[n].T
      i_begstep);
      else
        local_DomainWork[no] += (1.0 + P[n].GravCost);

      local_DomainCount[no] += 1;
      if(P[n].Type == 0)
        local_DomainCountSph[no] += 1;
    }

  MPI_Allreduce(local_DomainWork, DomainWork, NTopleaves, MPI_DOUBLE, MPI_SUM, MP
      I_COMM_WORLD);
  MPI_Allreduce(local_DomainCount, DomainCount, NTopleaves, MPI_INT, MPI_SUM, MPI
      _COMM_WORLD);
  MPI_Allreduce(local_DomainCountSph, DomainCountSph, NTopleaves, MPI_INT, MPI_SU
      M, MPI_COMM_WORLD);


  free(local_DomainCountSph);
  free(local_DomainCount);
  free(local_DomainWork);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{proto_8h_a25aada0d3751c2afd2a376151d1d917e_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a25aada0d3751c2afd2a376151d1d917e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a606de536756a67ad8f79f1135009195e}{
\index{proto.h@{proto.h}!domain\_\-topsplit@{domain\_\-topsplit}}
\index{domain\_\-topsplit@{domain\_\-topsplit}!proto.h@{proto.h}}
\subsubsection[{domain\_\-topsplit}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-topsplit (
\begin{DoxyParamCaption}
\item[{int}]{ node, }
\item[{{\bf peanokey}}]{ startkey}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a606de536756a67ad8f79f1135009195e}
This function is responsible for constructing the global top-\/level tree segments. Starting from a joint list of all local top-\/level segments, in which mulitple occurences of the same spatial segment have been combined, a segment is subdivided into 8 pieces recursively until the number of particles in each segment has fallen below All.TotNumPart / (TOPNODEFACTOR $\ast$ NTask). 

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition 



Definition at line 1049 of file domain.c.



References All, topnode\_\-data::Blocks, topnode\_\-exchange::Count, topnode\_\-data::Count, topnode\_\-data::Daughter, domain\_\-topsplit(), endrun(), MAXTOPNODES, NTask, NTopnodes, topnode\_\-data::Pstart, topnode\_\-data::Size, topnode\_\-exchange::Startkey, topnode\_\-data::StartKey, ThisTask, toplist, TOPNODEFACTOR, TopNodes, and global\_\-data\_\-all\_\-processes::TotNumPart.



Referenced by domain\_\-determineTopTree(), and domain\_\-topsplit().




\begin{DoxyCode}
{
  int i, p, sub, bin;

  if(TopNodes[node].Size >= 8)
    {
      TopNodes[node].Daughter = NTopnodes;

      for(i = 0; i < 8; i++)
        {
          if(NTopnodes < MAXTOPNODES)
            {
              sub = TopNodes[node].Daughter + i;
              TopNodes[sub].Size = TopNodes[node].Size / 8;
              TopNodes[sub].Count = 0;
              TopNodes[sub].Blocks = 0;
              TopNodes[sub].Daughter = -1;
              TopNodes[sub].StartKey = startkey + i * TopNodes[sub].Size;
              TopNodes[sub].Pstart = TopNodes[node].Pstart;
              NTopnodes++;
            }
          else
            {
              printf("Task=%d: We are out of Topnodes. Increasing the constant MA
      XTOPNODES might help.\n",
                     ThisTask);
              fflush(stdout);
              endrun(137213);
            }
        }

      for(p = TopNodes[node].Pstart; p < TopNodes[node].Pstart + TopNodes[node].
      Blocks; p++)
        {
          bin = (toplist[p].Startkey - startkey) / (TopNodes[node].Size / 8);
          sub = TopNodes[node].Daughter + bin;

          if(bin < 0 || bin > 7)
            endrun(77);

          if(TopNodes[sub].Blocks == 0)
            TopNodes[sub].Pstart = p;

          TopNodes[sub].Count += toplist[p].Count;
          TopNodes[sub].Blocks++;
        }

      for(i = 0; i < 8; i++)
        {
          sub = TopNodes[node].Daughter + i;
          if(TopNodes[sub].Count > All.TotNumPart / (TOPNODEFACTOR * NTask))
            domain_topsplit(sub, TopNodes[sub].StartKey);
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a606de536756a67ad8f79f1135009195e_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a606de536756a67ad8f79f1135009195e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aa5001f9be833c4673392b40e7be3a421}{
\index{proto.h@{proto.h}!domain\_\-topsplit\_\-local@{domain\_\-topsplit\_\-local}}
\index{domain\_\-topsplit\_\-local@{domain\_\-topsplit\_\-local}!proto.h@{proto.h}}
\subsubsection[{domain\_\-topsplit\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void domain\_\-topsplit\_\-local (
\begin{DoxyParamCaption}
\item[{int}]{ node, }
\item[{{\bf peanokey}}]{ startkey}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aa5001f9be833c4673392b40e7be3a421}
This function is responsible for constructing the local top-\/level Peano-\/Hilbert segments. A segment is cut into 8 pieces recursively until the number of particles in the segment has fallen below All.TotNumPart / (TOPNODEFACTOR $\ast$ NTask $\ast$ NTask). 

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition 



Definition at line 982 of file domain.c.



References All, topnode\_\-exchange::Count, topnode\_\-data::Count, topnode\_\-data::Daughter, domain\_\-topsplit\_\-local(), endrun(), KeySorted, MAXTOPNODES, NTask, NTopnodes, topnode\_\-data::Pstart, topnode\_\-data::Size, topnode\_\-data::StartKey, ThisTask, TOPNODEFACTOR, TopNodes, and global\_\-data\_\-all\_\-processes::TotNumPart.



Referenced by domain\_\-determineTopTree(), and domain\_\-topsplit\_\-local().




\begin{DoxyCode}
{
  int i, p, sub, bin;

  if(TopNodes[node].Size >= 8)
    {
      TopNodes[node].Daughter = NTopnodes;

      for(i = 0; i < 8; i++)
        {
          if(NTopnodes < MAXTOPNODES)
            {
              sub = TopNodes[node].Daughter + i;
              TopNodes[sub].Size = TopNodes[node].Size / 8;
              TopNodes[sub].Count = 0;
              TopNodes[sub].Daughter = -1;
              TopNodes[sub].StartKey = startkey + i * TopNodes[sub].Size;
              TopNodes[sub].Pstart = TopNodes[node].Pstart;

              NTopnodes++;
            }
          else
            {
              printf("task=%d: We are out of Topnodes. Increasing the constant MA
      XTOPNODES might help.\n",
                     ThisTask);
              fflush(stdout);
              endrun(13213);
            }
        }

      for(p = TopNodes[node].Pstart; p < TopNodes[node].Pstart + TopNodes[node].
      Count; p++)
        {
          bin = (KeySorted[p] - startkey) / (TopNodes[node].Size / 8);

          if(bin < 0 || bin > 7)
            {
              printf("task=%d: something odd has happened here. bin=%d\n", 
      ThisTask, bin);
              fflush(stdout);
              endrun(13123123);
            }

          sub = TopNodes[node].Daughter + bin;

          if(TopNodes[sub].Count == 0)
            TopNodes[sub].Pstart = p;

          TopNodes[sub].Count++;
        }

      for(i = 0; i < 8; i++)
        {
          sub = TopNodes[node].Daughter + i;
          if(TopNodes[sub].Count > All.TotNumPart / (TOPNODEFACTOR * NTask * 
      NTask))
            domain_topsplit_local(sub, TopNodes[sub].StartKey);
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aa5001f9be833c4673392b40e7be3a421_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aa5001f9be833c4673392b40e7be3a421_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e}{
\index{proto.h@{proto.h}!drift\_\-integ@{drift\_\-integ}}
\index{drift\_\-integ@{drift\_\-integ}!proto.h@{proto.h}}
\subsubsection[{drift\_\-integ}]{\setlength{\rightskip}{0pt plus 5cm}double drift\_\-integ (
\begin{DoxyParamCaption}
\item[{double}]{ a, }
\item[{void $\ast$}]{ param}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e}
Integration kernel for drift factor computation. 

Definition at line 179 of file driftfac.c.



References All, global\_\-data\_\-all\_\-processes::Hubble, global\_\-data\_\-all\_\-processes::Omega0, and global\_\-data\_\-all\_\-processes::OmegaLambda.




\begin{DoxyCode}
{
  double h;

  h = All.Omega0 / (a * a * a) + (1 - All.Omega0 - All.OmegaLambda) / (a * a) + 
      All.OmegaLambda;
  h = All.Hubble * sqrt(h);

  return 1 / (h * a * a * a);
}
\end{DoxyCode}


\hypertarget{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0}{
\index{proto.h@{proto.h}!dump\_\-particles@{dump\_\-particles}}
\index{dump\_\-particles@{dump\_\-particles}!proto.h@{proto.h}}
\subsubsection[{dump\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void dump\_\-particles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0}
This function dumps some of the basic particle data to a file. In case the tree construction fails, it is called just before the run terminates with an error message. Examination of the generated file may then give clues to what caused the problem. 

Definition at line 3040 of file forcetree.c.



References fd, FLOAT, my\_\-fwrite(), NumPart, P, and ThisTask.



Referenced by force\_\-create\_\-empty\_\-nodes(), and force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  FILE *fd;
  char buffer[200];
  int i;

  sprintf(buffer, "particles%d.dat", ThisTask);
  fd = fopen(buffer, "w");
  my_fwrite(&NumPart, 1, sizeof(int), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].Pos[0], 3, sizeof(FLOAT), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].Vel[0], 3, sizeof(FLOAT), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].ID, 1, sizeof(int), fd);

  fclose(fd);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a3757efb7e470353080a128388ccebec9}{
\index{proto.h@{proto.h}!empty\_\-read\_\-buffer@{empty\_\-read\_\-buffer}}
\index{empty\_\-read\_\-buffer@{empty\_\-read\_\-buffer}!proto.h@{proto.h}}
\subsubsection[{empty\_\-read\_\-buffer}]{\setlength{\rightskip}{0pt plus 5cm}void empty\_\-read\_\-buffer (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr, }
\item[{int}]{ offset, }
\item[{int}]{ pc, }
\item[{int}]{ type}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a3757efb7e470353080a128388ccebec9}
This function reads out the buffer that was filled with particle data, and stores it at the appropriate place in the particle structures. 

Definition at line 168 of file read\_\-ic.c.



References CommBuffer, particle\_\-data::ID, IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, IO\_\-VEL, particle\_\-data::Mass, P, particle\_\-data::Pos, SphP, particle\_\-data::Type, and particle\_\-data::Vel.



Referenced by read\_\-file().




\begin{DoxyCode}
{
  int n, k;
  float *fp;

#ifdef LONGIDS
  long long *ip;
#else
  int *ip;
#endif

  fp = CommBuffer;
  ip = CommBuffer;

  switch (blocknr)
    {
    case IO_POS:                /* positions */
      for(n = 0; n < pc; n++)
        for(k = 0; k < 3; k++)
          P[offset + n].Pos[k] = *fp++;

      for(n = 0; n < pc; n++)
        P[offset + n].Type = type;      /* initialize type here as well */
      break;

    case IO_VEL:                /* velocities */
      for(n = 0; n < pc; n++)
        for(k = 0; k < 3; k++)
          P[offset + n].Vel[k] = *fp++;
      break;

    case IO_ID:         /* particle ID */
      for(n = 0; n < pc; n++)
        P[offset + n].ID = *ip++;
      break;

    case IO_MASS:               /* particle mass */
      for(n = 0; n < pc; n++)
        P[offset + n].Mass = *fp++;
      break;

    case IO_U:                  /* temperature */
      for(n = 0; n < pc; n++)
        SphP[offset + n].Entropy = *fp++;
      break;

    case IO_RHO:                /* density */
      for(n = 0; n < pc; n++)
        SphP[offset + n].Density = *fp++;
      break;


    case IO_HSML:               /* SPH smoothing length */
      for(n = 0; n < pc; n++)
        SphP[offset + n].Hsml = *fp++;
      break;




      /* the other input fields (if present) are not needed to define the 
         initial conditions of the code */

    case IO_POT:
    case IO_ACCEL:
    case IO_DTENTR:
    case IO_TSTP:
      break;
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a3757efb7e470353080a128388ccebec9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d}{
\index{proto.h@{proto.h}!endrun@{endrun}}
\index{endrun@{endrun}!proto.h@{proto.h}}
\subsubsection[{endrun}]{\setlength{\rightskip}{0pt plus 5cm}void endrun (
\begin{DoxyParamCaption}
\item[{int}]{ ierr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d}
This function aborts the simulations. If a single processors wants an immediate termination, the function needs to be called with ierr$>$0. A bunch of MPI-\/error messages may also appear in this case. For ierr=0, MPI is gracefully cleaned up, but this requires that all processors call \hyperlink{endrun_8c_a6c7c5d488c8a9e1fb9c408ae00aa8839}{endrun()}. 

Definition at line 25 of file endrun.c.



References terminate\_\-processes(), and ThisTask.



Referenced by allocate\_\-commbuffers(), allocate\_\-memory(), check\_\-omega(), compute\_\-potential(), density(), domain\_\-decompose(), domain\_\-exchangeParticles(), domain\_\-topsplit(), domain\_\-topsplit\_\-local(), find\_\-files(), find\_\-next\_\-outputtime(), force\_\-create\_\-empty\_\-nodes(), force\_\-insert\_\-pseudo\_\-particles(), force\_\-treeallocate(), force\_\-treebuild\_\-single(), force\_\-treeevaluate(), force\_\-treeevaluate\_\-potential(), force\_\-treeevaluate\_\-potential\_\-shortrange(), force\_\-treeevaluate\_\-shortrange(), get\_\-particles\_\-in\_\-block(), get\_\-timestep(), gravity\_\-forcetest(), init(), long\_\-range\_\-force(), main(), my\_\-fread(), my\_\-fwrite(), ngb\_\-treeallocate(), open\_\-outputfiles(), pm\_\-init\_\-periodic\_\-allocate(), read\_\-file(), read\_\-parameter\_\-file(), readjust\_\-timebase(), restart(), savepositions(), update\_\-interaction\_\-table(), and write\_\-file().




\begin{DoxyCode}
{
  if(ierr)
    {
      printf("task %d: endrun called with an error level of %d\n\n\n", ThisTask, 
      ierr);
      fflush(stdout);
#ifdef DEBUG
      terminate_processes();
      raise(SIGABRT);
      sleep(60);
#else
      MPI_Abort(MPI_COMM_WORLD, ierr);
#endif
      exit(0);
    }

  MPI_Finalize();
  exit(0);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=284pt]{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae903322da17c6875ab606b032b918099}{
\index{proto.h@{proto.h}!energy\_\-statistics@{energy\_\-statistics}}
\index{energy\_\-statistics@{energy\_\-statistics}!proto.h@{proto.h}}
\subsubsection[{energy\_\-statistics}]{\setlength{\rightskip}{0pt plus 5cm}void energy\_\-statistics (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ae903322da17c6875ab606b032b918099}
This routine first calls a computation of various global quantities of the particle distribution, and then writes some statistics about the energies in the various particle components to the file FdEnergy. 

Definition at line 437 of file run.c.



References All, compute\_\-global\_\-quantities\_\-of\_\-system(), state\_\-of\_\-system::EnergyInt, state\_\-of\_\-system::EnergyIntComp, state\_\-of\_\-system::EnergyKin, state\_\-of\_\-system::EnergyKinComp, state\_\-of\_\-system::EnergyPot, state\_\-of\_\-system::EnergyPotComp, FdEnergy, state\_\-of\_\-system::MassComp, SysState, ThisTask, and global\_\-data\_\-all\_\-processes::Time.



Referenced by run().




\begin{DoxyCode}
{
  compute_global_quantities_of_system();

  if(ThisTask == 0)
    {
      fprintf(FdEnergy,
              "%g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g 
      %g %g %g %g %g %g\n",
              All.Time, SysState.EnergyInt, SysState.EnergyPot, SysState.
      EnergyKin, SysState.EnergyIntComp[0],
              SysState.EnergyPotComp[0], SysState.EnergyKinComp[0], SysState.
      EnergyIntComp[1],
              SysState.EnergyPotComp[1], SysState.EnergyKinComp[1], SysState.
      EnergyIntComp[2],
              SysState.EnergyPotComp[2], SysState.EnergyKinComp[2], SysState.
      EnergyIntComp[3],
              SysState.EnergyPotComp[3], SysState.EnergyKinComp[3], SysState.
      EnergyIntComp[4],
              SysState.EnergyPotComp[4], SysState.EnergyKinComp[4], SysState.
      EnergyIntComp[5],
              SysState.EnergyPotComp[5], SysState.EnergyKinComp[5], SysState.
      MassComp[0],
              SysState.MassComp[1], SysState.MassComp[2], SysState.MassComp[3], 
      SysState.MassComp[4],
              SysState.MassComp[5]);

      fflush(FdEnergy);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae903322da17c6875ab606b032b918099_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_ae903322da17c6875ab606b032b918099_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d}{
\index{proto.h@{proto.h}!every\_\-timestep\_\-stuff@{every\_\-timestep\_\-stuff}}
\index{every\_\-timestep\_\-stuff@{every\_\-timestep\_\-stuff}!proto.h@{proto.h}}
\subsubsection[{every\_\-timestep\_\-stuff}]{\setlength{\rightskip}{0pt plus 5cm}void every\_\-timestep\_\-stuff (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d}
This routine writes one line for every timestep to two log-\/files. In FdInfo, we just list the timesteps that have been done, while in FdCPU the cumulative cpu-\/time consumption in various parts of the code is stored. 

Definition at line 370 of file run.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-CommSum, global\_\-data\_\-all\_\-processes::CPU\_\-Domain, global\_\-data\_\-all\_\-processes::CPU\_\-EnsureNgb, global\_\-data\_\-all\_\-processes::CPU\_\-Gravity, global\_\-data\_\-all\_\-processes::CPU\_\-HydCommSumm, global\_\-data\_\-all\_\-processes::CPU\_\-HydCompWalk, global\_\-data\_\-all\_\-processes::CPU\_\-HydImbalance, global\_\-data\_\-all\_\-processes::CPU\_\-Hydro, global\_\-data\_\-all\_\-processes::CPU\_\-Imbalance, global\_\-data\_\-all\_\-processes::CPU\_\-Peano, global\_\-data\_\-all\_\-processes::CPU\_\-PM, global\_\-data\_\-all\_\-processes::CPU\_\-Potential, global\_\-data\_\-all\_\-processes::CPU\_\-Predict, global\_\-data\_\-all\_\-processes::CPU\_\-Snapshot, global\_\-data\_\-all\_\-processes::CPU\_\-TimeLine, global\_\-data\_\-all\_\-processes::CPU\_\-Total, global\_\-data\_\-all\_\-processes::CPU\_\-TreeConstruction, global\_\-data\_\-all\_\-processes::CPU\_\-TreeWalk, FdCPU, FdInfo, NTask, global\_\-data\_\-all\_\-processes::NumCurrentTiStep, set\_\-random\_\-numbers(), ThisTask, global\_\-data\_\-all\_\-processes::Time, and global\_\-data\_\-all\_\-processes::TimeStep.



Referenced by run().




\begin{DoxyCode}
{
  double z;

  if(ThisTask == 0)
    {
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      int i,j;
      if(All.ComovingIntegrationOn)
        {
          z = 1.0 / (All.Time) - 1;
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Redshift: %g, Systemstep: %
      g, Dloga: %g, NselfInteractions: %lu\n", 
                  All.NumCurrentTiStep, All.Time, z, All.TimeStep,
                  log(All.Time) - log(All.Time - All.TimeStep),  All.Nself_intera
      ctions);
          printf("\nBegin Step %d, Time: %g, Redshift: %g, Systemstep: %g, Dloga:
       %g, NselfInteractions: %lu\n", All.NumCurrentTiStep,
                 All.Time, z, All.TimeStep, log(All.Time) - log(All.Time - All.
      TimeStep), All.Nself_interactions);
          fflush(FdInfo);
        }
      else
        {
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Systemstep: %g, NselfIntera
      ctions: %lu\n", All.NumCurrentTiStep, All.Time,
                  All.TimeStep, All.Nself_interactions);
          printf("\nBegin Step %d, Time: %g, Systemstep: %g, NselfInteractions: %
      lu\n", All.NumCurrentTiStep, All.Time, All.TimeStep, All.Nself_interactions);
          fflush(FdInfo);
        }
      All.Nself_interactions = 0;
      for (i = 0; i < INTERACTION_TABLE_LENGTH; i++)
        for(j = 0; j < PARTICLE_MAX_INTERACTIONS; j++)
          InteractionTable[i][j] = 0;
#else       
      if(All.ComovingIntegrationOn)
        {
          z = 1.0 / (All.Time) - 1;
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Redshift: %g, Systemstep: %
      g, Dloga: %g\n",
                  All.NumCurrentTiStep, All.Time, z, All.TimeStep,
                  log(All.Time) - log(All.Time - All.TimeStep));
          printf("\nBegin Step %d, Time: %g, Redshift: %g, Systemstep: %g, Dloga:
       %g\n", All.NumCurrentTiStep,
                 All.Time, z, All.TimeStep, log(All.Time) - log(All.Time - All.
      TimeStep));
          fflush(FdInfo);
        }
      else
        {
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Systemstep: %g\n", All.
      NumCurrentTiStep, All.Time,
                  All.TimeStep);
          printf("\nBegin Step %d, Time: %g, Systemstep: %g\n", All.
      NumCurrentTiStep, All.Time, All.TimeStep);
          fflush(FdInfo);
        }
#endif
      fprintf(FdCPU, "Step %d, Time: %g, CPUs: %d\n", All.NumCurrentTiStep, All.
      Time, NTask);

      fprintf(FdCPU,
              "%10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10
      .2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f\n",
              All.CPU_Total, All.CPU_Gravity, All.CPU_Hydro, All.CPU_Domain, All.
      CPU_Potential,
              All.CPU_Predict, All.CPU_TimeLine, All.CPU_Snapshot, All.
      CPU_TreeWalk, All.CPU_TreeConstruction,
              All.CPU_CommSum, All.CPU_Imbalance, All.CPU_HydCompWalk, All.
      CPU_HydCommSumm,
              All.CPU_HydImbalance, All.CPU_EnsureNgb, All.CPU_PM, All.CPU_Peano)
      ;
      fflush(FdCPU);
    }

  set_random_numbers();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=356pt]{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad8b8e212e593e1795f6ba522239086fc}{
\index{proto.h@{proto.h}!ewald\_\-corr@{ewald\_\-corr}}
\index{ewald\_\-corr@{ewald\_\-corr}!proto.h@{proto.h}}
\subsubsection[{ewald\_\-corr}]{\setlength{\rightskip}{0pt plus 5cm}void ewald\_\-corr (
\begin{DoxyParamCaption}
\item[{double}]{ dx, }
\item[{double}]{ dy, }
\item[{double}]{ dz, }
\item[{double $\ast$}]{ fper}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad8b8e212e593e1795f6ba522239086fc}
This function looks up the correction force due to the infinite number of periodic particle/node images. We here use trilinear interpolation to get it from the precomputed tables, which contain one octant around the target particle at the origin. The other octants are obtained from it by exploiting the symmetry properties. 

Definition at line 3228 of file forcetree.c.



References EN, fac\_\-intp, fcorrx, fcorry, fcorrz, and NODE::u.



Referenced by force\_\-treeevaluate\_\-direct().




\begin{DoxyCode}
{
  int signx, signy, signz;
  int i, j, k;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;

  if(dx < 0)
    {
      dx = -dx;
      signx = +1;
    }
  else
    signx = -1;

  if(dy < 0)
    {
      dy = -dy;
      signy = +1;
    }
  else
    signy = -1;

  if(dz < 0)
    {
      dz = -dz;
      signz = +1;
    }
  else
    signz = -1;

  u = dx * fac_intp;
  i = (int) u;
  if(i >= EN)
    i = EN - 1;
  u -= i;
  v = dy * fac_intp;
  j = (int) v;
  if(j >= EN)
    j = EN - 1;
  v -= j;
  w = dz * fac_intp;
  k = (int) w;
  if(k >= EN)
    k = EN - 1;
  w -= k;

  f1 = (1 - u) * (1 - v) * (1 - w);
  f2 = (1 - u) * (1 - v) * (w);
  f3 = (1 - u) * (v) * (1 - w);
  f4 = (1 - u) * (v) * (w);
  f5 = (u) * (1 - v) * (1 - w);
  f6 = (u) * (1 - v) * (w);
  f7 = (u) * (v) * (1 - w);
  f8 = (u) * (v) * (w);

  fper[0] = signx * (fcorrx[i][j][k] * f1 +
                     fcorrx[i][j][k + 1] * f2 +
                     fcorrx[i][j + 1][k] * f3 +
                     fcorrx[i][j + 1][k + 1] * f4 +
                     fcorrx[i + 1][j][k] * f5 +
                     fcorrx[i + 1][j][k + 1] * f6 +
                     fcorrx[i + 1][j + 1][k] * f7 + fcorrx[i + 1][j + 1][k + 1] *
       f8);

  fper[1] = signy * (fcorry[i][j][k] * f1 +
                     fcorry[i][j][k + 1] * f2 +
                     fcorry[i][j + 1][k] * f3 +
                     fcorry[i][j + 1][k + 1] * f4 +
                     fcorry[i + 1][j][k] * f5 +
                     fcorry[i + 1][j][k + 1] * f6 +
                     fcorry[i + 1][j + 1][k] * f7 + fcorry[i + 1][j + 1][k + 1] *
       f8);

  fper[2] = signz * (fcorrz[i][j][k] * f1 +
                     fcorrz[i][j][k + 1] * f2 +
                     fcorrz[i][j + 1][k] * f3 +
                     fcorrz[i][j + 1][k + 1] * f4 +
                     fcorrz[i + 1][j][k] * f5 +
                     fcorrz[i + 1][j][k + 1] * f6 +
                     fcorrz[i + 1][j + 1][k] * f7 + fcorrz[i + 1][j + 1][k + 1] *
       f8);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad8b8e212e593e1795f6ba522239086fc_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0c4d2bd0695737095313d7dc47ce120c}{
\index{proto.h@{proto.h}!ewald\_\-force@{ewald\_\-force}}
\index{ewald\_\-force@{ewald\_\-force}!proto.h@{proto.h}}
\subsubsection[{ewald\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void ewald\_\-force (
\begin{DoxyParamCaption}
\item[{int}]{ iii, }
\item[{int}]{ jjj, }
\item[{int}]{ kkk, }
\item[{double}]{ x\mbox{[}3\mbox{]}, }
\item[{double}]{ force\mbox{[}3\mbox{]}}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0c4d2bd0695737095313d7dc47ce120c}
This function computes the force correction term (difference between full force of infinite lattice and nearest image) by Ewald summation. 

Definition at line 3411 of file forcetree.c.



Referenced by ewald\_\-init().




\begin{DoxyCode}
{
  double alpha, r2;
  double r, val, hdotx, dx[3];
  int i, h[3], n[3], h2;

  alpha = 2.0;

  for(i = 0; i < 3; i++)
    force[i] = 0;

  if(iii == 0 && jjj == 0 && kkk == 0)
    return;

  r2 = x[0] * x[0] + x[1] * x[1] + x[2] * x[2];

  for(i = 0; i < 3; i++)
    force[i] += x[i] / (r2 * sqrt(r2));

  for(n[0] = -4; n[0] <= 4; n[0]++)
    for(n[1] = -4; n[1] <= 4; n[1]++)
      for(n[2] = -4; n[2] <= 4; n[2]++)
        {
          for(i = 0; i < 3; i++)
            dx[i] = x[i] - n[i];

          r = sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);

          val = erfc(alpha * r) + 2 * alpha * r / sqrt(M_PI) * exp(-alpha * alpha
       * r * r);

          for(i = 0; i < 3; i++)
            force[i] -= dx[i] / (r * r * r) * val;
        }

  for(h[0] = -4; h[0] <= 4; h[0]++)
    for(h[1] = -4; h[1] <= 4; h[1]++)
      for(h[2] = -4; h[2] <= 4; h[2]++)
        {
          hdotx = x[0] * h[0] + x[1] * h[1] + x[2] * h[2];
          h2 = h[0] * h[0] + h[1] * h[1] + h[2] * h[2];

          if(h2 > 0)
            {
              val = 2.0 / ((double) h2) * exp(-M_PI * M_PI * h2 / (alpha * alpha)
      ) * sin(2 * M_PI * hdotx);

              for(i = 0; i < 3; i++)
                force[i] -= h[i] * val;
            }
        }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a0c4d2bd0695737095313d7dc47ce120c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6}{
\index{proto.h@{proto.h}!ewald\_\-init@{ewald\_\-init}}
\index{ewald\_\-init@{ewald\_\-init}!proto.h@{proto.h}}
\subsubsection[{ewald\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void ewald\_\-init (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6}
This function initializes tables with the correction force and the correction potential due to the periodic images of a point mass located at the origin. These corrections are obtained by Ewald summation. (See Hernquist, Bouchet, Suto, ApJS, 1991, 75, 231) The correction fields are used to obtain the full periodic force if periodic boundaries combined with the pure tree algorithm are used. For the TreePM algorithm, the Ewald correction is not used.

The correction fields are stored on disk once they are computed. If a corresponding file is found, they are loaded from disk to speed up the initialization. The Ewald summation is done in parallel, i.e. the processors share the work to compute the tables if needed. 

Definition at line 3079 of file forcetree.c.



References All, global\_\-data\_\-all\_\-processes::BoxSize, EN, ewald\_\-force(), ewald\_\-psi(), fac\_\-intp, fcorrx, fcorry, fcorrz, fd, FLOAT, NODE::len, my\_\-fread(), my\_\-fwrite(), NTask, potcorr, and ThisTask.



Referenced by begrun().




\begin{DoxyCode}
{
  int i, j, k, beg, len, size, n, task, count;
  double x[3], force[3];
  char buf[200];
  FILE *fd;

  if(ThisTask == 0)
    {
      printf("initialize Ewald correction...\n");
      fflush(stdout);
    }

#ifdef DOUBLEPRECISION
  sprintf(buf, "ewald_spc_table_%d_dbl.dat", EN);
#else
  sprintf(buf, "ewald_spc_table_%d.dat", EN);
#endif

  if((fd = fopen(buf, "r")))
    {
      if(ThisTask == 0)
        {
          printf("\nreading Ewald tables from file `%s'\n", buf);
          fflush(stdout);
        }

      my_fread(&fcorrx[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), f
      d);
      my_fread(&fcorry[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), f
      d);
      my_fread(&fcorrz[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), f
      d);
      my_fread(&potcorr[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1), 
      fd);
      fclose(fd);
    }
  else
    {
      if(ThisTask == 0)
        {
          printf("\nNo Ewald tables in file `%s' found.\nRecomputing them...\n", 
      buf);
          fflush(stdout);
        }

      /* ok, let's recompute things. Actually, we do that in parallel. */

      size = (EN + 1) * (EN + 1) * (EN + 1) / NTask;


      beg = ThisTask * size;
      len = size;
      if(ThisTask == (NTask - 1))
        len = (EN + 1) * (EN + 1) * (EN + 1) - beg;

      for(i = 0, count = 0; i <= EN; i++)
        for(j = 0; j <= EN; j++)
          for(k = 0; k <= EN; k++)
            {
              n = (i * (EN + 1) + j) * (EN + 1) + k;
              if(n >= beg && n < (beg + len))
                {
                  if(ThisTask == 0)
                    {
                      if((count % (len / 20)) == 0)
                        {
                          printf("%4.1f percent done\n", count / (len / 100.0));
                          fflush(stdout);
                        }
                    }

                  x[0] = 0.5 * ((double) i) / EN;
                  x[1] = 0.5 * ((double) j) / EN;
                  x[2] = 0.5 * ((double) k) / EN;

                  ewald_force(i, j, k, x, force);

                  fcorrx[i][j][k] = force[0];
                  fcorry[i][j][k] = force[1];
                  fcorrz[i][j][k] = force[2];

                  if(i + j + k == 0)
                    potcorr[i][j][k] = 2.8372975;
                  else
                    potcorr[i][j][k] = ewald_psi(x);

                  count++;
                }
            }

      for(task = 0; task < NTask; task++)
        {
          beg = task * size;
          len = size;
          if(task == (NTask - 1))
            len = (EN + 1) * (EN + 1) * (EN + 1) - beg;

#ifdef DOUBLEPRECISION
          MPI_Bcast(&fcorrx[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorry[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorrz[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&potcorr[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
#else
          MPI_Bcast(&fcorrx[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorry[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorrz[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&potcorr[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
#endif
        }

      if(ThisTask == 0)
        {
          printf("\nwriting Ewald tables to file `%s'\n", buf);
          fflush(stdout);

          if((fd = fopen(buf, "w")))
            {
              my_fwrite(&fcorrx[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              my_fwrite(&fcorry[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              my_fwrite(&fcorrz[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              my_fwrite(&potcorr[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (
      EN + 1), fd);
              fclose(fd);
            }
        }
    }

  fac_intp = 2 * EN / All.BoxSize;

  for(i = 0; i <= EN; i++)
    for(j = 0; j <= EN; j++)
      for(k = 0; k <= EN; k++)
        {
          potcorr[i][j][k] /= All.BoxSize;
          fcorrx[i][j][k] /= All.BoxSize * All.BoxSize;
          fcorry[i][j][k] /= All.BoxSize * All.BoxSize;
          fcorrz[i][j][k] /= All.BoxSize * All.BoxSize;
        }

  if(ThisTask == 0)
    {
      printf("initialization of periodic boundaries finished.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58}{
\index{proto.h@{proto.h}!ewald\_\-pot\_\-corr@{ewald\_\-pot\_\-corr}}
\index{ewald\_\-pot\_\-corr@{ewald\_\-pot\_\-corr}!proto.h@{proto.h}}
\subsubsection[{ewald\_\-pot\_\-corr}]{\setlength{\rightskip}{0pt plus 5cm}double ewald\_\-pot\_\-corr (
\begin{DoxyParamCaption}
\item[{double}]{ dx, }
\item[{double}]{ dy, }
\item[{double}]{ dz}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58}
This function looks up the correction potential due to the infinite number of periodic particle/node images. We here use tri-\/linear interpolation to get it from the precomputed table, which contains one octant around the target particle at the origin. The other octants are obtained from it by exploiting symmetry properties. 

Definition at line 3317 of file forcetree.c.



References EN, fac\_\-intp, potcorr, and NODE::u.



Referenced by force\_\-treeevaluate\_\-potential().




\begin{DoxyCode}
{
  int i, j, k;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;

  if(dx < 0)
    dx = -dx;

  if(dy < 0)
    dy = -dy;

  if(dz < 0)
    dz = -dz;

  u = dx * fac_intp;
  i = (int) u;
  if(i >= EN)
    i = EN - 1;
  u -= i;
  v = dy * fac_intp;
  j = (int) v;
  if(j >= EN)
    j = EN - 1;
  v -= j;
  w = dz * fac_intp;
  k = (int) w;
  if(k >= EN)
    k = EN - 1;
  w -= k;

  f1 = (1 - u) * (1 - v) * (1 - w);
  f2 = (1 - u) * (1 - v) * (w);
  f3 = (1 - u) * (v) * (1 - w);
  f4 = (1 - u) * (v) * (w);
  f5 = (u) * (1 - v) * (1 - w);
  f6 = (u) * (1 - v) * (w);
  f7 = (u) * (v) * (1 - w);
  f8 = (u) * (v) * (w);

  return potcorr[i][j][k] * f1 +
    potcorr[i][j][k + 1] * f2 +
    potcorr[i][j + 1][k] * f3 +
    potcorr[i][j + 1][k + 1] * f4 +
    potcorr[i + 1][j][k] * f5 +
    potcorr[i + 1][j][k + 1] * f6 + potcorr[i + 1][j + 1][k] * f7 + potcorr[i + 1
      ][j + 1][k + 1] * f8;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4a219224b239f0c20497e54ae421f134}{
\index{proto.h@{proto.h}!ewald\_\-psi@{ewald\_\-psi}}
\index{ewald\_\-psi@{ewald\_\-psi}!proto.h@{proto.h}}
\subsubsection[{ewald\_\-psi}]{\setlength{\rightskip}{0pt plus 5cm}double ewald\_\-psi (
\begin{DoxyParamCaption}
\item[{double}]{ x\mbox{[}3\mbox{]}}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a4a219224b239f0c20497e54ae421f134}
This function computes the potential correction term by means of Ewald summation. 

Definition at line 3370 of file forcetree.c.



Referenced by ewald\_\-init().




\begin{DoxyCode}
{
  double alpha, psi;
  double r, sum1, sum2, hdotx;
  double dx[3];
  int i, n[3], h[3], h2;

  alpha = 2.0;

  for(n[0] = -4, sum1 = 0; n[0] <= 4; n[0]++)
    for(n[1] = -4; n[1] <= 4; n[1]++)
      for(n[2] = -4; n[2] <= 4; n[2]++)
        {
          for(i = 0; i < 3; i++)
            dx[i] = x[i] - n[i];

          r = sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);
          sum1 += erfc(alpha * r) / r;
        }

  for(h[0] = -4, sum2 = 0; h[0] <= 4; h[0]++)
    for(h[1] = -4; h[1] <= 4; h[1]++)
      for(h[2] = -4; h[2] <= 4; h[2]++)
        {
          hdotx = x[0] * h[0] + x[1] * h[1] + x[2] * h[2];
          h2 = h[0] * h[0] + h[1] * h[1] + h[2] * h[2];
          if(h2 > 0)
            sum2 += 1 / (M_PI * h2) * exp(-M_PI * M_PI * h2 / (alpha * alpha)) * 
      cos(2 * M_PI * hdotx);
        }

  r = sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);

  psi = M_PI / (alpha * alpha) - sum1 - sum2 + 1 / r;

  return psi;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a4a219224b239f0c20497e54ae421f134_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a10281a87abe1e07d6ca603de6a533345}{
\index{proto.h@{proto.h}!fill\_\-Tab\_\-IO\_\-Labels@{fill\_\-Tab\_\-IO\_\-Labels}}
\index{fill\_\-Tab\_\-IO\_\-Labels@{fill\_\-Tab\_\-IO\_\-Labels}!proto.h@{proto.h}}
\subsubsection[{fill\_\-Tab\_\-IO\_\-Labels}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-Tab\_\-IO\_\-Labels (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a10281a87abe1e07d6ca603de6a533345}
This function associates a short 4-\/character block name with each block number. This is stored in front of each block for snapshot FileFormat=2. If one wants to add a new output-\/block, this function should be augmented accordingly. 

$<$ total number of defined 0 0 for snapshot files. Must be equal to the number of entries in \char`\"{}enum iofields\char`\"{} 



Definition at line 566 of file io.c.



References IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, IO\_\-VEL, and Tab\_\-IO\_\-Labels.



Referenced by read\_\-ic(), and savepositions().




\begin{DoxyCode}
{
  enum iofields i;

  for(i = 0; i < IO_NBLOCKS; i++)
    switch (i)
      {
      case IO_POS:
        strncpy(Tab_IO_Labels[IO_POS], "POS ", 4);
        break;
      case IO_VEL:
        strncpy(Tab_IO_Labels[IO_VEL], "VEL ", 4);
        break;
      case IO_ID:
        strncpy(Tab_IO_Labels[IO_ID], "ID  ", 4);
        break;
      case IO_MASS:
        strncpy(Tab_IO_Labels[IO_MASS], "MASS", 4);
        break;
      case IO_U:
        strncpy(Tab_IO_Labels[IO_U], "U   ", 4);
        break;
      case IO_RHO:
        strncpy(Tab_IO_Labels[IO_RHO], "RHO ", 4);
        break;
      case IO_HSML:
        strncpy(Tab_IO_Labels[IO_HSML], "HSML", 4);
        break;
      case IO_POT:
        strncpy(Tab_IO_Labels[IO_POT], "POT ", 4);
        break;
      case IO_ACCEL:
        strncpy(Tab_IO_Labels[IO_ACCEL], "ACCE", 4);
        break;
      case IO_DTENTR:
        strncpy(Tab_IO_Labels[IO_DTENTR], "ENDT", 4);
        break;
      case IO_TSTP:
        strncpy(Tab_IO_Labels[IO_TSTP], "TSTP", 4);
        break;
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a10281a87abe1e07d6ca603de6a533345_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aea8fa222a10c4796687c6ff25550cd74}{
\index{proto.h@{proto.h}!fill\_\-write\_\-buffer@{fill\_\-write\_\-buffer}}
\index{fill\_\-write\_\-buffer@{fill\_\-write\_\-buffer}!proto.h@{proto.h}}
\subsubsection[{fill\_\-write\_\-buffer}]{\setlength{\rightskip}{0pt plus 5cm}void fill\_\-write\_\-buffer (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr, }
\item[{int $\ast$}]{ startindex, }
\item[{int}]{ pc, }
\item[{int}]{ type}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aea8fa222a10c4796687c6ff25550cd74}
This function fills the write buffer with particle data. New output blocks can in principle be added here. 

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 



Definition at line 129 of file io.c.



References a3inv, All, global\_\-data\_\-all\_\-processes::BoxSize, boxSize, CommBuffer, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, sph\_\-particle\_\-data::Density, dmax(), sph\_\-particle\_\-data::DtEntropy, sph\_\-particle\_\-data::Entropy, fac1, fac2, FLOAT, GAMMA, GAMMA\_\-MINUS1, get\_\-gravkick\_\-factor(), get\_\-hydrokick\_\-factor(), particle\_\-data::GravAccel, sph\_\-particle\_\-data::Hsml, sph\_\-particle\_\-data::HydroAccel, particle\_\-data::ID, IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, IO\_\-VEL, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MinEgySpec, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-begstep, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, particle\_\-data::Pos, particle\_\-data::Potential, pow(), SphP, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, and particle\_\-data::Vel.



Referenced by write\_\-file().




\begin{DoxyCode}
{
  int n, k, pindex;
  float *fp;

#ifdef LONGIDS
  long long *ip;
#else
  int *ip;
#endif

#ifdef PERIODIC
  FLOAT boxSize;
#endif
#ifdef PMGRID
  double dt_gravkick_pm = 0;
#endif
  double dt_gravkick, dt_hydrokick, a3inv = 1, fac1, fac2;


  if(All.ComovingIntegrationOn)
    {
      a3inv = 1 / (All.Time * All.Time * All.Time);
      fac1 = 1 / (All.Time * All.Time);
      fac2 = 1 / pow(All.Time, 3 * GAMMA - 2);
    }
  else
    a3inv = fac1 = fac2 = 1;

#ifdef PMGRID
  if(All.ComovingIntegrationOn)
    dt_gravkick_pm =
      get_gravkick_factor(All.PM_Ti_begstep,
                          All.Ti_Current) -
      get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
  else
    dt_gravkick_pm = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep) / 
      2) * All.Timebase_interval;
#endif



  fp = CommBuffer;
  ip = CommBuffer;

  pindex = *startindex;

  switch (blocknr)
    {
    case IO_POS:                /* positions */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            for(k = 0; k < 3; k++)
              {
                fp[k] = P[pindex].Pos[k];
#ifdef PERIODIC
                boxSize = All.BoxSize;
#ifdef LONG_X
                if(k == 0)
                  boxSize = All.BoxSize * LONG_X;
#endif
#ifdef LONG_Y
                if(k == 1)
                  boxSize = All.BoxSize * LONG_Y;
#endif
#ifdef LONG_Z
                if(k == 2)
                  boxSize = All.BoxSize * LONG_Z;
#endif
                while(fp[k] < 0)
                  fp[k] += boxSize;
                while(fp[k] >= boxSize)
                  fp[k] -= boxSize;
#endif
              }
            n++;
            fp += 3;
          }
      break;

    case IO_VEL:                /* velocities */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            if(All.ComovingIntegrationOn)
              {
                dt_gravkick =
                  get_gravkick_factor(P[pindex].Ti_begstep,
                                      All.Ti_Current) -
                  get_gravkick_factor(P[pindex].Ti_begstep,
                                      (P[pindex].Ti_begstep + P[pindex].Ti_endste
      p) / 2);
                dt_hydrokick =
                  get_hydrokick_factor(P[pindex].Ti_begstep,
                                       All.Ti_Current) -
                  get_hydrokick_factor(P[pindex].Ti_begstep,
                                       (P[pindex].Ti_begstep + P[pindex].Ti_endst
      ep) / 2);
              }
            else
              dt_gravkick = dt_hydrokick =
                (All.Ti_Current - (P[pindex].Ti_begstep + P[pindex].Ti_endstep) /
       2) * All.Timebase_interval;

            for(k = 0; k < 3; k++)
              {
                fp[k] = P[pindex].Vel[k] + P[pindex].GravAccel[k] * dt_gravkick;
                if(P[pindex].Type == 0)
                  fp[k] += SphP[pindex].HydroAccel[k] * dt_hydrokick;
              }
#ifdef PMGRID
            for(k = 0; k < 3; k++)
              fp[k] += P[pindex].GravPM[k] * dt_gravkick_pm;
#endif
            for(k = 0; k < 3; k++)
              fp[k] *= sqrt(a3inv);

            n++;
            fp += 3;
          }
      break;

    case IO_ID:         /* particle ID */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *ip++ = P[pindex].ID;
            n++;
          }
      break;

    case IO_MASS:               /* particle mass */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = P[pindex].Mass;
            n++;
          }
      break;

    case IO_U:                  /* internal energy */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
#ifdef ISOTHERM_EQS
            *fp++ = SphP[pindex].Entropy;
#else
            *fp++ =
              dmax(All.MinEgySpec,
                   SphP[pindex].Entropy / GAMMA_MINUS1 * pow(SphP[pindex].Density
       * a3inv, GAMMA_MINUS1));
#endif
            n++;
          }
      break;

    case IO_RHO:                /* density */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = SphP[pindex].Density;
            n++;
          }
      break;

    case IO_HSML:               /* SPH smoothing length */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = SphP[pindex].Hsml;
            n++;
          }
      break;


    case IO_POT:                /* gravitational potential */
#ifdef OUTPUTPOTENTIAL
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = P[pindex].Potential;
            n++;
          }
#endif
      break;

    case IO_ACCEL:              /* acceleration */
#ifdef OUTPUTACCELERATION
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            for(k = 0; k < 3; k++)
              fp[k] = fac1 * P[pindex].GravAccel[k];
#ifdef PMGRID
            for(k = 0; k < 3; k++)
              fp[k] += fac1 * P[pindex].GravPM[k];
#endif
            if(P[pindex].Type == 0)
              for(k = 0; k < 3; k++)
                fp[k] += fac2 * SphP[pindex].HydroAccel[k];
            fp += 3;
            n++;
          }
#endif
      break;

    case IO_DTENTR:             /* rate of change of entropy */
#ifdef OUTPUTCHANGEOFENTROPY
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = SphP[pindex].DtEntropy;
            n++;
          }
#endif
      break;

    case IO_TSTP:               /* timestep  */
#ifdef OUTPUTTIMESTEP

      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = (P[pindex].Ti_endstep - P[pindex].Ti_begstep) * All.
      Timebase_interval;
            n++;
          }
#endif
      break;

    }

  *startindex = pindex;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_aea8fa222a10c4796687c6ff25550cd74_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aea8fa222a10c4796687c6ff25550cd74_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a78ed439b8a1cb93647a2b9de998d9269}{
\index{proto.h@{proto.h}!find\_\-dt\_\-displacement\_\-constraint@{find\_\-dt\_\-displacement\_\-constraint}}
\index{find\_\-dt\_\-displacement\_\-constraint@{find\_\-dt\_\-displacement\_\-constraint}!proto.h@{proto.h}}
\subsubsection[{find\_\-dt\_\-displacement\_\-constraint}]{\setlength{\rightskip}{0pt plus 5cm}void find\_\-dt\_\-displacement\_\-constraint (
\begin{DoxyParamCaption}
\item[{double}]{ hfac}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a78ed439b8a1cb93647a2b9de998d9269}
This function computes an upper limit ('dt\_\-displacement') to the global timestep of the system based on the rms velocities of particles. For cosmological simulations, the criterion used is that the rms displacement should be at most a fraction MaxRMSDisplacementFac of the mean particle separation. Note that the latter is estimated using the assigned particle masses, separately for each particle type. If comoving integration is not used, the function imposes no constraint on the timestep. 
\begin{DoxyParams}{Parameters}
\item[{\em hfac}]should be a$^\wedge$2$\ast$H(a) \end{DoxyParams}


Definition at line 566 of file timestep.c.



References All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, dt\_\-displacement, global\_\-data\_\-all\_\-processes::G, global\_\-data\_\-all\_\-processes::Hubble, global\_\-data\_\-all\_\-processes::MaxRMSDisplacementFac, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, NTask, NumPart, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaBaryon, P, pow(), ThisTask, global\_\-data\_\-all\_\-processes::Time, and particle\_\-data::Type.



Referenced by advance\_\-and\_\-find\_\-timesteps().




\begin{DoxyCode}
{
  int i, j, type, *temp;
  int count[6];
  long long count_sum[6];
  double v[6], v_sum[6], mim[6], min_mass[6];
  double dt, dmean, asmth = 0;

  dt_displacement = All.MaxSizeTimestep;

  if(All.ComovingIntegrationOn)
    {
      for(type = 0; type < 6; type++)
        {
          count[type] = 0;
          v[type] = 0;
          mim[type] = 1.0e30;
        }

      for(i = 0; i < NumPart; i++)
        {
          v[P[i].Type] += P[i].Vel[0] * P[i].Vel[0] + P[i].Vel[1] * P[i].Vel[1] +
       P[i].Vel[2] * P[i].Vel[2];
          if(mim[P[i].Type] > P[i].Mass)
            mim[P[i].Type] = P[i].Mass;
          count[P[i].Type]++;
        }

      MPI_Allreduce(v, v_sum, 6, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
      MPI_Allreduce(mim, min_mass, 6, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

      temp = malloc(NTask * 6 * sizeof(int));
      MPI_Allgather(count, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
      for(i = 0; i < 6; i++)
        {
          count_sum[i] = 0;
          for(j = 0; j < NTask; j++)
            count_sum[i] += temp[j * 6 + i];
        }
      free(temp);

      for(type = 0; type < 6; type++)
        {
          if(count_sum[type] > 0)
            {
              if(type == 0)
                dmean =
                  pow(min_mass[type] / (All.OmegaBaryon * 3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G)),
                      1.0 / 3);
              else
                dmean =
                  pow(min_mass[type] /
                      ((All.Omega0 - All.OmegaBaryon) * 3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G)),
                      1.0 / 3);

              dt = All.MaxRMSDisplacementFac * hfac * dmean / sqrt(v_sum[type] / 
      count_sum[type]);

#ifdef PMGRID
              asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
              if(((1 << type) & (PLACEHIGHRESREGION)))
                asmth = All.Asmth[1];
#endif
              if(asmth < dmean)
                dt = All.MaxRMSDisplacementFac * hfac * asmth / sqrt(v_sum[type] 
      / count_sum[type]);
#endif

              if(ThisTask == 0)
                printf("type=%d  dmean=%g asmth=%g minmass=%g a=%g  sqrt(<p^2>)=%
      g  dlogmax=%g\n",
                       type, dmean, asmth, min_mass[type], All.Time, sqrt(v_sum[t
      ype] / count_sum[type]), dt);

              if(dt < dt_displacement)
                dt_displacement = dt;
            }
        }

      if(ThisTask == 0)
        printf("displacement time constraint: %g  (%g)\n", dt_displacement, All.
      MaxSizeTimestep);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_a78ed439b8a1cb93647a2b9de998d9269_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a78ed439b8a1cb93647a2b9de998d9269_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac028b474d53a40e79377b7ae5dde636a}{
\index{proto.h@{proto.h}!find\_\-files@{find\_\-files}}
\index{find\_\-files@{find\_\-files}!proto.h@{proto.h}}
\subsubsection[{find\_\-files}]{\setlength{\rightskip}{0pt plus 5cm}int find\_\-files (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ac028b474d53a40e79377b7ae5dde636a}
This function determines onto how many files a given snapshot is distributed. 

Definition at line 615 of file read\_\-ic.c.



References All, endrun(), fd, header, global\_\-data\_\-all\_\-processes::ICFormat, io\_\-header::num\_\-files, read\_\-header\_\-attributes\_\-in\_\-hdf5(), and ThisTask.



Referenced by read\_\-ic().




\begin{DoxyCode}
{
  FILE *fd;
  char buf[200], buf1[200];
  int dummy;

  sprintf(buf, "%s.%d", fname, 0);
  sprintf(buf1, "%s", fname);

  if(All.ICFormat == 3)
    {
      sprintf(buf, "%s.%d.hdf5", fname, 0);
      sprintf(buf1, "%s.hdf5", fname);
    }

#ifndef  HAVE_HDF5
  if(All.ICFormat == 3)
    {
      if(ThisTask == 0)
        printf("Code wasn't compiled with HDF5 support enabled!\n");
      endrun(0);
    }
#endif

  header.num_files = 0;

  if(ThisTask == 0)
    {
      if((fd = fopen(buf, "r")))
        {
          if(All.ICFormat == 1 || All.ICFormat == 2)
            {
              if(All.ICFormat == 2)
                {
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                }

              fread(&dummy, sizeof(dummy), 1, fd);
              fread(&header, sizeof(header), 1, fd);
              fread(&dummy, sizeof(dummy), 1, fd);
            }
          fclose(fd);

#ifdef HAVE_HDF5
          if(All.ICFormat == 3)
            read_header_attributes_in_hdf5(buf);
#endif
        }
    }

  MPI_Bcast(&header, sizeof(header), MPI_BYTE, 0, MPI_COMM_WORLD);

  if(header.num_files > 0)
    return header.num_files;

  if(ThisTask == 0)
    {
      if((fd = fopen(buf1, "r")))
        {
          if(All.ICFormat == 1 || All.ICFormat == 2)
            {
              if(All.ICFormat == 2)
                {
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                }

              fread(&dummy, sizeof(dummy), 1, fd);
              fread(&header, sizeof(header), 1, fd);
              fread(&dummy, sizeof(dummy), 1, fd);
            }
          fclose(fd);

#ifdef HAVE_HDF5
          if(All.ICFormat == 3)
            read_header_attributes_in_hdf5(buf1);
#endif
          header.num_files = 1;
        }
    }

  MPI_Bcast(&header, sizeof(header), MPI_BYTE, 0, MPI_COMM_WORLD);

  if(header.num_files > 0)
    return header.num_files;

  if(ThisTask == 0)
    {
      printf("\nCan't find initial conditions file.");
      printf("neither as '%s'\nnor as '%s'\n", buf, buf1);
      fflush(stdout);
    }

  endrun(0);
  return 0;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac028b474d53a40e79377b7ae5dde636a_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac028b474d53a40e79377b7ae5dde636a_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a532b4637166ab194c1b1d0dee9f003f2}{
\index{proto.h@{proto.h}!find\_\-next\_\-outputtime@{find\_\-next\_\-outputtime}}
\index{find\_\-next\_\-outputtime@{find\_\-next\_\-outputtime}!proto.h@{proto.h}}
\subsubsection[{find\_\-next\_\-outputtime}]{\setlength{\rightskip}{0pt plus 5cm}int find\_\-next\_\-outputtime (
\begin{DoxyParamCaption}
\item[{int}]{ ti\_\-curr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a532b4637166ab194c1b1d0dee9f003f2}
this function returns the next output time that is equal or larger to ti\_\-curr 

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 



Definition at line 244 of file run.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, endrun(), global\_\-data\_\-all\_\-processes::OutputListLength, global\_\-data\_\-all\_\-processes::OutputListOn, global\_\-data\_\-all\_\-processes::OutputListTimes, ThisTask, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, global\_\-data\_\-all\_\-processes::TimeBegin, global\_\-data\_\-all\_\-processes::TimeBetSnapshot, global\_\-data\_\-all\_\-processes::TimeMax, and global\_\-data\_\-all\_\-processes::TimeOfFirstSnapshot.



Referenced by begrun(), and find\_\-next\_\-sync\_\-point\_\-and\_\-drift().




\begin{DoxyCode}
{
  int i, ti, ti_next, iter = 0;
  double next, time;

  ti_next = -1;

  if(All.OutputListOn)
    {
      for(i = 0; i < All.OutputListLength; i++)
        {
          time = All.OutputListTimes[i];

          if(time >= All.TimeBegin && time <= All.TimeMax)
            {
              if(All.ComovingIntegrationOn)
                ti = log(time / All.TimeBegin) / All.Timebase_interval;
              else
                ti = (time - All.TimeBegin) / All.Timebase_interval;

              if(ti >= ti_curr)
                {
                  if(ti_next == -1)
                    ti_next = ti;

                  if(ti_next > ti)
                    ti_next = ti;
                }
            }
        }
    }
  else
    {
      if(All.ComovingIntegrationOn)
        {
          if(All.TimeBetSnapshot <= 1.0)
            {
              printf("TimeBetSnapshot > 1.0 required for your simulation.\n");
              endrun(13123);
            }
        }
      else
        {
          if(All.TimeBetSnapshot <= 0.0)
            {
              printf("TimeBetSnapshot > 0.0 required for your simulation.\n");
              endrun(13123);
            }
        }

      time = All.TimeOfFirstSnapshot;

      iter = 0;

      while(time < All.TimeBegin)
        {
          if(All.ComovingIntegrationOn)
            time *= All.TimeBetSnapshot;
          else
            time += All.TimeBetSnapshot;

          iter++;

          if(iter > 1000000)
            {
              printf("Can't determine next output time.\n");
              endrun(110);
            }
        }

      while(time <= All.TimeMax)
        {
          if(All.ComovingIntegrationOn)
            ti = log(time / All.TimeBegin) / All.Timebase_interval;
          else
            ti = (time - All.TimeBegin) / All.Timebase_interval;

          if(ti >= ti_curr)
            {
              ti_next = ti;
              break;
            }

          if(All.ComovingIntegrationOn)
            time *= All.TimeBetSnapshot;
          else
            time += All.TimeBetSnapshot;

          iter++;

          if(iter > 1000000)
            {
              printf("Can't determine next output time.\n");
              endrun(111);
            }
        }
    }

  if(ti_next == -1)
    {
      ti_next = 2 * TIMEBASE;   /* this will prevent any further output */

      if(ThisTask == 0)
        printf("\nThere is no valid time for a further snapshot file.\n");
    }
  else
    {
      if(All.ComovingIntegrationOn)
        next = All.TimeBegin * exp(ti_next * All.Timebase_interval);
      else
        next = All.TimeBegin + ti_next * All.Timebase_interval;

      if(ThisTask == 0)
        printf("\nSetting next time for snapshot file to Time_next= %g\n\n", next
      );
    }

  return ti_next;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a532b4637166ab194c1b1d0dee9f003f2_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a532b4637166ab194c1b1d0dee9f003f2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad52604af910b3e1677718d863ab09391}{
\index{proto.h@{proto.h}!find\_\-next\_\-sync\_\-point\_\-and\_\-drift@{find\_\-next\_\-sync\_\-point\_\-and\_\-drift}}
\index{find\_\-next\_\-sync\_\-point\_\-and\_\-drift@{find\_\-next\_\-sync\_\-point\_\-and\_\-drift}!proto.h@{proto.h}}
\subsubsection[{find\_\-next\_\-sync\_\-point\_\-and\_\-drift}]{\setlength{\rightskip}{0pt plus 5cm}void find\_\-next\_\-sync\_\-point\_\-and\_\-drift (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad52604af910b3e1677718d863ab09391}
This function finds the next synchronization point of the system (i.e. the earliest point of time any of the particles needs a force computation), and drifts the system to this point of time. If the system drifts over the desired time of a snapshot file, the function will drift to this moment, generate an output, and then resume the drift. 

Definition at line 151 of file run.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, compute\_\-potential(), global\_\-data\_\-all\_\-processes::CPU\_\-Predict, domain\_\-Decomposition(), find\_\-next\_\-outputtime(), Flag\_\-FullStep, move\_\-particles(), NTask, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumForceUpdate, NumPart, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, savepositions(), second(), global\_\-data\_\-all\_\-processes::SnapshotFileCount, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Ti\_\-nextoutput, global\_\-data\_\-all\_\-processes::Time, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, global\_\-data\_\-all\_\-processes::TimeBegin, timediff(), global\_\-data\_\-all\_\-processes::TimeStep, global\_\-data\_\-all\_\-processes::TotNumPart, and global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency.



Referenced by run().




\begin{DoxyCode}
{
  int n, min, min_glob, flag, *temp;
  double timeold;
  double t0, t1;

  t0 = second();

  timeold = All.Time;

  for(n = 1, min = P[0].Ti_endstep; n < NumPart; n++)
    if(min > P[n].Ti_endstep)
      min = P[n].Ti_endstep;

  MPI_Allreduce(&min, &min_glob, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);

  /* We check whether this is a full step where all particles are synchronized */
      
  flag = 1;
  for(n = 0; n < NumPart; n++)
    if(P[n].Ti_endstep > min_glob)
      flag = 0;

  MPI_Allreduce(&flag, &Flag_FullStep, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);

#ifdef PMGRID
  if(min_glob >= All.PM_Ti_endstep)
    {
      min_glob = All.PM_Ti_endstep;
      Flag_FullStep = 1;
    }
#endif

  /* Determine 'NumForceUpdate', i.e. the number of particles on this processor t
      hat are going to be active */
  for(n = 0, NumForceUpdate = 0; n < NumPart; n++)
    {
      if(P[n].Ti_endstep == min_glob)
#ifdef SELECTIVE_NO_GRAVITY
        if(!((1 << P[n].Type) & (SELECTIVE_NO_GRAVITY)))
#endif
          NumForceUpdate++;
    }

  /* note: NumForcesSinceLastDomainDecomp has type "long long" */
  temp = malloc(NTask * sizeof(int));
  MPI_Allgather(&NumForceUpdate, 1, MPI_INT, temp, 1, MPI_INT, MPI_COMM_WORLD);
  for(n = 0; n < NTask; n++)
    All.NumForcesSinceLastDomainDecomp += temp[n];
  free(temp);



  t1 = second();

  All.CPU_Predict += timediff(t0, t1);

  while(min_glob >= All.Ti_nextoutput && All.Ti_nextoutput >= 0)
    {
      move_particles(All.Ti_Current, All.Ti_nextoutput);

      All.Ti_Current = All.Ti_nextoutput;

      if(All.ComovingIntegrationOn)
        All.Time = All.TimeBegin * exp(All.Ti_Current * All.Timebase_interval);
      else
        All.Time = All.TimeBegin + All.Ti_Current * All.Timebase_interval;

#ifdef OUTPUTPOTENTIAL
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
      domain_Decomposition();
      compute_potential();
#endif
      savepositions(All.SnapshotFileCount++);   /* write snapshot file */

      All.Ti_nextoutput = find_next_outputtime(All.Ti_nextoutput + 1);
    }

  move_particles(All.Ti_Current, min_glob);

  All.Ti_Current = min_glob;

  if(All.ComovingIntegrationOn)
    All.Time = All.TimeBegin * exp(All.Ti_Current * All.Timebase_interval);
  else
    All.Time = All.TimeBegin + All.Ti_Current * All.Timebase_interval;

  All.TimeStep = All.Time - timeold;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad52604af910b3e1677718d863ab09391_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=390pt]{proto_8h_ad52604af910b3e1677718d863ab09391_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8eaedfa5c6d72bca79b465003679ed89}{
\index{proto.h@{proto.h}!force\_\-create\_\-empty\_\-nodes@{force\_\-create\_\-empty\_\-nodes}}
\index{force\_\-create\_\-empty\_\-nodes@{force\_\-create\_\-empty\_\-nodes}!proto.h@{proto.h}}
\subsubsection[{force\_\-create\_\-empty\_\-nodes}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-create\_\-empty\_\-nodes (
\begin{DoxyParamCaption}
\item[{int}]{ no, }
\item[{int}]{ topnode, }
\item[{int}]{ bits, }
\item[{int}]{ x, }
\item[{int}]{ y, }
\item[{int}]{ z, }
\item[{int $\ast$}]{ nodecount, }
\item[{int $\ast$}]{ nextfree}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a8eaedfa5c6d72bca79b465003679ed89}
This function recursively creates a set of empty tree nodes which corresponds to the top-\/level tree for the domain grid. This is done to ensure that this top-\/level tree is always \char`\"{}complete\char`\"{} so that we can easily associate the pseudo-\/particles of other CPUs with tree-\/nodes at a given level in the tree, even when the particle population is so sparse that some of these nodes are actually empty. 

Definition at line 292 of file forcetree.c.



References NODE::center, topnode\_\-data::Daughter, DomainNodeIndex, dump\_\-particles(), endrun(), force\_\-create\_\-empty\_\-nodes(), topnode\_\-data::Leaf, NODE::len, MaxNodes, Nodes, peano\_\-hilbert\_\-key(), NODE::suns, ThisTask, TopNodes, and NODE::u.



Referenced by force\_\-create\_\-empty\_\-nodes(), and force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  int i, j, k, n, sub, count;

  if(TopNodes[topnode].Daughter >= 0)
    {
      for(i = 0; i < 2; i++)
        for(j = 0; j < 2; j++)
          for(k = 0; k < 2; k++)
            {
              sub = 7 & peano_hilbert_key((x << 1) + i, (y << 1) + j, (z << 1) + 
      k, bits);

              count = i + 2 * j + 4 * k;

              Nodes[no].u.suns[count] = *nextfree;


              Nodes[*nextfree].len = 0.5 * Nodes[no].len;
              Nodes[*nextfree].center[0] = Nodes[no].center[0] + (2 * i - 1) * 0.
      25 * Nodes[no].len;
              Nodes[*nextfree].center[1] = Nodes[no].center[1] + (2 * j - 1) * 0.
      25 * Nodes[no].len;
              Nodes[*nextfree].center[2] = Nodes[no].center[2] + (2 * k - 1) * 0.
      25 * Nodes[no].len;

              for(n = 0; n < 8; n++)
                Nodes[*nextfree].u.suns[n] = -1;

              if(TopNodes[TopNodes[topnode].Daughter + sub].Daughter == -1)
                DomainNodeIndex[TopNodes[TopNodes[topnode].Daughter + sub].Leaf] 
      = *nextfree;

              *nextfree = *nextfree + 1;
              *nodecount = *nodecount + 1;

              if((*nodecount) >= MaxNodes)
                {
                  printf("task %d: maximum number %d of tree-nodes reached.\n", 
      ThisTask, MaxNodes);
                  printf("in create empty nodes\n");
                  dump_particles();
                  endrun(11);
                }

              force_create_empty_nodes(*nextfree - 1, TopNodes[topnode].Daughter 
      + sub,
                                       bits + 1, 2 * x + i, 2 * y + j, 2 * z + k,
       nodecount, nextfree);
            }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a8eaedfa5c6d72bca79b465003679ed89_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a8eaedfa5c6d72bca79b465003679ed89_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb}{
\index{proto.h@{proto.h}!force\_\-exchange\_\-pseudodata@{force\_\-exchange\_\-pseudodata}}
\index{force\_\-exchange\_\-pseudodata@{force\_\-exchange\_\-pseudodata}!proto.h@{proto.h}}
\subsubsection[{force\_\-exchange\_\-pseudodata}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-exchange\_\-pseudodata (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb}
This function communicates the values of the multipole moments of the top-\/level tree-\/nodes of the domain grid. This data can then be used to update the pseudo-\/particles on each CPU accordingly. 

Definition at line 684 of file forcetree.c.



References NODE::d, DomainEndList, DomainMoment, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, Extnodes, DomainNODE::mass, Nodes, NTask, PTask, DomainNODE::s, TAG\_\-DMOM, ThisTask, NODE::u, extNODE::vs, and DomainNODE::vs.



Referenced by force\_\-update\_\-pseudoparticles().




\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      /* read out the multipole moments from the local base cells */
      DomainMoment[i].s[0] = Nodes[no].u.d.s[0];
      DomainMoment[i].s[1] = Nodes[no].u.d.s[1];
      DomainMoment[i].s[2] = Nodes[no].u.d.s[2];
      DomainMoment[i].vs[0] = Extnodes[no].vs[0];
      DomainMoment[i].vs[1] = Extnodes[no].vs[1];
      DomainMoment[i].vs[2] = Extnodes[no].vs[2];
      DomainMoment[i].mass = Nodes[no].u.d.mass;
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      DomainMoment[i].bitflags = Nodes[no].u.d.bitflags;
#else
      DomainMoment[i].maxsoft = Nodes[no].maxsoft;
#endif
#endif
    }

  /* share the pseudo-particle data accross CPUs */

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainMoment[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) * 
      sizeof(struct DomainNODE),
                     MPI_BYTE, recvTask, TAG_DMOM,
                     &DomainMoment[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) * 
      sizeof(struct DomainNODE),
                     MPI_BYTE, recvTask, TAG_DMOM, MPI_COMM_WORLD, &status);
    }

}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a947a734f3bbba14d4092c7480880d3c7}{
\index{proto.h@{proto.h}!force\_\-flag\_\-localnodes@{force\_\-flag\_\-localnodes}}
\index{force\_\-flag\_\-localnodes@{force\_\-flag\_\-localnodes}!proto.h@{proto.h}}
\subsubsection[{force\_\-flag\_\-localnodes}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-flag\_\-localnodes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a947a734f3bbba14d4092c7480880d3c7}
This function flags nodes in the top-\/level tree that are dependent on local particle data. 

Definition at line 834 of file forcetree.c.



References NODE::d, DomainMyLast, DomainMyStart, DomainNodeIndex, Nodes, NTopleaves, and NODE::u.



Referenced by force\_\-treebuild().




\begin{DoxyCode}
{
  int no, i;

  /* mark all top-level nodes */

  for(i = 0; i < NTopleaves; i++)
    {
      no = DomainNodeIndex[i];

      while(no >= 0)
        {
          if((Nodes[no].u.d.bitflags & 1))
            break;

          Nodes[no].u.d.bitflags |= 1;

          no = Nodes[no].u.d.father;
        }
    }

  /* mark top-level nodes that contain local particles */

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      /*
         if(DomainMoment[i].mass > 0)
       */
      {
        no = DomainNodeIndex[i];

        while(no >= 0)
          {
            if((Nodes[no].u.d.bitflags & 2))
              break;

            Nodes[no].u.d.bitflags |= 2;

            no = Nodes[no].u.d.father;
          }
      }
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a947a734f3bbba14d4092c7480880d3c7_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad9e0a57b7577d64a315c142e197d292d}{
\index{proto.h@{proto.h}!force\_\-insert\_\-pseudo\_\-particles@{force\_\-insert\_\-pseudo\_\-particles}}
\index{force\_\-insert\_\-pseudo\_\-particles@{force\_\-insert\_\-pseudo\_\-particles}!proto.h@{proto.h}}
\subsubsection[{force\_\-insert\_\-pseudo\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-insert\_\-pseudo\_\-particles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad9e0a57b7577d64a315c142e197d292d}
this function inserts pseudo-\/particles which will represent the mass distribution of the other CPUs. Initially, the mass of the pseudo-\/particles is set to zero, and their coordinate is set to the center of the domain-\/cell they correspond to. These quantities will be updated later on. 

Definition at line 346 of file forcetree.c.



References All, NODE::center, DomainMoment, DomainMyLast, DomainNodeIndex, endrun(), DomainNODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nodes, NTopleaves, NODE::s, DomainNODE::s, NODE::suns, and NODE::u.



Referenced by force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  int i, index, subnode, nn, th;

  for(i = 0; i < NTopleaves; i++)
    {
      index = DomainNodeIndex[i];

      DomainMoment[i].mass = 0;
      DomainMoment[i].s[0] = Nodes[index].center[0];
      DomainMoment[i].s[1] = Nodes[index].center[1];
      DomainMoment[i].s[2] = Nodes[index].center[2];
    }

  for(i = 0; i < NTopleaves; i++)
    {
      if(i < DomainMyStart || i > DomainMyLast)
        {
          th = All.MaxPart;     /* select index of first node in tree */

          while(1)
            {
              if(th >= All.MaxPart)     /* we are dealing with an internal node *
      /
                {
                  if(th >= All.MaxPart + MaxNodes)
                    endrun(888);        /* this can't be */

                  subnode = 0;
                  if(DomainMoment[i].s[0] > Nodes[th].center[0])
                    subnode += 1;
                  if(DomainMoment[i].s[1] > Nodes[th].center[1])
                    subnode += 2;
                  if(DomainMoment[i].s[2] > Nodes[th].center[2])
                    subnode += 4;

                  nn = Nodes[th].u.suns[subnode];

                  if(nn >= 0)   /* ok, something is in the daughter slot already,
       need to continue */
                    {
                      th = nn;
                    }
                  else
                    {
                      /* here we have found an empty slot where we can 
                       * attach the pseudo particle as a leaf 
                       */
                      Nodes[th].u.suns[subnode] = All.MaxPart + MaxNodes + i;

                      break;    /* done for this pseudo particle */
                    }
                }
              else
                {
                  endrun(889);  /* this can't be */
                }
            }
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad9e0a57b7577d64a315c142e197d292d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad9e0a57b7577d64a315c142e197d292d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae809fba68f599de9874f593b77d0bbfd}{
\index{proto.h@{proto.h}!force\_\-setupnonrecursive@{force\_\-setupnonrecursive}}
\index{force\_\-setupnonrecursive@{force\_\-setupnonrecursive}!proto.h@{proto.h}}
\subsubsection[{force\_\-setupnonrecursive}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-setupnonrecursive (
\begin{DoxyParamCaption}
\item[{int}]{ no}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ae809fba68f599de9874f593b77d0bbfd}
\hypertarget{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2}{
\index{proto.h@{proto.h}!force\_\-treeallocate@{force\_\-treeallocate}}
\index{force\_\-treeallocate@{force\_\-treeallocate}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeallocate}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeallocate (
\begin{DoxyParamCaption}
\item[{int}]{ maxnodes, }
\item[{int}]{ maxpart}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2}
This function allocates the memory used for storage of the tree and of auxiliary arrays needed for tree-\/walk and link-\/lists. Usually, maxnodes approximately equal to 0.7$\ast$maxpart is sufficient to store the tree for up to maxpart particles. 

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition 



Definition at line 2827 of file forcetree.c.



References All, endrun(), Extnodes, Extnodes\_\-base, Father, first\_\-flag, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, MAXTOPNODES, Nextnode, Nodes, Nodes\_\-base, NTAB, shortrange\_\-table, shortrange\_\-table\_\-potential, tabfac, ThisTask, and NODE::u.



Referenced by init(), pmforce\_\-periodic(), pmpotential\_\-periodic(), and restart().




\begin{DoxyCode}
{
  int i;
  size_t bytes;
  double allbytes = 0;
  double u;

  MaxNodes = maxnodes;

  if(!(Nodes_base = malloc(bytes = (MaxNodes + 1) * sizeof(struct NODE))))
    {
      printf("failed to allocate memory for %d tree-nodes (%g MB).\n", MaxNodes, 
      bytes / (1024.0 * 1024.0));
      endrun(3);
    }
  allbytes += bytes;

  if(!(Extnodes_base = malloc(bytes = (MaxNodes + 1) * sizeof(struct extNODE))))
    {
      printf("failed to allocate memory for %d tree-extnodes (%g MB).\n", 
      MaxNodes,
             bytes / (1024.0 * 1024.0));
      endrun(3);
    }
  allbytes += bytes;

  Nodes = Nodes_base - All.MaxPart;
  Extnodes = Extnodes_base - All.MaxPart;

  if(!(Nextnode = malloc(bytes = (maxpart + MAXTOPNODES) * sizeof(int))))
    {
      printf("Failed to allocate %d spaces for 'Nextnode' array (%g MB)\n", maxpa
      rt + MAXTOPNODES,
             bytes / (1024.0 * 1024.0));
      exit(0);
    }
  allbytes += bytes;

  if(!(Father = malloc(bytes = (maxpart) * sizeof(int))))
    {
      printf("Failed to allocate %d spaces for 'Father' array (%g MB)\n", maxpart
      , bytes / (1024.0 * 1024.0));
      exit(0);
    }
  allbytes += bytes;

  if(first_flag == 0)
    {
      first_flag = 1;

      if(ThisTask == 0)
        printf("\nAllocated %g MByte for BH-tree. %lu\n\n", allbytes / (1024.0 * 
      1024.0),
               sizeof(struct NODE) + sizeof(struct extNODE));

      tabfac = NTAB / 3.0;

      for(i = 0; i < NTAB; i++)
        {
          u = 3.0 / NTAB * (i + 0.5);
          shortrange_table[i] = erfc(u) + 2.0 * u / sqrt(M_PI) * exp(-u * u);
          shortrange_table_potential[i] = erfc(u);
        }
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a10f92098e86f82baec9f84a283f4c9e5}{
\index{proto.h@{proto.h}!force\_\-treebuild@{force\_\-treebuild}}
\index{force\_\-treebuild@{force\_\-treebuild}!proto.h@{proto.h}}
\subsubsection[{force\_\-treebuild}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treebuild (
\begin{DoxyParamCaption}
\item[{int}]{ npart}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a10f92098e86f82baec9f84a283f4c9e5}
This function is a driver routine for constructing the gravitational oct-\/tree, which is done by calling a small number of other functions. 

Definition at line 61 of file forcetree.c.



References All, force\_\-flag\_\-localnodes(), force\_\-treebuild\_\-single(), force\_\-update\_\-pseudoparticles(), Numnodestree, global\_\-data\_\-all\_\-processes::Time, and TimeOfLastTreeConstruction.



Referenced by compute\_\-potential(), gravity\_\-tree(), and ngb\_\-treebuild().




\begin{DoxyCode}
{
  Numnodestree = force_treebuild_single(npart);

  force_update_pseudoparticles();

  force_flag_localnodes();

  TimeOfLastTreeConstruction = All.Time;

  return Numnodestree;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a10f92098e86f82baec9f84a283f4c9e5_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a10f92098e86f82baec9f84a283f4c9e5_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6}{
\index{proto.h@{proto.h}!force\_\-treebuild\_\-single@{force\_\-treebuild\_\-single}}
\index{force\_\-treebuild\_\-single@{force\_\-treebuild\_\-single}!proto.h@{proto.h}}
\subsubsection[{force\_\-treebuild\_\-single}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treebuild\_\-single (
\begin{DoxyParamCaption}
\item[{int}]{ npart}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6}
Constructs the gravitational oct-\/tree.

The index convention for accessing tree nodes is the following: the indices 0...NumPart-\/1 reference single particles, the indices All.MaxPart.... All.MaxPart+nodes-\/1 reference tree nodes. `Nodes\_\-base' points to the first tree node, while `nodes' is shifted such that nodes\mbox{[}All.MaxPart\mbox{]} gives the first tree node. Finally, node indices with values 'All.MaxPart + MaxNodes' and larger indicate \char`\"{}pseudo
  particles\char`\"{}, i.e. multipole moments of top-\/level nodes that lie on different CPUs. If such a node needs to be opened, the corresponding particle must be exported to that CPU. The 'Extnodes' structure parallels that of 'Nodes'. Its information is only needed for the SPH part of the computation. (The data is split onto these two structures as a tuning measure. If it is merged into 'Nodes' a somewhat bigger size of the nodes also for gravity would result, which would reduce cache utilization slightly. 

$<$ Bits per dimension available for Peano-\/Hilbert order. Note: If peanokey is defined 0 0 int, the allowed maximum is 10. If 64-\/bit integers are used, the maximum is 21 



Definition at line 93 of file forcetree.c.



References All, BITS\_\-PER\_\-DIMENSION, NODE::center, NODE::d, topnode\_\-data::Daughter, DomainCenter, DomainCorner, DomainFac, DomainLen, DomainNodeIndex, dump\_\-particles(), endrun(), force\_\-create\_\-empty\_\-nodes(), force\_\-insert\_\-pseudo\_\-particles(), force\_\-update\_\-node\_\-recursive(), global\_\-data\_\-all\_\-processes::ForceSoftening, get\_\-random\_\-number(), particle\_\-data::GravCost, last, topnode\_\-data::Leaf, NODE::len, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nextnode, Nodes, P, peano\_\-hilbert\_\-key(), topnode\_\-data::StartKey, NODE::suns, ThisTask, TopNodes, particle\_\-data::Type, and NODE::u.



Referenced by force\_\-treebuild().




\begin{DoxyCode}
{
  int i, j, subnode = 0, parent, numnodes;
  int nfree, th, nn, no;
  struct NODE *nfreep;
  double lenhalf, epsilon;
  peanokey key;


  /* create an empty root node  */
  nfree = All.MaxPart;          /* index of first free node */
  nfreep = &Nodes[nfree];       /* select first node */

  nfreep->len = DomainLen;
  for(j = 0; j < 3; j++)
    nfreep->center[j] = DomainCenter[j];
  for(j = 0; j < 8; j++)
    nfreep->u.suns[j] = -1;


  numnodes = 1;
  nfreep++;
  nfree++;

  /* create a set of empty nodes corresponding to the top-level domain
   * grid. We need to generate these nodes first to make sure that we have a
   * complete top-level tree which allows the easy insertion of the
   * pseudo-particles at the right place 
   */

  force_create_empty_nodes(All.MaxPart, 0, 1, 0, 0, 0, &numnodes, &nfree);


  /* if a high-resolution region in a global tree is used, we need to generate
   * an additional set empty nodes to make sure that we have a complete
   * top-level tree for the high-resolution inset
   */

  nfreep = &Nodes[nfree];
  parent = -1;                  /* note: will not be used below before it is chan
      ged */


  /* now we insert all particles */
  for(i = 0; i < npart; i++)
    {

      /* the softening is only used to check whether particles are so close
       * that the tree needs not to be refined further
       */
      epsilon = All.ForceSoftening[P[i].Type];

      key = peano_hilbert_key((P[i].Pos[0] - DomainCorner[0]) * DomainFac,
                              (P[i].Pos[1] - DomainCorner[1]) * DomainFac,
                              (P[i].Pos[2] - DomainCorner[2]) * DomainFac, 
      BITS_PER_DIMENSION);

      no = 0;
      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (key - TopNodes[no].StartKey) / (TopNodes[no
      ].Size / 8);

      no = TopNodes[no].Leaf;
      th = DomainNodeIndex[no];

      while(1)
        {
          if(th >= All.MaxPart) /* we are dealing with an internal node */
            {
              subnode = 0;
              if(P[i].Pos[0] > Nodes[th].center[0])
                subnode += 1;
              if(P[i].Pos[1] > Nodes[th].center[1])
                subnode += 2;
              if(P[i].Pos[2] > Nodes[th].center[2])
                subnode += 4;

              nn = Nodes[th].u.suns[subnode];

              if(nn >= 0)       /* ok, something is in the daughter slot already,
       need to continue */
                {
                  parent = th;
                  th = nn;
                }
              else
                {
                  /* here we have found an empty slot where we can attach
                   * the new particle as a leaf.
                   */
                  Nodes[th].u.suns[subnode] = i;
                  break;        /* done for this particle */
                }
            }
          else
            {
              /* We try to insert into a leaf with a single particle.  Need
               * to generate a new internal node at this point.
               */
              Nodes[parent].u.suns[subnode] = nfree;

              nfreep->len = 0.5 * Nodes[parent].len;
              lenhalf = 0.25 * Nodes[parent].len;

              if(subnode & 1)
                nfreep->center[0] = Nodes[parent].center[0] + lenhalf;
              else
                nfreep->center[0] = Nodes[parent].center[0] - lenhalf;

              if(subnode & 2)
                nfreep->center[1] = Nodes[parent].center[1] + lenhalf;
              else
                nfreep->center[1] = Nodes[parent].center[1] - lenhalf;

              if(subnode & 4)
                nfreep->center[2] = Nodes[parent].center[2] + lenhalf;
              else
                nfreep->center[2] = Nodes[parent].center[2] - lenhalf;

              nfreep->u.suns[0] = -1;
              nfreep->u.suns[1] = -1;
              nfreep->u.suns[2] = -1;
              nfreep->u.suns[3] = -1;
              nfreep->u.suns[4] = -1;
              nfreep->u.suns[5] = -1;
              nfreep->u.suns[6] = -1;
              nfreep->u.suns[7] = -1;


              subnode = 0;
              if(P[th].Pos[0] > nfreep->center[0])
                subnode += 1;
              if(P[th].Pos[1] > nfreep->center[1])
                subnode += 2;
              if(P[th].Pos[2] > nfreep->center[2])
                subnode += 4;
#ifndef NOTREERND
              if(nfreep->len < 1.0e-3 * epsilon)
                {
                  /* seems like we're dealing with particles at identical (or ext
      remely close)
                   * locations. Randomize subnode index to allow tree constructio
      n. Note: Multipole moments
                   * of tree are still correct, but this will only happen well be
      low gravitational softening
                   * length-scale anyway.
                   */
                  subnode = (int) (8.0 * get_random_number((0xffff & P[i].ID) + 
      P[i].GravCost));
                  P[i].GravCost += 1;
                  if(subnode >= 8)
                    subnode = 7;
                }
#endif
              nfreep->u.suns[subnode] = th;

              th = nfree;       /* resume trying to insert the new particle at
                                 * the newly created internal node
                                 */

              numnodes++;
              nfree++;
              nfreep++;

              if((numnodes) >= MaxNodes)
                {
                  printf("task %d: maximum number %d of tree-nodes reached.\n", 
      ThisTask, MaxNodes);
                  printf("for particle %d\n", i);
                  dump_particles();
                  endrun(1);
                }
            }
        }
    }


  /* insert the pseudo particles that represent the mass distribution of other do
      mains */
  force_insert_pseudo_particles();


  /* now compute the multipole moments recursively */
  last = -1;

  force_update_node_recursive(All.MaxPart, -1, -1);

  if(last >= All.MaxPart)
    {
      if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
        Nextnode[last - MaxNodes] = -1;
      else
        Nodes[last].u.d.nextnode = -1;
    }
  else
    Nextnode[last] = -1;

  return numnodes;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a59ae74ef51d6a7065605638422489391}{
\index{proto.h@{proto.h}!force\_\-treeevaluate@{force\_\-treeevaluate}}
\index{force\_\-treeevaluate@{force\_\-treeevaluate}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeevaluate}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode, }
\item[{double $\ast$}]{ ewaldcountsum}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a59ae74ef51d6a7065605638422489391}
This routine computes the gravitational force for a given local particle, or for a particle in the communication buffer. Depending on the value of TypeOfOpeningCriterion, either the geometrical BH cell-\/opening criterion, or the `relative' opening criterion is used. 

Definition at line 1126 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BoxSize, calculate\_\-interact\_\-kick(), NODE::center, check\_\-interaction\_\-table(), NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, FLOAT, force\_\-treeevaluate\_\-ewald\_\-correction(), global\_\-data\_\-all\_\-processes::ForceSoftening, get\_\-random\_\-number(), particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, particle\_\-data::ID, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, gravdata\_\-in::Ninteractions, Nodes, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, prob\_\-of\_\-interaction(), SphP, particle\_\-data::Ti\_\-begstep, particle\_\-data::Ti\_\-endstep, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, update\_\-interaction\_\-table(), particle\_\-data::Vel, and gravdata\_\-in::w.



Referenced by gravity\_\-tree().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ninteractions, ptype;
  double r2, dx, dy, dz, mass, r, fac, u, h, h_inv, h3_inv;
  double acc_x, acc_y, acc_z, pos_x, pos_y, pos_z, aold;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center,kick_x,kick_y,kick_z,kick_target[3],kick_no[3],prob;
  FLOAT  targetVel[3];
  int targetBegstep,targetEndstep;
  unsigned int targetID;
  int si_count,i;
  kick_x = 0;
  kick_y = 0;
  kick_z = 0;
  si_count = 0;
  if(mode == 0)
  {
    for(i=0;i<3;i++)
      targetVel[i] = P[target].Vel[i];
    targetBegstep = P[target].Ti_begstep;
    targetEndstep = P[target].Ti_endstep;
    targetID      = P[target].ID;
  }
  else
  {
    for(i=0;i<3;i++)
      targetVel[i] = GravDataGet[target].u.Vel[i];
    targetBegstep = GravDataGet[target].u.Ti_begstep;
    targetEndstep = GravDataGet[target].u.Ti_endstep;
    targetID      = GravDataGet[target].u.ID;
  }
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  ninteractions = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#ifdef COMPUTE_SELFINTERACTION_FORDARK      
      ptype = GravDataGet[target].Type;
#endif
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }



#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
  h3_inv = h_inv * h_inv * h_inv;
#endif
  no = All.MaxPart;             /* root node */

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;

          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }
          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;

          mass = nop->u.d.mass;
        }
#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node. Need to check openi
      ng criterion */
        {
          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can
                                                 * continue to do a short-cut */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
           /* check if any portion the cell lies withing the intercation range */
      
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#else

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* check in addition whether we lie inside the cell */

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#endif

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(986);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5 signals 
      that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif

          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        fac = mass / (r2 * r);
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
          h3_inv = h_inv * h_inv * h_inv;
#endif
          u = r * h_inv;
          if(u < 0.5)
            fac = mass * h3_inv * (10.666666666667 + u * u * (32.0 * u - 38.4));
          else
            fac =
              mass * h3_inv * (21.333333333333 - 48.0 * u +
                               38.4 * u * u - 10.666666666667 * u * u * u - 0.066
      666666667 / (u * u * u));
        }
      
        acc_x += dx * fac;
        acc_y += dy * fac;
        acc_z += dz * fac;

#ifdef COMPUTE_SELFINTERACTION_FORDARK
        if (no < All.MaxPart)
          {
            if ((ptype == 1 && P[no].Type == 4) || (ptype == 4 && P[no].Type == 1
      ) ) /*This line has been modified for the Test1. original: if (ptype == 1 && P[no
      ].Type == 1)*/
              {
                if (r < 2.0 * All.ForceSoftening[1] && check_interaction_table(ta
      rgetID,P[no].ID) == 0)
                  {
                    prob = prob_of_interaction(r, targetVel, P[no].Vel, targetBeg
      step, targetEndstep);
                    if (get_random_number(P[no].ID) < prob)
                      {
                        calculate_interact_kick(targetVel, P[no].Vel, kick_target
      , kick_no);
                        kick_x += kick_target[0];
                        kick_y += kick_target[1];
                        kick_z += kick_target[2];
                        for (i = 0; i < 3 ; i++)
                          P[no].Vel[i] += kick_no[i];
                        si_count+=1;
                        update_interaction_table(targetID,P[no].ID);
                      }
                  }
              }
          }
#endif
      ninteractions++;
    }
  
#ifdef COMPUTE_SELFINTERACTION_FORDARK 
  All.Nself_interactions += si_count;
#endif

  /* store result at the proper place */
  if(mode == 0)
    {
      P[target].GravAccel[0] = acc_x;
      P[target].GravAccel[1] = acc_y;
      P[target].GravAccel[2] = acc_z;
      P[target].GravCost = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      P[target].Vel[0] += kick_x;
      P[target].Vel[1] += kick_y;
      P[target].Vel[2] += kick_z;
#endif
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
      GravDataResult[target].w.Ninteractions = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      GravDataResult[target].u.Vel[0] = kick_x;
      GravDataResult[target].u.Vel[1] = kick_y;
      GravDataResult[target].u.Vel[2] = kick_z;
#endif
    }

#ifdef PERIODIC
  *ewaldcountsum += force_treeevaluate_ewald_correction(target, mode, pos_x, pos_
      y, pos_z, aold);
#endif

  return ninteractions;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a59ae74ef51d6a7065605638422489391_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a59ae74ef51d6a7065605638422489391_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0ec221b2517893874b12dc366bfe0da8}{
\index{proto.h@{proto.h}!force\_\-treeevaluate\_\-direct@{force\_\-treeevaluate\_\-direct}}
\index{force\_\-treeevaluate\_\-direct@{force\_\-treeevaluate\_\-direct}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeevaluate\_\-direct}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate\_\-direct (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0ec221b2517893874b12dc366bfe0da8}
This function does the force computation with direct summation for the specified particle in the communication buffer. This can be useful for debugging purposes, in particular for explicit checks of the force accuracy. 

Definition at line 2909 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BoxSize, dmax(), ewald\_\-corr(), global\_\-data\_\-all\_\-processes::ForceSoftening, particle\_\-data::GravAccelDirect, GravDataGet, GravDataResult, particle\_\-data::Mass, NumPart, P, gravdata\_\-in::Pos, particle\_\-data::Pos, particle\_\-data::Type, gravdata\_\-in::u, and NODE::u.



Referenced by gravity\_\-forcetest().




\begin{DoxyCode}
{
  double epsilon;
  double h, h_inv, dx, dy, dz, r, r2, u, r_inv, fac;
  int i, ptype;
  double pos_x, pos_y, pos_z;
  double acc_x, acc_y, acc_z;

#ifdef PERIODIC
  double fcorr[3];
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
    }

  for(i = 0; i < NumPart; i++)
    {
      epsilon = dmax(All.ForceSoftening[P[i].Type], All.ForceSoftening[ptype]);

      h = epsilon;
      h_inv = 1 / h;

      dx = P[i].Pos[0] - pos_x;
      dy = P[i].Pos[1] - pos_y;
      dz = P[i].Pos[2] - pos_z;

#ifdef PERIODIC
      while(dx > boxhalf)
        dx -= boxsize;
      while(dy > boxhalf)
        dy -= boxsize;
      while(dz > boxhalf)
        dz -= boxsize;
      while(dx < -boxhalf)
        dx += boxsize;
      while(dy < -boxhalf)
        dy += boxsize;
      while(dz < -boxhalf)
        dz += boxsize;
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      r = sqrt(r2);

      u = r * h_inv;

      if(u >= 1)
        {
          r_inv = 1 / r;

          fac = P[i].Mass * r_inv * r_inv * r_inv;
        }
      else
        {
          if(u < 0.5)
            fac = P[i].Mass * h_inv * h_inv * h_inv * (10.666666666667 + u * u * 
      (32.0 * u - 38.4));
          else
            fac =
              P[i].Mass * h_inv * h_inv * h_inv * (21.333333333333 -
                                                   48.0 * u + 38.4 * u * u -
                                                   10.666666666667 * u * u *
                                                   u - 0.066666666667 / (u * u * 
      u));
        }

      acc_x += dx * fac;
      acc_y += dy * fac;
      acc_z += dz * fac;

#ifdef PERIODIC
      if(u > 1.0e-5)
        {
          ewald_corr(dx, dy, dz, fcorr);

          acc_x += P[i].Mass * fcorr[0];
          acc_y += P[i].Mass * fcorr[1];
          acc_z += P[i].Mass * fcorr[2];
        }
#endif
    }


  if(mode == 0)
    {
      P[target].GravAccelDirect[0] = acc_x;
      P[target].GravAccelDirect[1] = acc_y;
      P[target].GravAccelDirect[2] = acc_z;
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
    }


  return NumPart;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_a0ec221b2517893874b12dc366bfe0da8_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a0ec221b2517893874b12dc366bfe0da8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f}{
\index{proto.h@{proto.h}!force\_\-treeevaluate\_\-ewald\_\-correction@{force\_\-treeevaluate\_\-ewald\_\-correction}}
\index{force\_\-treeevaluate\_\-ewald\_\-correction@{force\_\-treeevaluate\_\-ewald\_\-correction}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeevaluate\_\-ewald\_\-correction}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate\_\-ewald\_\-correction (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode, }
\item[{double}]{ pos\_\-x, }
\item[{double}]{ pos\_\-y, }
\item[{double}]{ pos\_\-z, }
\item[{double}]{ aold}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f}
This function computes the Ewald correction, and is needed if periodic boundary conditions together with a pure tree algorithm are used. Note that the ordinary tree walk does not carry out this correction directly as it was done in Gadget-\/1.1. Instead, the tree is walked a second time. This is actually faster because the \char`\"{}Ewald-\/Treewalk\char`\"{} can use a different opening criterion than the normal tree walk. In particular, the Ewald correction is negligible for particles that are very close, but it is large for particles that are far away (this is quite different for the normal direct force). So we can here use a different opening criterion. Sufficient accuracy is usually obtained if the node length has dropped to a certain fraction $\sim$$<$ 0.25 of the BoxLength. However, we may only short-\/cut the interaction list of the normal full Ewald tree walk if we are sure that the whole node and all daughter nodes \char`\"{}lie on the same side\char`\"{} of the periodic boundary, i.e. that the real tree walk would not find a daughter node or particle that was mapped to a different nearest neighbour position when the tree walk would be further refined. 

Definition at line 1934 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BoxSize, NODE::center, NODE::d, DomainTask, EN, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, fac\_\-intp, fcorrx, fcorry, fcorrz, global\_\-data\_\-all\_\-processes::ForceSoftening, particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataResult, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, gravdata\_\-in::Ninteractions, Nodes, P, particle\_\-data::Pos, gravdata\_\-in::u, NODE::u, and gravdata\_\-in::w.



Referenced by force\_\-treeevaluate().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, cost;
  double dx, dy, dz, mass, r2;
  int signx, signy, signz;
  int i, j, k, openflag;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;
  double acc_x, acc_y, acc_z;
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif
  
  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  cost = 0;

  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }

              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);

      if(no < All.MaxPart)
        no = Nextnode[no];
      else                      /* we have an  internal node. Need to check openi
      ng criterion */
        {
          openflag = 0;

          r2 = dx * dx + dy * dy + dz * dz;
        
#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       +
                              (nop->center[1] - pos_y)*(nop->center[1] - pos_y) +
      
                              (nop->center[2] - pos_z)*(nop->center[2] - pos_z));
      
          /*check if any portion the cell lies withing the intercation range*/
        if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  openflag = 1;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  openflag = 1;
                }
              else
                {
                  if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                        {
                          if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                            {
                              openflag = 1;
                            }
                        }
                    }
                }
            }

          if(openflag)
            {
              /* now we check if we can avoid opening the cell */

              u = nop->center[0] - pos_x;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              u = nop->center[1] - pos_y;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              u = nop->center[2] - pos_z;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* if the cell is too large, we need to refine
               * it further 
               */
              if(nop->len > 0.20 * boxsize)
                {
                  /* cell is too large */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }

          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 1))       /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      /* compute the Ewald correction force */

      if(dx < 0)
        {
          dx = -dx;
          signx = +1;
        }
      else
        signx = -1;

      if(dy < 0)
        {
          dy = -dy;
          signy = +1;
        }
      else
        signy = -1;

      if(dz < 0)
        {
          dz = -dz;
          signz = +1;
        }
      else
        signz = -1;

      u = dx * fac_intp;
      i = (int) u;
      if(i >= EN)
        i = EN - 1;
      u -= i;
      v = dy * fac_intp;
      j = (int) v;
      if(j >= EN)
        j = EN - 1;
      v -= j;
      w = dz * fac_intp;
      k = (int) w;
      if(k >= EN)
        k = EN - 1;
      w -= k;

      /* compute factors for trilinear interpolation */

      f1 = (1 - u) * (1 - v) * (1 - w);
      f2 = (1 - u) * (1 - v) * (w);
      f3 = (1 - u) * (v) * (1 - w);
      f4 = (1 - u) * (v) * (w);
      f5 = (u) * (1 - v) * (1 - w);
      f6 = (u) * (1 - v) * (w);
      f7 = (u) * (v) * (1 - w);
      f8 = (u) * (v) * (w);

      acc_x += mass * signx * (fcorrx[i][j][k] * f1 +
                               fcorrx[i][j][k + 1] * f2 +
                               fcorrx[i][j + 1][k] * f3 +
                               fcorrx[i][j + 1][k + 1] * f4 +
                               fcorrx[i + 1][j][k] * f5 +
                               fcorrx[i + 1][j][k + 1] * f6 +
                               fcorrx[i + 1][j + 1][k] * f7 + fcorrx[i + 1][j + 1
      ][k + 1] * f8);

      acc_y += mass * signy * (fcorry[i][j][k] * f1 +
                               fcorry[i][j][k + 1] * f2 +
                               fcorry[i][j + 1][k] * f3 +
                               fcorry[i][j + 1][k + 1] * f4 +
                               fcorry[i + 1][j][k] * f5 +
                               fcorry[i + 1][j][k + 1] * f6 +
                               fcorry[i + 1][j + 1][k] * f7 + fcorry[i + 1][j + 1
      ][k + 1] * f8);

      acc_z += mass * signz * (fcorrz[i][j][k] * f1 +
                               fcorrz[i][j][k + 1] * f2 +
                               fcorrz[i][j + 1][k] * f3 +
                               fcorrz[i][j + 1][k + 1] * f4 +
                               fcorrz[i + 1][j][k] * f5 +
                               fcorrz[i + 1][j][k + 1] * f6 +
                               fcorrz[i + 1][j + 1][k] * f7 + fcorrz[i + 1][j + 1
      ][k + 1] * f8);
      cost++;
    }


  /* add the result at the proper place */

  if(mode == 0)
    {
      P[target].GravAccel[0] += acc_x;
      P[target].GravAccel[1] += acc_y;
      P[target].GravAccel[2] += acc_z;
      P[target].GravCost += cost;
    }
  else
    {
      GravDataResult[target].u.Acc[0] += acc_x;
      GravDataResult[target].u.Acc[1] += acc_y;
      GravDataResult[target].u.Acc[2] += acc_z;
      GravDataResult[target].w.Ninteractions += cost;
    }

  return cost;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a804166b1847da509d8fe57072b40d5f9}{
\index{proto.h@{proto.h}!force\_\-treeevaluate\_\-potential@{force\_\-treeevaluate\_\-potential}}
\index{force\_\-treeevaluate\_\-potential@{force\_\-treeevaluate\_\-potential}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeevaluate\_\-potential}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeevaluate\_\-potential (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a804166b1847da509d8fe57072b40d5f9}
This routine computes the gravitational potential by walking the tree. The same opening criteria is used as for the gravitational force walk. 

Definition at line 2216 of file forcetree.c.



References All, global\_\-data\_\-all\_\-processes::BoxSize, NODE::center, NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, ewald\_\-pot\_\-corr(), Exportflag, global\_\-data\_\-all\_\-processes::ForceSoftening, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, Nodes, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, gravdata\_\-in::Potential, particle\_\-data::Potential, SphP, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, and gravdata\_\-in::w.



Referenced by compute\_\-potential().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype;
  double r2, dx, dy, dz, mass, r, u, h, h_inv, wp;
  double pot, pos_x, pos_y, pos_z, aold;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif
  
  pot = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }


#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
#endif
  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an internal node. Need to check openin
      g criterion */
        {
          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can make
                                                 * a short-cut 
                                                 */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
           /*check if any portion the cell lies withing the intercation range*/
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
          {
            /* open cell */
            no = nop->u.d.nextnode;
            continue;
          }
#endif
        
          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(988);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5 signals 
      that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif

          no = nop->u.d.sibling;        /* node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        pot -= mass / r;
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
#endif
          u = r * h_inv;

          if(u < 0.5)
            wp = -2.8 + u * u * (5.333333333333 + u * u * (6.4 * u - 9.6));
          else
            wp =
              -3.2 + 0.066666666667 / u + u * u * (10.666666666667 +
                                                   u * (-16.0 + u * (9.6 - 2.1333
      33333333 * u)));

          pot += mass * h_inv * wp;
        }
#ifdef PERIODIC
      pot += mass * ewald_pot_corr(dx, dy, dz);
#endif
    }

  /* store result at the proper place */

  if(mode == 0)
    P[target].Potential = pot;
  else
    GravDataResult[target].u.Potential = pot;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a804166b1847da509d8fe57072b40d5f9_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a804166b1847da509d8fe57072b40d5f9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7}{
\index{proto.h@{proto.h}!force\_\-treeevaluate\_\-potential\_\-shortrange@{force\_\-treeevaluate\_\-potential\_\-shortrange}}
\index{force\_\-treeevaluate\_\-potential\_\-shortrange@{force\_\-treeevaluate\_\-potential\_\-shortrange}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeevaluate\_\-potential\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeevaluate\_\-potential\_\-shortrange (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7}
This function computes the short-\/range potential when the TreePM algorithm is used. This potential is the Newtonian potential, modified by a complementary error function. 

Definition at line 2493 of file forcetree.c.



References All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, NODE::center, NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, global\_\-data\_\-all\_\-processes::ForceSoftening, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, Nodes, NTAB, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, gravdata\_\-in::Potential, particle\_\-data::Potential, global\_\-data\_\-all\_\-processes::Rcut, shortrange\_\-table\_\-potential, SphP, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, and gravdata\_\-in::w.



Referenced by compute\_\-potential().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype, tabindex;
  double r2, dx, dy, dz, mass, r, u, h, h_inv, wp;
  double pot, pos_x, pos_y, pos_z, aold;
  double eff_dist, fac, rcut, asmth, asmthfac;
  double dxx, dyy, dzz;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif

#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif

  pot = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }


  rcut = All.Rcut[0];
  asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
  if(((1 << ptype) & (PLACEHIGHRESREGION)))
    {
      rcut = All.Rcut[1];
      asmth = All.Asmth[1];
    }
#endif
  asmthfac = 0.5 / asmth * (NTAB / 3.0);

#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
#endif

  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign  */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node. Need to check openi
      ng criterion */
        {
          /* check whether we can stop walking along this branch */
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node which
       does not contain local particles */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

          eff_dist = rcut + 0.5 * nop->len;

          dxx = nop->center[0] - pos_x; /* observe the sign ! */
          dyy = nop->center[1] - pos_y; /* this vector is -y in my thesis notatio
      n */
          dzz = nop->center[2] - pos_z;
#ifdef PERIODIC
          dxx = NEAREST(dxx);
          dyy = NEAREST(dyy);
          dzz = NEAREST(dzz);
#endif
          if(dxx < -eff_dist || dxx > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

          if(dyy < -eff_dist || dyy > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

          if(dzz < -eff_dist || dzz > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
           /*check if any portion the cell lies withing the intercation range*/
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
          {
            /* open cell */
            no = nop->u.d.nextnode;
            continue;
          }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(989);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      /* bit-5 signals that there are particles of
                       * different softening in the node
                       */
                      if(((nop->u.d.bitflags >> 5) & 1))
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif
          no = nop->u.d.sibling;        /* node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      tabindex = (int) (r * asmthfac);

      if(tabindex < NTAB)
        {
          fac = shortrange_table_potential[tabindex];

          if(r >= h)
            pot -= fac * mass / r;
          else
            {
#ifdef UNEQUALSOFTENINGS
              h_inv = 1.0 / h;
#endif
              u = r * h_inv;

              if(u < 0.5)
                wp = -2.8 + u * u * (5.333333333333 + u * u * (6.4 * u - 9.6));
              else
                wp =
                  -3.2 + 0.066666666667 / u + u * u * (10.666666666667 +
                                                       u * (-16.0 + u * (9.6 - 2.
      133333333333 * u)));
              pot += fac * mass * h_inv * wp;
            }
        }
    }


  /* store result at the proper place */
  if(mode == 0)
    P[target].Potential = pot;
  else
    GravDataResult[target].u.Potential = pot;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae01e179b7686a7fe62970160b7bbdb46}{
\index{proto.h@{proto.h}!force\_\-treeevaluate\_\-shortrange@{force\_\-treeevaluate\_\-shortrange}}
\index{force\_\-treeevaluate\_\-shortrange@{force\_\-treeevaluate\_\-shortrange}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeevaluate\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}int force\_\-treeevaluate\_\-shortrange (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ae01e179b7686a7fe62970160b7bbdb46}
In the TreePM algorithm, the tree is walked only locally around the target coordinate. Tree nodes that fall outside a box of half side-\/length Rcut= RCUT$\ast$ASMTH$\ast$MeshSize can be discarded. The short-\/range potential is modified by a complementary error function, multiplied with the Newtonian form. The resulting short-\/range suppression compared to the Newtonian force is tabulated, because looking up from this table is faster than recomputing the corresponding factor, despite the memory-\/access panelty (which reduces cache performance) incurred by the table. 

Definition at line 1500 of file forcetree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, calculate\_\-interact\_\-kick(), NODE::center, check\_\-interaction\_\-table(), NODE::d, DomainTask, endrun(), global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, FLOAT, global\_\-data\_\-all\_\-processes::ForceSoftening, get\_\-random\_\-number(), particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataGet, GravDataResult, sph\_\-particle\_\-data::Hsml, particle\_\-data::ID, NODE::len, particle\_\-data::Mass, NODE::mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, NEAREST, Nextnode, gravdata\_\-in::Ninteractions, Nodes, NTAB, gravdata\_\-in::OldAcc, particle\_\-data::OldAcc, P, gravdata\_\-in::Pos, particle\_\-data::Pos, prob\_\-of\_\-interaction(), global\_\-data\_\-all\_\-processes::Rcut, shortrange\_\-table, SphP, particle\_\-data::Ti\_\-begstep, particle\_\-data::Ti\_\-endstep, particle\_\-data::Type, gravdata\_\-in::u, NODE::u, update\_\-interaction\_\-table(), particle\_\-data::Vel, and gravdata\_\-in::w.



Referenced by gravity\_\-tree().




\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype, ninteractions, tabindex;
  double r2, dx, dy, dz, mass, r, fac, u, h, h_inv, h3_inv;
  double acc_x, acc_y, acc_z, pos_x, pos_y, pos_z, aold;
  double eff_dist;
  double rcut, asmth, asmthfac, rcut2, dist;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center,kick_x,kick_y,kick_z,kick_target[3],kick_no[3],prob;
  FLOAT targetVel[3];
  int targetBegstep,targetEndstep;
  unsigned int targetID;
  int si_count,i;
  kick_x = 0;
  kick_y = 0;
  kick_z = 0;
  si_count = 0;
  if(mode == 0)
    {
      for(i=0;i<3;i++)
        targetVel[i] = P[target].Vel[i];
      targetBegstep = P[target].Ti_begstep;
      targetEndstep = P[target].Ti_endstep;
      targetID      = P[target].ID;
    }
  else
    {
      for(i=0;i<3;i++)
        targetVel[i] = GravDataGet[target].u.Vel[i];
      targetBegstep = GravDataGet[target].u.Ti_begstep;
      targetEndstep = GravDataGet[target].u.Ti_endstep;
      targetID      = GravDataGet[target].u.ID;
    }
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  ninteractions = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#ifdef COMPUTE_SELFINTERACTION_FORDARK      
      ptype = GravDataGet[target].Type;
#endif
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }

  rcut = All.Rcut[0];
  asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
  if(((1 << ptype) & (PLACEHIGHRESREGION)))
    {
      rcut = All.Rcut[1];
      asmth = All.Asmth[1];
    }
#endif
  rcut2 = rcut * rcut;

  asmthfac = 0.5 / asmth * (NTAB / 3.0);

#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
  h3_inv = h_inv * h_inv * h_inv;
#endif
  no = All.MaxPart;             /* root node */

  while(no >= 0)
    {
      if(no < All.MaxPart)
        {
          /* the index of the node is the index of the particle */
          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
#ifdef PERIODIC
          dx = NEAREST(dx);
          dy = NEAREST(dy);
          dz = NEAREST(dz);
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          mass = P[no].Mass;
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node */
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can
                                                 * continue at this point
                                                 */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

          mass = nop->u.d.mass;

          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
#ifdef PERIODIC
          dx = NEAREST(dx);
          dy = NEAREST(dy);
          dz = NEAREST(dz);
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          if(r2 > rcut2)
            {
              /* check whether we can stop walking along this branch */
              eff_dist = rcut + 0.5 * nop->len;
#ifdef PERIODIC
              dist = NEAREST(nop->center[0] - pos_x);
#else
              dist = nop->center[0] - pos_x;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
#ifdef PERIODIC
              dist = NEAREST(nop->center[1] - pos_y);
#else
              dist = nop->center[1] - pos_y;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
#ifdef PERIODIC
              dist = NEAREST(nop->center[2] - pos_z);
#else
              dist = nop->center[2] - pos_z;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - pos_x)
       + 
                                (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                                (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
          /*check if any portion the cell lies withing the intercation range */
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0 * All.
      ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* check in addition whether we lie inside the cell */

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes */
      
            {
              if(mass > 0)
                endrun(987);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5 signals 
      that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif
          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node b
      elongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        fac = mass / (r2 * r);
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
          h3_inv = h_inv * h_inv * h_inv;
#endif
          u = r * h_inv;
          if(u < 0.5)
            fac = mass * h3_inv * (10.666666666667 + u * u * (32.0 * u - 38.4));
          else
            fac =
              mass * h3_inv * (21.333333333333 - 48.0 * u +
                               38.4 * u * u - 10.666666666667 * u * u * u - 0.066
      666666667 / (u * u * u));
        }

      tabindex = (int) (asmthfac * r);

      if(tabindex < NTAB)
        {
          fac *= shortrange_table[tabindex];

          acc_x += dx * fac;
          acc_y += dy * fac;
          acc_z += dz * fac;
        
#ifdef COMPUTE_SELFINTERACTION_FORDARK
          if(no < All.MaxPart)
            {
              if ((ptype == 1 && P[no].Type == 4) || (ptype == 4 && P[no].Type ==
       1) ) /*This line has been modified for the Test1. original: if (ptype == 1 && P[
      no].Type == 1)*/
                {
                  if(r < 2.0 * All.ForceSoftening[1] && check_interaction_table(t
      argetID,P[no].ID) == 0)
                    {
                      prob = prob_of_interaction(r, targetVel, P[no].Vel, targetB
      egstep, targetEndstep);
                      if(get_random_number(P[no].ID) < prob)
                        {
                          calculate_interact_kick(targetVel, P[no].Vel, kick_targ
      et, kick_no);
                          kick_x += kick_target[0];
                          kick_y += kick_target[1];
                          kick_z += kick_target[2];
                          for(i = 0; i < 3 ; i++)
                              P[no].Vel[i] += kick_no[i];
                          si_count+=1;
                          update_interaction_table(targetID,P[no].ID);
                        }
                    }
                }
            }
#endif
          ninteractions++;
        }
    }

#ifdef COMPUTE_SELFINTERACTION_FORDARK 
  All.Nself_interactions += si_count;
#endif

  /* store result at the proper place */

  if(mode == 0)
    {
      P[target].GravAccel[0] = acc_x;
      P[target].GravAccel[1] = acc_y;
      P[target].GravAccel[2] = acc_z;
      P[target].GravCost = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      P[target].Vel[0] += kick_x;
      P[target].Vel[1] += kick_y;
      P[target].Vel[2] += kick_z;
#endif
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
      GravDataResult[target].w.Ninteractions = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      GravDataResult[target].u.Vel[0] = kick_x;
      GravDataResult[target].u.Vel[1] = kick_y;
      GravDataResult[target].u.Vel[2] = kick_z;
#endif
    }

  return ninteractions;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae01e179b7686a7fe62970160b7bbdb46_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae01e179b7686a7fe62970160b7bbdb46_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888}{
\index{proto.h@{proto.h}!force\_\-treefree@{force\_\-treefree}}
\index{force\_\-treefree@{force\_\-treefree}!proto.h@{proto.h}}
\subsubsection[{force\_\-treefree}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treefree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888}
This function frees the memory allocated for the tree, i.e. it frees the space allocated by the function \hyperlink{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2}{force\_\-treeallocate()}. 

Definition at line 2892 of file forcetree.c.



References Extnodes\_\-base, Father, Nextnode, and Nodes\_\-base.



Referenced by pmforce\_\-periodic(), and pmpotential\_\-periodic().




\begin{DoxyCode}
{
  free(Father);
  free(Nextnode);
  free(Extnodes_base);
  free(Nodes_base);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19}{
\index{proto.h@{proto.h}!force\_\-treeupdate\_\-pseudos@{force\_\-treeupdate\_\-pseudos}}
\index{force\_\-treeupdate\_\-pseudos@{force\_\-treeupdate\_\-pseudos}!proto.h@{proto.h}}
\subsubsection[{force\_\-treeupdate\_\-pseudos}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-treeupdate\_\-pseudos (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19}
This function updates the top-\/level tree after the multipole moments of the pseudo-\/particles have been updated. 

Definition at line 732 of file forcetree.c.



References All, NODE::d, DomainMoment, DomainMyLast, DomainNodeIndex, Extnodes, FLOAT, global\_\-data\_\-all\_\-processes::ForceSoftening, DomainNODE::mass, Nodes, NTopleaves, DomainNODE::s, NODE::u, DomainNODE::vs, and extNODE::vs.



Referenced by force\_\-update\_\-pseudoparticles().




\begin{DoxyCode}
{
  int i, k, no;
  FLOAT sold[3], vsold[3], snew[3], vsnew[3], massold, massnew, mm;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
  int maxsofttype, diffsoftflag;
#else
  FLOAT maxsoft;
#endif
#endif

  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        for(k = 0; k < 3; k++)
          {
            sold[k] = Nodes[no].u.d.s[k];
            vsold[k] = Extnodes[no].vs[k];
          }
        massold = Nodes[no].u.d.mass;

        for(k = 0; k < 3; k++)
          {
            snew[k] = DomainMoment[i].s[k];
            vsnew[k] = DomainMoment[i].vs[k];
          }
        massnew = DomainMoment[i].mass;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
        maxsofttype = (DomainMoment[i].bitflags >> 2) & 7;
        diffsoftflag = (DomainMoment[i].bitflags >> 5) & 1;
#else
        maxsoft = DomainMoment[i].maxsoft;
#endif
#endif
        do
          {
            mm = Nodes[no].u.d.mass + massnew - massold;
            for(k = 0; k < 3; k++)
              {
                if(mm > 0)
                  {
                    Nodes[no].u.d.s[k] =
                      (Nodes[no].u.d.mass * Nodes[no].u.d.s[k] + massnew * snew[k
      ] - massold * sold[k]) / mm;
                    Extnodes[no].vs[k] =
                      (Nodes[no].u.d.mass * Extnodes[no].vs[k] + massnew * vsnew[
      k] -
                       massold * vsold[k]) / mm;
                  }
              }
            Nodes[no].u.d.mass = mm;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
            diffsoftflag |= (Nodes[no].u.d.bitflags >> 5) & 1;

            if(maxsofttype == 7)
              maxsofttype = (Nodes[no].u.d.bitflags >> 2) & 7;
            else
              {
                if(((Nodes[no].u.d.bitflags >> 2) & 7) != 7)
                  {
                    if(All.ForceSoftening[((Nodes[no].u.d.bitflags >> 2) & 7)] >
                       All.ForceSoftening[maxsofttype])
                      {
                        maxsofttype = ((Nodes[no].u.d.bitflags >> 2) & 7);
                        diffsoftflag = 1;
                      }
                    else
                      {
                        if(All.ForceSoftening[((Nodes[no].u.d.bitflags >> 2) & 7)
      ] <
                           All.ForceSoftening[maxsofttype])
                          diffsoftflag = 1;
                      }
                  }
              }

            Nodes[no].u.d.bitflags = (Nodes[no].u.d.bitflags & 3) + 4 * maxsoftty
      pe + 32 * diffsoftflag;
#else
            if(Nodes[no].maxsoft < maxsoft)
              Nodes[no].maxsoft = maxsoft;
            maxsoft = Nodes[no].maxsoft;
#endif
#endif
            no = Nodes[no].u.d.father;

          }
        while(no >= 0);
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4764c1fb83a956c1712345538630854c}{
\index{proto.h@{proto.h}!force\_\-update\_\-hmax@{force\_\-update\_\-hmax}}
\index{force\_\-update\_\-hmax@{force\_\-update\_\-hmax}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-hmax}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-hmax (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a4764c1fb83a956c1712345538630854c}
This function updates the hmax-\/values in tree nodes that hold SPH particles. These values are needed to find all neighbors in the hydro-\/force computation. Since the Hsml-\/values are potentially changed in the SPH-\/denity computation, \hyperlink{forcetree_8c_a4764c1fb83a956c1712345538630854c}{force\_\-update\_\-hmax()} should be carried out just before the hydrodynamical SPH forces are computed, i.e. after \hyperlink{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density()}. 

Definition at line 1014 of file forcetree.c.



References DomainEndList, DomainHmax, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, Extnodes, FLOAT, force\_\-update\_\-node\_\-hmax\_\-local(), force\_\-update\_\-node\_\-hmax\_\-toptree(), extNODE::hmax, NTask, PTask, TAG\_\-HMAX, and ThisTask.



Referenced by compute\_\-accelerations().




\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  force_update_node_hmax_local();

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      DomainHmax[i] = Extnodes[no].hmax;
    }

  /* share the hmax-data of the pseudo-particles accross CPUs */

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainHmax[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_HMAX,
                     &DomainHmax[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_HMAX, MPI_COMM_WORLD, &status);
    }


  force_update_node_hmax_toptree();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a4764c1fb83a956c1712345538630854c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a4764c1fb83a956c1712345538630854c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a04fb647ef783d5baeb9275d806c08365}{
\index{proto.h@{proto.h}!force\_\-update\_\-len@{force\_\-update\_\-len}}
\index{force\_\-update\_\-len@{force\_\-update\_\-len}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-len}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-len (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a04fb647ef783d5baeb9275d806c08365}
This function updates the side-\/length of tree nodes in case the tree is not reconstructed, but only drifted. The grouping of particles to tree nodes is not changed in this case, but some tree nodes may need to be enlarged because particles moved out of their original bounds. 

Definition at line 885 of file forcetree.c.



References DomainEndList, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, DomainTreeNodeLen, FLOAT, force\_\-update\_\-node\_\-len\_\-local(), force\_\-update\_\-node\_\-len\_\-toptree(), NODE::len, Nodes, NTask, PTask, TAG\_\-NODELEN, and ThisTask.



Referenced by move\_\-particles().




\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  force_update_node_len_local();

  /* first update the side-lengths of all local nodes */
  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      DomainTreeNodeLen[i] = Nodes[no].len;
    }

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainTreeNodeLen[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_NODELEN,
                     &DomainTreeNodeLen[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) * 
      sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_NODELEN, MPI_COMM_WORLD, &status);
    }

  /* Finally, we update the top-level tree. */
  force_update_node_len_toptree();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=386pt]{proto_8h_a04fb647ef783d5baeb9275d806c08365_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a04fb647ef783d5baeb9275d806c08365_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0292cb282788bf4e4f06636096c5abdf}{
\index{proto.h@{proto.h}!force\_\-update\_\-node@{force\_\-update\_\-node}}
\index{force\_\-update\_\-node@{force\_\-update\_\-node}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-node}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node (
\begin{DoxyParamCaption}
\item[{int}]{ no, }
\item[{int}]{ flag}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0292cb282788bf4e4f06636096c5abdf}
\hypertarget{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074}{
\index{proto.h@{proto.h}!force\_\-update\_\-node\_\-hmax\_\-local@{force\_\-update\_\-node\_\-hmax\_\-local}}
\index{force\_\-update\_\-node\_\-hmax\_\-local@{force\_\-update\_\-node\_\-hmax\_\-local}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-node\_\-hmax\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-hmax\_\-local (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074}
This routine updates the hmax-\/values of local tree nodes. 

Definition at line 1051 of file forcetree.c.



References NODE::d, Extnodes, Father, extNODE::hmax, sph\_\-particle\_\-data::Hsml, N\_\-gas, Nodes, SphP, and NODE::u.



Referenced by force\_\-update\_\-hmax().




\begin{DoxyCode}
{
  int i, p, no;

  for(i = 0; i < N_gas; i++)
    {

      no = Father[i];

      if(SphP[i].Hsml > Extnodes[no].hmax)
        {

          Extnodes[no].hmax = SphP[i].Hsml;
          p = Nodes[no].u.d.father;

          while(p >= 0)
            {
              if(Extnodes[no].hmax > Extnodes[p].hmax)
                {
                  Extnodes[p].hmax = Extnodes[no].hmax;
                  no = p;
                  p = Nodes[p].u.d.father;
                }
              else
                break;
            }
        }

    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac3f5945bb7c73936ef49af1507265afe}{
\index{proto.h@{proto.h}!force\_\-update\_\-node\_\-hmax\_\-toptree@{force\_\-update\_\-node\_\-hmax\_\-toptree}}
\index{force\_\-update\_\-node\_\-hmax\_\-toptree@{force\_\-update\_\-node\_\-hmax\_\-toptree}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-node\_\-hmax\_\-toptree}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-hmax\_\-toptree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ac3f5945bb7c73936ef49af1507265afe}
This function recursively sets the hmax-\/values of the top-\/level tree. 

Definition at line 1087 of file forcetree.c.



References NODE::d, DomainHmax, DomainMyLast, DomainNodeIndex, Extnodes, extNODE::hmax, Nodes, NTopleaves, and NODE::u.



Referenced by force\_\-update\_\-hmax().




\begin{DoxyCode}
{

  int i, no, p;


  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        if(Extnodes[no].hmax < DomainHmax[i])
          Extnodes[no].hmax = DomainHmax[i];

        p = Nodes[no].u.d.father;

        while(p >= 0)
          {
            if(Extnodes[no].hmax > Extnodes[p].hmax)
              {
                Extnodes[p].hmax = Extnodes[no].hmax;
                no = p;
                p = Nodes[p].u.d.father;
              }
            else
              break;
          }
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac3f5945bb7c73936ef49af1507265afe_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4592b750f8555f580691103acf1e5366}{
\index{proto.h@{proto.h}!force\_\-update\_\-node\_\-len\_\-local@{force\_\-update\_\-node\_\-len\_\-local}}
\index{force\_\-update\_\-node\_\-len\_\-local@{force\_\-update\_\-node\_\-len\_\-local}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-node\_\-len\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-len\_\-local (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a4592b750f8555f580691103acf1e5366}
This function recursively enlarges nodes such that they always contain all their daughter nodes and daughter particles. 

Definition at line 923 of file forcetree.c.



References NODE::center, NODE::d, Father, FLOAT, NODE::len, Nodes, NumPart, P, particle\_\-data::Pos, and NODE::u.



Referenced by force\_\-update\_\-len().




\begin{DoxyCode}
{
  int i, p, k, no;
  FLOAT dist, distmax;

  for(i = 0; i < NumPart; i++)
    {
      no = Father[i];

      for(k = 0, distmax = 0; k < 3; k++)
        {
          dist = P[i].Pos[k] - Nodes[no].center[k];
          if(dist < 0)
            dist = -dist;
          if(dist > distmax)
            distmax = dist;
        }

      if(distmax + distmax > Nodes[no].len)
        {
          Nodes[no].len = distmax + distmax;
          p = Nodes[no].u.d.father;

          while(p >= 0)
            {
              distmax = Nodes[p].center[0] - Nodes[no].center[0];
              if(distmax < 0)
                distmax = -distmax;
              distmax = distmax + distmax + Nodes[no].len;

              if(0.999999 * distmax > Nodes[p].len)
                {
                  Nodes[p].len = distmax;
                  no = p;
                  p = Nodes[p].u.d.father;
                }
              else
                break;
            }
        }
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a4592b750f8555f580691103acf1e5366_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5f85438d619d63c812c8e05faf1f0074}{
\index{proto.h@{proto.h}!force\_\-update\_\-node\_\-len\_\-toptree@{force\_\-update\_\-node\_\-len\_\-toptree}}
\index{force\_\-update\_\-node\_\-len\_\-toptree@{force\_\-update\_\-node\_\-len\_\-toptree}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-node\_\-len\_\-toptree}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-len\_\-toptree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a5f85438d619d63c812c8e05faf1f0074}
This function recursively enlarges nodes of the top-\/level tree such that they always contain all their daughter nodes. 

Definition at line 970 of file forcetree.c.



References NODE::center, NODE::d, DomainMyLast, DomainNodeIndex, DomainTreeNodeLen, FLOAT, NODE::len, Nodes, NTopleaves, and NODE::u.



Referenced by force\_\-update\_\-len().




\begin{DoxyCode}
{
  int i, no, p;
  FLOAT distmax;

  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        if(Nodes[no].len < DomainTreeNodeLen[i])
          Nodes[no].len = DomainTreeNodeLen[i];

        p = Nodes[no].u.d.father;

        while(p >= 0)
          {
            distmax = Nodes[p].center[0] - Nodes[no].center[0];
            if(distmax < 0)
              distmax = -distmax;
            distmax = distmax + distmax + Nodes[no].len;

            if(0.999999 * distmax > Nodes[p].len)
              {
                Nodes[p].len = distmax;
                no = p;
                p = Nodes[p].u.d.father;
              }
            else
              break;
          }
      }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a5f85438d619d63c812c8e05faf1f0074_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab745c54c805d07ad255a3f86ff77e18d}{
\index{proto.h@{proto.h}!force\_\-update\_\-node\_\-recursive@{force\_\-update\_\-node\_\-recursive}}
\index{force\_\-update\_\-node\_\-recursive@{force\_\-update\_\-node\_\-recursive}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-node\_\-recursive}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-node\_\-recursive (
\begin{DoxyParamCaption}
\item[{int}]{ no, }
\item[{int}]{ sib, }
\item[{int}]{ father}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab745c54c805d07ad255a3f86ff77e18d}
this routine determines the multipole moments for a given internal node and all its subnodes using a recursive computation. The result is stored in the Nodes\mbox{[}\mbox{]} structure in the sequence of this tree-\/walk.

Note that the bitflags-\/variable for each node is used to store in the lowest bits some special information: Bit 0 flags whether the node belongs to the top-\/level tree corresponding to the domain decomposition, while Bit 1 signals whether the top-\/level node is dependent on local mass.

If UNEQUALSOFTENINGS is set, bits 2-\/4 give the particle type with the maximum softening among the particles in the node, and bit 5 flags whether the node contains any particles with lower softening than that. 

Definition at line 422 of file forcetree.c.



References All, NODE::center, NODE::d, Extnodes, Father, FLOAT, force\_\-update\_\-node\_\-recursive(), global\_\-data\_\-all\_\-processes::ForceSoftening, extNODE::hmax, sph\_\-particle\_\-data::Hsml, last, particle\_\-data::Mass, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nextnode, Nodes, P, particle\_\-data::Pos, SphP, NODE::suns, particle\_\-data::Type, NODE::u, particle\_\-data::Vel, and extNODE::vs.



Referenced by force\_\-treebuild\_\-single(), and force\_\-update\_\-node\_\-recursive().




\begin{DoxyCode}
{
  int j, jj, p, pp, nextsib, suns[8];
  FLOAT hmax;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
  int maxsofttype, diffsoftflag;
#else
  FLOAT maxsoft;
#endif
#endif
  struct particle_data *pa;
  double s[3], vs[3], mass;

  if(no >= All.MaxPart && no < All.MaxPart + MaxNodes)  /* internal node */
    {
      for(j = 0; j < 8; j++)
        suns[j] = Nodes[no].u.suns[j];  /* this "backup" is necessary because the
       nextnode entry will
                                           overwrite one element (union!) */
      if(last >= 0)
        {
          if(last >= All.MaxPart)
            {
              if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
                Nextnode[last - MaxNodes] = no;
              else
                Nodes[last].u.d.nextnode = no;
            }
          else
            Nextnode[last] = no;
        }

      last = no;

      mass = 0;
      s[0] = 0;
      s[1] = 0;
      s[2] = 0;
      vs[0] = 0;
      vs[1] = 0;
      vs[2] = 0;
      hmax = 0;
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      maxsofttype = 7;
      diffsoftflag = 0;
#else
      maxsoft = 0;
#endif
#endif

      for(j = 0; j < 8; j++)
        {
          if((p = suns[j]) >= 0)
            {
              /* check if we have a sibling on the same level */
              for(jj = j + 1; jj < 8; jj++)
                if((pp = suns[jj]) >= 0)
                  break;

              if(jj < 8)        /* yes, we do */
                nextsib = pp;
              else
                nextsib = sib;

              force_update_node_recursive(p, nextsib, no);


              if(p >= All.MaxPart)      /* an internal node or pseudo particle */
      
                {
                  if(p >= All.MaxPart + MaxNodes)       /* a pseudo particle */
                    {
                      /* nothing to be done here because the mass of the
                       * pseudo-particle is still zero. This will be changed
                       * later.
                       */
                    }
                  else
                    {
                      mass += Nodes[p].u.d.mass;
                      s[0] += Nodes[p].u.d.mass * Nodes[p].u.d.s[0];
                      s[1] += Nodes[p].u.d.mass * Nodes[p].u.d.s[1];
                      s[2] += Nodes[p].u.d.mass * Nodes[p].u.d.s[2];
                      vs[0] += Nodes[p].u.d.mass * Extnodes[p].vs[0];
                      vs[1] += Nodes[p].u.d.mass * Extnodes[p].vs[1];
                      vs[2] += Nodes[p].u.d.mass * Extnodes[p].vs[2];

                      if(Extnodes[p].hmax > hmax)
                        hmax = Extnodes[p].hmax;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
                      diffsoftflag |= (Nodes[p].u.d.bitflags >> 5) & 1;

                      if(maxsofttype == 7)
                        {
                          maxsofttype = (Nodes[p].u.d.bitflags >> 2) & 7;
                        }
                      else
                        {
                          if(((Nodes[p].u.d.bitflags >> 2) & 7) != 7)
                            {
                              if(All.ForceSoftening[((Nodes[p].u.d.bitflags >> 2)
       & 7)] >
                                 All.ForceSoftening[maxsofttype])
                                {
                                  maxsofttype = ((Nodes[p].u.d.bitflags >> 2) & 7
      );
                                  diffsoftflag = 1;
                                }
                              else
                                {
                                  if(All.ForceSoftening[((Nodes[p].u.d.bitflags >
      > 2) & 7)] <
                                     All.ForceSoftening[maxsofttype])
                                    diffsoftflag = 1;
                                }
                            }
                        }
#else
                      if(Nodes[p].maxsoft > maxsoft)
                        maxsoft = Nodes[p].maxsoft;
#endif
#endif
                    }
                }
              else              /* a particle */
                {
                  pa = &P[p];

                  mass += pa->Mass;
                  s[0] += pa->Mass * pa->Pos[0];
                  s[1] += pa->Mass * pa->Pos[1];
                  s[2] += pa->Mass * pa->Pos[2];
                  vs[0] += pa->Mass * pa->Vel[0];
                  vs[1] += pa->Mass * pa->Vel[1];
                  vs[2] += pa->Mass * pa->Vel[2];

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
                  if(maxsofttype == 7)
                    {
                      maxsofttype = pa->Type;
                    }
                  else
                    {
                      if(All.ForceSoftening[pa->Type] > All.ForceSoftening[maxsof
      ttype])
                        {
                          maxsofttype = pa->Type;
                          diffsoftflag = 1;
                        }
                      else
                        {
                          if(All.ForceSoftening[pa->Type] < All.ForceSoftening[ma
      xsofttype])
                            diffsoftflag = 1;
                        }
                    }
#else
                  if(pa->Type == 0)
                    {
                      if(SphP[p].Hsml > maxsoft)
                        maxsoft = SphP[p].Hsml;
                    }
                  else
                    {
                      if(All.ForceSoftening[pa->Type] > maxsoft)
                        maxsoft = All.ForceSoftening[pa->Type];
                    }
#endif
#endif
                  if(pa->Type == 0)
                    if(SphP[p].Hsml > hmax)
                      hmax = SphP[p].Hsml;
                }
            }
        }


      if(mass)
        {
          s[0] /= mass;
          s[1] /= mass;
          s[2] /= mass;
          vs[0] /= mass;
          vs[1] /= mass;
          vs[2] /= mass;
        }
      else
        {
          s[0] = Nodes[no].center[0];
          s[1] = Nodes[no].center[1];
          s[2] = Nodes[no].center[2];
        }

      Nodes[no].u.d.s[0] = s[0];
      Nodes[no].u.d.s[1] = s[1];
      Nodes[no].u.d.s[2] = s[2];
      Nodes[no].u.d.mass = mass;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      Nodes[no].u.d.bitflags = 4 * maxsofttype + 32 * diffsoftflag;
#else
      Nodes[no].u.d.bitflags = 0;
      Nodes[no].maxsoft = maxsoft;
#endif
#else
      Nodes[no].u.d.bitflags = 0;
#endif


      Extnodes[no].vs[0] = vs[0];
      Extnodes[no].vs[1] = vs[1];
      Extnodes[no].vs[2] = vs[2];
      Extnodes[no].hmax = hmax;

      Nodes[no].u.d.sibling = sib;
      Nodes[no].u.d.father = father;
    }
  else                          /* single particle or pseudo particle */
    {
      if(last >= 0)
        {
          if(last >= All.MaxPart)
            {
              if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
                Nextnode[last - MaxNodes] = no;
              else
                Nodes[last].u.d.nextnode = no;
            }
          else
            Nextnode[last] = no;
        }

      last = no;

      if(no < All.MaxPart)      /* only set it for single particles */
        Father[no] = father;
    }

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab745c54c805d07ad255a3f86ff77e18d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ab745c54c805d07ad255a3f86ff77e18d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0}{
\index{proto.h@{proto.h}!force\_\-update\_\-pseudoparticles@{force\_\-update\_\-pseudoparticles}}
\index{force\_\-update\_\-pseudoparticles@{force\_\-update\_\-pseudoparticles}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-pseudoparticles}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-pseudoparticles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0}
This function updates the multipole moments of the pseudo-\/particles that represent the mass distribution on different CPUs. For that purpose, it first exchanges the necessary data, and then updates the top-\/level tree accordingly. The detailed implementation of these two tasks is done in separate functions. 

Definition at line 671 of file forcetree.c.



References force\_\-exchange\_\-pseudodata(), and force\_\-treeupdate\_\-pseudos().



Referenced by force\_\-treebuild(), and move\_\-particles().




\begin{DoxyCode}
{
  force_exchange_pseudodata();

  force_treeupdate_pseudos();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a207b80df2a123bc29295a0d496186d70}{
\index{proto.h@{proto.h}!force\_\-update\_\-size\_\-of\_\-parent\_\-node@{force\_\-update\_\-size\_\-of\_\-parent\_\-node}}
\index{force\_\-update\_\-size\_\-of\_\-parent\_\-node@{force\_\-update\_\-size\_\-of\_\-parent\_\-node}!proto.h@{proto.h}}
\subsubsection[{force\_\-update\_\-size\_\-of\_\-parent\_\-node}]{\setlength{\rightskip}{0pt plus 5cm}void force\_\-update\_\-size\_\-of\_\-parent\_\-node (
\begin{DoxyParamCaption}
\item[{int}]{ no}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a207b80df2a123bc29295a0d496186d70}
\hypertarget{proto_8h_a99877ff0dc6228eabf8f959569f2771e}{
\index{proto.h@{proto.h}!free\_\-memory@{free\_\-memory}}
\index{free\_\-memory@{free\_\-memory}!proto.h@{proto.h}}
\subsubsection[{free\_\-memory}]{\setlength{\rightskip}{0pt plus 5cm}void free\_\-memory (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a99877ff0dc6228eabf8f959569f2771e}
This routine frees the memory for the particle storage. Note: We don't actually bother to call it in the code... When the program terminats, the memory will be automatically freed by the operating system. 

Definition at line 144 of file allocate.c.



References All, global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MaxPartSph, P, and SphP.




\begin{DoxyCode}
{
  if(All.MaxPartSph > 0)
    free(SphP);

  if(All.MaxPart > 0)
    free(P);
}
\end{DoxyCode}


\hypertarget{proto_8h_a49492470fcccf9d05bf51993f281f16c}{
\index{proto.h@{proto.h}!get\_\-bytes\_\-per\_\-blockelement@{get\_\-bytes\_\-per\_\-blockelement}}
\index{get\_\-bytes\_\-per\_\-blockelement@{get\_\-bytes\_\-per\_\-blockelement}!proto.h@{proto.h}}
\subsubsection[{get\_\-bytes\_\-per\_\-blockelement}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-bytes\_\-per\_\-blockelement (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a49492470fcccf9d05bf51993f281f16c}
This function tells the size of one data entry in each of the blocks defined for the output file. If one wants to add a new output-\/block, this function should be augmented accordingly. 

Definition at line 366 of file io.c.



References IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, and IO\_\-VEL.



Referenced by read\_\-file(), and write\_\-file().




\begin{DoxyCode}
{
  int bytes_per_blockelement = 0;

  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
      bytes_per_blockelement = 3 * sizeof(float);
      break;

    case IO_ID:
#ifdef LONGIDS
      bytes_per_blockelement = sizeof(long long);
#else
      bytes_per_blockelement = sizeof(int);
#endif
      break;

    case IO_MASS:
    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_POT:
    case IO_DTENTR:
    case IO_TSTP:
      bytes_per_blockelement = sizeof(float);
      break;
    }

  return bytes_per_blockelement;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a49492470fcccf9d05bf51993f281f16c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4d30ce1aad9c69d5af676a6a13173686}{
\index{proto.h@{proto.h}!get\_\-dataset\_\-name@{get\_\-dataset\_\-name}}
\index{get\_\-dataset\_\-name@{get\_\-dataset\_\-name}!proto.h@{proto.h}}
\subsubsection[{get\_\-dataset\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}void get\_\-dataset\_\-name (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr, }
\item[{char $\ast$}]{ buf}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a4d30ce1aad9c69d5af676a6a13173686}
This function returns a descriptive character string that describes the name of the block when the HDF5 file format is used. If one wants to add a new output-\/block, this function should be augmented accordingly. 

Definition at line 613 of file io.c.



References IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, and IO\_\-VEL.



Referenced by read\_\-file(), and write\_\-file().




\begin{DoxyCode}
{

  strcpy(buf, "default");

  switch (blocknr)
    {
    case IO_POS:
      strcpy(buf, "Coordinates");
      break;
    case IO_VEL:
      strcpy(buf, "Velocities");
      break;
    case IO_ID:
      strcpy(buf, "ParticleIDs");
      break;
    case IO_MASS:
      strcpy(buf, "Masses");
      break;
    case IO_U:
      strcpy(buf, "InternalEnergy");
      break;
    case IO_RHO:
      strcpy(buf, "Density");
      break;
    case IO_HSML:
      strcpy(buf, "SmoothingLength");
      break;
    case IO_POT:
      strcpy(buf, "Potential");
      break;
    case IO_ACCEL:
      strcpy(buf, "Acceleration");
      break;
    case IO_DTENTR:
      strcpy(buf, "RateOfChangeOfEntropy");
      break;
    case IO_TSTP:
      strcpy(buf, "TimeStep");
      break;
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a4d30ce1aad9c69d5af676a6a13173686_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_acdf59daa02f065452a596cf88b4de1a1}{
\index{proto.h@{proto.h}!get\_\-datatype\_\-in\_\-block@{get\_\-datatype\_\-in\_\-block}}
\index{get\_\-datatype\_\-in\_\-block@{get\_\-datatype\_\-in\_\-block}!proto.h@{proto.h}}
\subsubsection[{get\_\-datatype\_\-in\_\-block}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-datatype\_\-in\_\-block (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_acdf59daa02f065452a596cf88b4de1a1}
This function returns the type of the data contained in a given block of the output file. If one wants to add a new output-\/block, this function should be augmented accordingly. 

Definition at line 405 of file io.c.



References IO\_\-ID.



Referenced by read\_\-file(), and write\_\-file().




\begin{DoxyCode}
{
  int typekey;

  switch (blocknr)
    {
    case IO_ID:
#ifdef LONGIDS
      typekey = 2;              /* native long long */
#else
      typekey = 0;              /* native int */
#endif
      break;

    default:
      typekey = 1;              /* native float */
      break;
    }

  return typekey;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_acdf59daa02f065452a596cf88b4de1a1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_adadb384299eb936596574417d4b6b28c}{
\index{proto.h@{proto.h}!get\_\-drift\_\-factor@{get\_\-drift\_\-factor}}
\index{get\_\-drift\_\-factor@{get\_\-drift\_\-factor}!proto.h@{proto.h}}
\subsubsection[{get\_\-drift\_\-factor}]{\setlength{\rightskip}{0pt plus 5cm}double get\_\-drift\_\-factor (
\begin{DoxyParamCaption}
\item[{int}]{ time0, }
\item[{int}]{ time1}
\end{DoxyParamCaption}
)}}
\label{proto_8h_adadb384299eb936596574417d4b6b28c}
This function integrates the cosmological prefactor for a drift step between time0 and time1. The value returned is $\ast$ \[ \int_{a_0}^{a_1} \frac{{\rm d}a}{H(a)} * \] 

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 



Definition at line 67 of file driftfac.c.



References All, DRIFT\_\-TABLE\_\-LENGTH, DriftTable, logTimeBegin, logTimeMax, and global\_\-data\_\-all\_\-processes::Timebase\_\-interval.



Referenced by move\_\-particles().




\begin{DoxyCode}
{
  double a1, a2, df1, df2, u1, u2;
  int i1, i2;

  /* note: will only be called for cosmological integration */

  a1 = logTimeBegin + time0 * All.Timebase_interval;
  a2 = logTimeBegin + time1 * All.Timebase_interval;

  u1 = (a1 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i1 = (int) u1;
  if(i1 >= DRIFT_TABLE_LENGTH)
    i1 = DRIFT_TABLE_LENGTH - 1;

  if(i1 <= 1)
    df1 = u1 * DriftTable[0];
  else
    df1 = DriftTable[i1 - 1] + (DriftTable[i1] - DriftTable[i1 - 1]) * (u1 - i1);
      


  u2 = (a2 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i2 = (int) u2;
  if(i2 >= DRIFT_TABLE_LENGTH)
    i2 = DRIFT_TABLE_LENGTH - 1;

  if(i2 <= 1)
    df2 = u2 * DriftTable[0];
  else
    df2 = DriftTable[i2 - 1] + (DriftTable[i2] - DriftTable[i2 - 1]) * (u2 - i2);
      

  return df2 - df1;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_adadb384299eb936596574417d4b6b28c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a29057b821b850ab54b318d7339633059}{
\index{proto.h@{proto.h}!get\_\-gravkick\_\-factor@{get\_\-gravkick\_\-factor}}
\index{get\_\-gravkick\_\-factor@{get\_\-gravkick\_\-factor}!proto.h@{proto.h}}
\subsubsection[{get\_\-gravkick\_\-factor}]{\setlength{\rightskip}{0pt plus 5cm}double get\_\-gravkick\_\-factor (
\begin{DoxyParamCaption}
\item[{int}]{ time0, }
\item[{int}]{ time1}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a29057b821b850ab54b318d7339633059}
This function integrates the cosmological prefactor for a kick step of the gravitational force. 

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 



Definition at line 105 of file driftfac.c.



References All, DRIFT\_\-TABLE\_\-LENGTH, GravKickTable, logTimeBegin, logTimeMax, and global\_\-data\_\-all\_\-processes::Timebase\_\-interval.



Referenced by advance\_\-and\_\-find\_\-timesteps(), compute\_\-global\_\-quantities\_\-of\_\-system(), fill\_\-write\_\-buffer(), and move\_\-particles().




\begin{DoxyCode}
{
  double a1, a2, df1, df2, u1, u2;
  int i1, i2;

  /* note: will only be called for cosmological integration */

  a1 = logTimeBegin + time0 * All.Timebase_interval;
  a2 = logTimeBegin + time1 * All.Timebase_interval;

  u1 = (a1 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i1 = (int) u1;
  if(i1 >= DRIFT_TABLE_LENGTH)
    i1 = DRIFT_TABLE_LENGTH - 1;

  if(i1 <= 1)
    df1 = u1 * GravKickTable[0];
  else
    df1 = GravKickTable[i1 - 1] + (GravKickTable[i1] - GravKickTable[i1 - 1]) * (
      u1 - i1);


  u2 = (a2 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i2 = (int) u2;
  if(i2 >= DRIFT_TABLE_LENGTH)
    i2 = DRIFT_TABLE_LENGTH - 1;

  if(i2 <= 1)
    df2 = u2 * GravKickTable[0];
  else
    df2 = GravKickTable[i2 - 1] + (GravKickTable[i2] - GravKickTable[i2 - 1]) * (
      u2 - i2);

  return df2 - df1;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a29057b821b850ab54b318d7339633059_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ace65dca1556185b12c7f22427724c90c}{
\index{proto.h@{proto.h}!get\_\-hydrokick\_\-factor@{get\_\-hydrokick\_\-factor}}
\index{get\_\-hydrokick\_\-factor@{get\_\-hydrokick\_\-factor}!proto.h@{proto.h}}
\subsubsection[{get\_\-hydrokick\_\-factor}]{\setlength{\rightskip}{0pt plus 5cm}double get\_\-hydrokick\_\-factor (
\begin{DoxyParamCaption}
\item[{int}]{ time0, }
\item[{int}]{ time1}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ace65dca1556185b12c7f22427724c90c}
This function integrates the cosmological prefactor for a kick step of the hydrodynamical force. 

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 



Definition at line 142 of file driftfac.c.



References All, DRIFT\_\-TABLE\_\-LENGTH, HydroKickTable, logTimeBegin, logTimeMax, and global\_\-data\_\-all\_\-processes::Timebase\_\-interval.



Referenced by advance\_\-and\_\-find\_\-timesteps(), compute\_\-global\_\-quantities\_\-of\_\-system(), fill\_\-write\_\-buffer(), and move\_\-particles().




\begin{DoxyCode}
{
  double a1, a2, df1, df2, u1, u2;
  int i1, i2;

  /* note: will only be called for cosmological integration */

  a1 = logTimeBegin + time0 * All.Timebase_interval;
  a2 = logTimeBegin + time1 * All.Timebase_interval;

  u1 = (a1 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i1 = (int) u1;
  if(i1 >= DRIFT_TABLE_LENGTH)
    i1 = DRIFT_TABLE_LENGTH - 1;

  if(i1 <= 1)
    df1 = u1 * HydroKickTable[0];
  else
    df1 = HydroKickTable[i1 - 1] + (HydroKickTable[i1] - HydroKickTable[i1 - 1]) 
      * (u1 - i1);


  u2 = (a2 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i2 = (int) u2;
  if(i2 >= DRIFT_TABLE_LENGTH)
    i2 = DRIFT_TABLE_LENGTH - 1;

  if(i2 <= 1)
    df2 = u2 * HydroKickTable[0];
  else
    df2 = HydroKickTable[i2 - 1] + (HydroKickTable[i2] - HydroKickTable[i2 - 1]) 
      * (u2 - i2);

  return df2 - df1;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ace65dca1556185b12c7f22427724c90c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9}{
\index{proto.h@{proto.h}!get\_\-particles\_\-in\_\-block@{get\_\-particles\_\-in\_\-block}}
\index{get\_\-particles\_\-in\_\-block@{get\_\-particles\_\-in\_\-block}!proto.h@{proto.h}}
\subsubsection[{get\_\-particles\_\-in\_\-block}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-particles\_\-in\_\-block (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr, }
\item[{int $\ast$}]{ typelist}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9}
This function determines how many particles there are in a given block, based on the information in the header-\/structure. It also flags particle types that are present in the block in the typelist array. If one wants to add a new output-\/block, this function should be augmented accordingly. 

Definition at line 465 of file io.c.



References All, endrun(), header, IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, IO\_\-VEL, global\_\-data\_\-all\_\-processes::MassTable, and io\_\-header::npart.



Referenced by read\_\-file(), and write\_\-file().




\begin{DoxyCode}
{
  int i, nall, ntot_withmasses, ngas, nstars;

  nall = 0;
  ntot_withmasses = 0;

  for(i = 0; i < 6; i++)
    {
      typelist[i] = 0;

      if(header.npart[i] > 0)
        {
          nall += header.npart[i];
          typelist[i] = 1;
        }

      if(All.MassTable[i] == 0)
        ntot_withmasses += header.npart[i];
    }

  ngas = header.npart[0];
  nstars = header.npart[4];


  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
    case IO_TSTP:
    case IO_ID:
    case IO_POT:
      return nall;
      break;

    case IO_MASS:
      for(i = 0; i < 6; i++)
        {
          typelist[i] = 0;
          if(All.MassTable[i] == 0 && header.npart[i] > 0)
            typelist[i] = 1;
        }
      return ntot_withmasses;
      break;

    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_DTENTR:
      for(i = 1; i < 6; i++)
        typelist[i] = 0;
      return ngas;
      break;
    }

  endrun(212);
  return 0;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05}{
\index{proto.h@{proto.h}!get\_\-random\_\-number@{get\_\-random\_\-number}}
\index{get\_\-random\_\-number@{get\_\-random\_\-number}!proto.h@{proto.h}}
\subsubsection[{get\_\-random\_\-number}]{\setlength{\rightskip}{0pt plus 5cm}double get\_\-random\_\-number (
\begin{DoxyParamCaption}
\item[{int}]{ id}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05}
This routine returns a random number taken from a table of random numbers, which is refilled every timestep. This method is used to allow random number application to particles independent of the number of processors used, and independent of the particular order the particles have. In order to work properly, the particle IDs should be set properly to unique integer values. 

$<$ gives the length of a table with random numbers, refreshed at every timestep. This is used to allow application of random numbers to a specific particle in a way that is independent of the number of processors used. 



Definition at line 29 of file system.c.



References RndTable.



Referenced by advance\_\-and\_\-find\_\-timesteps(), force\_\-treebuild\_\-single(), force\_\-treeevaluate(), force\_\-treeevaluate\_\-shortrange(), gravity\_\-forcetest(), and init().




\begin{DoxyCode}
{
  return RndTable[(id % RNDTABLE)];
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8}{
\index{proto.h@{proto.h}!get\_\-timestep@{get\_\-timestep}}
\index{get\_\-timestep@{get\_\-timestep}!proto.h@{proto.h}}
\subsubsection[{get\_\-timestep}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-timestep (
\begin{DoxyParamCaption}
\item[{int}]{ p, }
\item[{double $\ast$}]{ aphys, }
\item[{int}]{ flag}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8}
This function normally (for flag==0) returns the maximum allowed timestep of a particle, expressed in terms of the integer mapping that is used to represent the total simulated timespan. The physical acceleration is returned in `aphys'. The latter is used in conjunction with the PSEUDOSYMMETRIC integration option, which also makes of the second function of get\_\-timestep. When it is called with a finite timestep for flag, it returns the physical acceleration that would lead to this timestep, assuming timestep criterion 0. 

$<$ adiabatic index of simulated gas

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 


\begin{DoxyParams}{Parameters}
\item[{\em p}]particle index \item[{\em aphys}]acceleration (physical units) \item[{\em flag}]either 0 for normal operation, or finite timestep to get corresponding aphys \end{DoxyParams}


Definition at line 423 of file timestep.c.



References All, atime, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CourantFac, dt\_\-displacement, endrun(), global\_\-data\_\-all\_\-processes::ErrTolIntAccuracy, fac1, fac2, fac3, GAMMA, particle\_\-data::GravAccel, particle\_\-data::GravPM, sph\_\-particle\_\-data::Hsml, hubble\_\-a, sph\_\-particle\_\-data::HydroAccel, sph\_\-particle\_\-data::MaxSignalVel, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, global\_\-data\_\-all\_\-processes::MinSizeTimestep, P, particle\_\-data::Pos, global\_\-data\_\-all\_\-processes::SofteningTable, SphP, ThisTask, global\_\-data\_\-all\_\-processes::Time, TIMEBASE, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, particle\_\-data::Type, and global\_\-data\_\-all\_\-processes::TypeOfTimestepCriterion.



Referenced by advance\_\-and\_\-find\_\-timesteps().




\begin{DoxyCode}
{
  double ax, ay, az, ac, csnd;
  double dt = 0, dt_courant = 0, dt_accel;
  int ti_step;

#ifdef CONDUCTION
  double dt_cond;
#endif

  if(flag == 0)
    {
      ax = fac1 * P[p].GravAccel[0];
      ay = fac1 * P[p].GravAccel[1];
      az = fac1 * P[p].GravAccel[2];

#ifdef PMGRID
      ax += fac1 * P[p].GravPM[0];
      ay += fac1 * P[p].GravPM[1];
      az += fac1 * P[p].GravPM[2];
#endif

      if(P[p].Type == 0)
        {
          ax += fac2 * SphP[p].HydroAccel[0];
          ay += fac2 * SphP[p].HydroAccel[1];
          az += fac2 * SphP[p].HydroAccel[2];
        }

      ac = sqrt(ax * ax + ay * ay + az * az);   /* this is now the physical accel
      eration */
      *aphys = ac;
    }
  else
    ac = *aphys;

  if(ac == 0)
    ac = 1.0e-30;

  switch (All.TypeOfTimestepCriterion)
    {
    case 0:
      if(flag > 0)
        {
          dt = flag * All.Timebase_interval;
          dt /= hubble_a;       /* convert dloga to physical timestep  */
          ac = 2 * All.ErrTolIntAccuracy * atime * All.SofteningTable[P[p].Type] 
      / (dt * dt);
          *aphys = ac;
          return flag;
        }
      dt = dt_accel = sqrt(2 * All.ErrTolIntAccuracy * atime * All.
      SofteningTable[P[p].Type] / ac);
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(P[p].Type == 0)
        dt = dt_accel = sqrt(2 * All.ErrTolIntAccuracy * atime * SphP[p].Hsml / 2
      .8 / ac);
#endif
      break;
    default:
      endrun(888);
      break;
    }

  if(P[p].Type == 0)
    {
      csnd = sqrt(GAMMA * SphP[p].Pressure / SphP[p].Density);

      if(All.ComovingIntegrationOn)
        dt_courant = 2 * All.CourantFac * All.Time * SphP[p].Hsml / (fac3 * SphP[
      p].MaxSignalVel);
      else
        dt_courant = 2 * All.CourantFac * SphP[p].Hsml / SphP[p].MaxSignalVel;

      if(dt_courant < dt)
        dt = dt_courant;
    }

  /* convert the physical timestep to dloga if needed. Note: If comoving integrat
      ion has not been selected,
     hubble_a=1.
   */
  dt *= hubble_a;

  if(dt >= All.MaxSizeTimestep)
    dt = All.MaxSizeTimestep;

  if(dt >= dt_displacement)
    dt = dt_displacement;

  if(dt < All.MinSizeTimestep)
    {
#ifndef NOSTOP_WHEN_BELOW_MINTIMESTEP
      printf("warning: Timestep wants to be below the limit `MinSizeTimestep'\n")
      ;

      if(P[p].Type == 0)
        {
          printf
            ("Part-ID=%d  dt=%g dtc=%g ac=%g xyz=(%g|%g|%g)  hsml=%g  maxsignalve
      l=%g dt0=%g eps=%g\n",
             (int) P[p].ID, dt, dt_courant * hubble_a, ac, P[p].Pos[0], P[p].Pos[
      1], P[p].Pos[2],
             SphP[p].Hsml, SphP[p].MaxSignalVel,
             sqrt(2 * All.ErrTolIntAccuracy * atime * All.SofteningTable[P[p].
      Type] / ac) * hubble_a,
             All.SofteningTable[P[p].Type]);
        }
      else
        {
          printf("Part-ID=%d  dt=%g ac=%g xyz=(%g|%g|%g)\n", (int) P[p].ID, dt, a
      c, P[p].Pos[0], P[p].Pos[1],
                 P[p].Pos[2]);
        }
      fflush(stdout);
      endrun(888);
#endif
      dt = All.MinSizeTimestep;
    }

  ti_step = dt / All.Timebase_interval;

  if(!(ti_step > 0 && ti_step < TIMEBASE))
    {
      printf("\nError: A timestep of size zero was assigned on the integer timeli
      ne!\n"
             "We better stop.\n"
             "Task=%d Part-ID=%d dt=%g tibase=%g ti_step=%d ac=%g xyz=(%g|%g|%g) 
      tree=(%g|%g%g)\n\n",
             ThisTask, (int) P[p].ID, dt, All.Timebase_interval, ti_step, ac,
             P[p].Pos[0], P[p].Pos[1], P[p].Pos[2], P[p].GravAccel[0], P[p].
      GravAccel[1], P[p].GravAccel[2]);
#ifdef PMGRID
      printf("pm_force=(%g|%g|%g)\n", P[p].GravPM[0], P[p].GravPM[1], P[p].GravPM
      [2]);
#endif
      if(P[p].Type == 0)
        printf("hydro-frc=(%g|%g|%g)\n", SphP[p].HydroAccel[0], SphP[p].HydroAcce
      l[1], SphP[p].HydroAccel[2]);

      fflush(stdout);
      endrun(818);
    }

  return ti_step;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a3892776d6528c51f720d2a48deb2486f}{
\index{proto.h@{proto.h}!get\_\-values\_\-per\_\-blockelement@{get\_\-values\_\-per\_\-blockelement}}
\index{get\_\-values\_\-per\_\-blockelement@{get\_\-values\_\-per\_\-blockelement}!proto.h@{proto.h}}
\subsubsection[{get\_\-values\_\-per\_\-blockelement}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-values\_\-per\_\-blockelement (
\begin{DoxyParamCaption}
\item[{enum {\bf iofields}}]{ blocknr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a3892776d6528c51f720d2a48deb2486f}
This function informs about the number of elements stored per particle for the given block of the output file. If one wants to add a new output-\/block, this function should be augmented accordingly. 

Definition at line 432 of file io.c.



References IO\_\-ACCEL, IO\_\-DTENTR, IO\_\-HSML, IO\_\-ID, IO\_\-MASS, IO\_\-POS, IO\_\-POT, IO\_\-RHO, IO\_\-TSTP, IO\_\-U, and IO\_\-VEL.



Referenced by read\_\-file(), and write\_\-file().




\begin{DoxyCode}
{
  int values = 0;

  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
      values = 3;
      break;

    case IO_ID:
    case IO_MASS:
    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_POT:
    case IO_DTENTR:
    case IO_TSTP:
      values = 1;
      break;
    }

  return values;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a3892776d6528c51f720d2a48deb2486f_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae9c157451dcc4cdbe02813141df2be42}{
\index{proto.h@{proto.h}!grav\_\-tree\_\-compare\_\-key@{grav\_\-tree\_\-compare\_\-key}}
\index{grav\_\-tree\_\-compare\_\-key@{grav\_\-tree\_\-compare\_\-key}!proto.h@{proto.h}}
\subsubsection[{grav\_\-tree\_\-compare\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int grav\_\-tree\_\-compare\_\-key (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ae9c157451dcc4cdbe02813141df2be42}
This function is used as a comparison kernel in a sort routine. It is used to group particles in the communication buffer that are going to be sent to the same CPU. 

Definition at line 522 of file gravtree.c.



Referenced by compute\_\-potential(), gravity\_\-forcetest(), and gravity\_\-tree().




\begin{DoxyCode}
{
  if(((struct gravdata_index *) a)->Task < (((struct gravdata_index *) b)->Task))
      
    return -1;

  if(((struct gravdata_index *) a)->Task > (((struct gravdata_index *) b)->Task))
      
    return +1;

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae9c157451dcc4cdbe02813141df2be42_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79}{
\index{proto.h@{proto.h}!gravity\_\-forcetest@{gravity\_\-forcetest}}
\index{gravity\_\-forcetest@{gravity\_\-forcetest}!proto.h@{proto.h}}
\subsubsection[{gravity\_\-forcetest}]{\setlength{\rightskip}{0pt plus 5cm}void gravity\_\-forcetest (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79}
This routine does the test of the gravitational tree force by computing the force for a random subset of particles with direct summation. 

Definition at line 28 of file gravtree\_\-forcetest.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BunchSizeForce, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, endrun(), Exportflag, fac1, FdForceTest, FdTimings, force\_\-treeevaluate\_\-direct(), global\_\-data\_\-all\_\-processes::G, get\_\-random\_\-number(), grav\_\-tree\_\-compare\_\-key(), particle\_\-data::GravAccel, particle\_\-data::GravAccelDirect, GravDataGet, GravDataIn, GravDataIndexTable, GravDataOut, GravDataResult, particle\_\-data::GravPM, global\_\-data\_\-all\_\-processes::Hubble, gravdata\_\-index::Index, NTask, NumForceUpdate, NumPart, particle\_\-data::OldAcc, gravdata\_\-in::OldAcc, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, global\_\-data\_\-all\_\-processes::OutputDir, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, particle\_\-data::Pos, gravdata\_\-in::Pos, PTask, second(), set\_\-softenings(), gravdata\_\-index::SortIndex, TAG\_\-DIRECT\_\-A, TAG\_\-DIRECT\_\-B, gravdata\_\-index::Task, ThisTask, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, timediff(), TimeOfLastTreeConstruction, global\_\-data\_\-all\_\-processes::TotNumPart, particle\_\-data::Type, and gravdata\_\-in::w.



Referenced by compute\_\-accelerations().




\begin{DoxyCode}
{
  int ntot, iter = 0, ntotleft, nthis;
  double tstart, tend, timetree = 0;
  int i, j, ndone, ngrp, maxfill, place, ndonetot;

#ifndef NOGRAVITY
  int *noffset, *nbuffer, *nsend, *nsend_local;
  int k, nexport;
  int level, sendTask, recvTask;
  double fac1;
  MPI_Status status;
#endif
  double costtotal, *costtreelist;
  double maxt, sumt, *timetreelist;
  double fac;
  char buf[200];

#ifdef PMGRID
  if(All.PM_Ti_endstep != All.Ti_Current)
    return;
#endif

  if(All.ComovingIntegrationOn)
    set_softenings();           /* set new softening lengths */

  for(i = 0, NumForceUpdate = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          if(get_random_number(P[i].ID) < FORCETEST)
            {
              P[i].Ti_endstep = -P[i].Ti_endstep - 1;
              NumForceUpdate++;
            }
        }
    }

  /* NumForceUpdate is the number of particles on this processor that want a forc
      e update */

  MPI_Allreduce(&NumForceUpdate, &ntot, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  costtotal = 0;

  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common l
      ist */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);

  i = 0;                        /* beginn with this index */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      iter++;

      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      tstart = second();
      for(nexport = 0, ndone = 0; i < NumPart && nexport < All.BunchSizeForce - N
      Task; i++)
        if(P[i].Ti_endstep < 0)
          {
            ndone++;

            for(j = 0; j < NTask; j++)
              Exportflag[j] = 1;
            Exportflag[ThisTask] = 0;

            costtotal += force_treeevaluate_direct(i, 0);

            for(j = 0; j < NTask; j++)
              {
                if(Exportflag[j])
                  {
                    for(k = 0; k < 3; k++)
                      GravDataGet[nexport].u.Pos[k] = P[i].Pos[k];

#ifdef UNEQUALSOFTENINGS
                    GravDataGet[nexport].Type = P[i].Type;
#endif
                    GravDataGet[nexport].w.OldAcc = P[i].OldAcc;

                    GravDataIndexTable[nexport].Task = j;
                    GravDataIndexTable[nexport].Index = i;
                    GravDataIndexTable[nexport].SortIndex = nexport;

                    nexport++;
                    nsend_local[j]++;
                  }
              }
          }
      tend = second();
      timetree += timediff(tstart, tend);

      qsort(GravDataIndexTable, nexport, sizeof(struct gravdata_index), 
      grav_tree_compare_key);

      for(j = 0; j < nexport; j++)
        GravDataIn[j] = GravDataGet[GravDataIndexTable[j].SortIndex];

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, MPI_COMM_
      WORLD);

      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&GravDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in), MPI_BYTE,
                                   recvTask, TAG_DIRECT_A,
                                   &GravDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct gravdata_in), MPI_BYTE,
                                   recvTask, TAG_DIRECT_A, MPI_COMM_WORLD, &statu
      s);
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          tstart = second();
          for(j = 0; j < nbuffer[ThisTask]; j++)
            {
              costtotal += force_treeevaluate_direct(j, 1);
            }
          tend = second();
          timetree += timediff(tstart, tend);


          /* get the result */
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;
              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&GravDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct gravdata_in),
                                   MPI_BYTE, recvTask, TAG_DIRECT_B,
                                   &GravDataOut[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in),
                                   MPI_BYTE, recvTask, TAG_DIRECT_B, MPI_COMM_WOR
      LD, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          place = GravDataIndexTable[noffset[recvTask] + j].
      Index;

                          for(k = 0; k < 3; k++)
                            P[place].GravAccelDirect[k] += GravDataOut[j + noffse
      t[recvTask]].u.Acc[k];
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          level = ngrp - 1;
        }

      MPI_Allreduce(&ndone, &ndonetot, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

      ntotleft -= ndonetot;
    }

  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* now add things for comoving integration */

  if(All.ComovingIntegrationOn)
    {
#ifndef PERIODIC
      fac1 = 0.5 * All.Hubble * All.Hubble * All.Omega0 / All.G;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep < 0)
          for(j = 0; j < 3; j++)
            P[i].GravAccelDirect[j] += fac1 * P[i].Pos[j];
#endif
    }



  /*  muliply by G */

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      for(j = 0; j < 3; j++)
        P[i].GravAccelDirect[j] *= All.G;



  /* Finally, the following factor allows a computation of cosmological simulatio
      n 
     with vacuum energy in physical coordinates */

  if(All.ComovingIntegrationOn == 0)
    {
      fac1 = All.OmegaLambda * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep < 0)
          for(j = 0; j < 3; j++)
            P[i].GravAccelDirect[j] += fac1 * P[i].Pos[j];
    }

  /* now output the forces to a file */

  for(nthis = 0; nthis < NTask; nthis++)
    {
      if(nthis == ThisTask)
        {
          sprintf(buf, "%s%s", All.OutputDir, "forcetest.txt");
          if(!(FdForceTest = fopen(buf, "a")))
            {
              printf("error in opening file '%s'\n", buf);
              endrun(17);
            }
          for(i = 0; i < NumPart; i++)
            if(P[i].Ti_endstep < 0)
              {
#ifndef PMGRID
                fprintf(FdForceTest, "%d %g %g %g %g %g %g %g %g %g %g %g\n",
                        P[i].Type, All.Time, All.Time - 
      TimeOfLastTreeConstruction,
                        P[i].Pos[0], P[i].Pos[1], P[i].Pos[2],
                        P[i].GravAccelDirect[0], P[i].GravAccelDirect[1], P[i].
      GravAccelDirect[2],
                        P[i].GravAccel[0], P[i].GravAccel[1], P[i].GravAccel[2]);
      
#else
                fprintf(FdForceTest, "%d %g %g %g %g %g %g %g %g %g %g %g %g %g %
      g\n",
                        P[i].Type, All.Time, All.Time - 
      TimeOfLastTreeConstruction,
                        P[i].Pos[0], P[i].Pos[1], P[i].Pos[2],
                        P[i].GravAccelDirect[0], P[i].GravAccelDirect[1], P[i].
      GravAccelDirect[2],
                        P[i].GravAccel[0], P[i].GravAccel[1], P[i].GravAccel[2],
                        P[i].GravPM[0] + P[i].GravAccel[0],
                        P[i].GravPM[1] + P[i].GravAccel[1], P[i].GravPM[2] + P[i]
      .GravAccel[2]);
#endif
              }
          fclose(FdForceTest);
        }
      MPI_Barrier(MPI_COMM_WORLD);
    }

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;

  /* Now the force computation is finished */



  timetreelist = malloc(sizeof(double) * NTask);
  costtreelist = malloc(sizeof(double) * NTask);

  MPI_Gather(&costtotal, 1, MPI_DOUBLE, costtreelist, 1, MPI_DOUBLE, 0, MPI_COMM_
      WORLD);
  MPI_Gather(&timetree, 1, MPI_DOUBLE, timetreelist, 1, MPI_DOUBLE, 0, MPI_COMM_W
      ORLD);

  if(ThisTask == 0)
    {
      fac = NTask / ((double) All.TotNumPart);

      for(i = 0, maxt = timetreelist[0], sumt = 0, costtotal = 0; i < NTask; i++)
      
        {
          costtotal += costtreelist[i];

          if(maxt < timetreelist[i])
            maxt = timetreelist[i];
          sumt += timetreelist[i];
        }

      fprintf(FdTimings, "DIRECT Nf= %d    part/sec=%g | %g  ia/part=%g \n", ntot
      , ntot / (sumt + 1.0e-20),
              ntot / (maxt * NTask), ((double) (costtotal)) / ntot);
      fprintf(FdTimings, "\n");

      fflush(FdTimings);
    }

  free(costtreelist);
  free(timetreelist);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac559dc2aeb21d5a379a3751bea7736af}{
\index{proto.h@{proto.h}!gravity\_\-tree@{gravity\_\-tree}}
\index{gravity\_\-tree@{gravity\_\-tree}!proto.h@{proto.h}}
\subsubsection[{gravity\_\-tree}]{\setlength{\rightskip}{0pt plus 5cm}void gravity\_\-tree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ac559dc2aeb21d5a379a3751bea7736af}
This function computes the gravitational forces for all active particles. If needed, a new tree is constructed, otherwise the dynamically updated tree is used. Particles are only exported to other processors when really needed, thereby allowing a good use of the communication buffer. 

Definition at line 27 of file gravtree.c.



References gravdata\_\-in::Acc, All, global\_\-data\_\-all\_\-processes::BunchSizeForce, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-CommSum, global\_\-data\_\-all\_\-processes::CPU\_\-Imbalance, global\_\-data\_\-all\_\-processes::CPU\_\-TreeConstruction, global\_\-data\_\-all\_\-processes::CPU\_\-TreeWalk, global\_\-data\_\-all\_\-processes::ErrTolTheta, Exportflag, FdTimings, force\_\-treebuild(), force\_\-treeevaluate(), force\_\-treeevaluate\_\-shortrange(), global\_\-data\_\-all\_\-processes::G, grav\_\-tree\_\-compare\_\-key(), particle\_\-data::GravAccel, particle\_\-data::GravCost, GravDataGet, GravDataIn, GravDataIndexTable, GravDataOut, GravDataResult, particle\_\-data::GravPM, sph\_\-particle\_\-data::Hsml, global\_\-data\_\-all\_\-processes::Hubble, particle\_\-data::ID, gravdata\_\-index::Index, global\_\-data\_\-all\_\-processes::MaxPart, gravdata\_\-in::Ninteractions, NTask, global\_\-data\_\-all\_\-processes::NumCurrentTiStep, NumForceUpdate, Numnodestree, NumPart, particle\_\-data::OldAcc, gravdata\_\-in::OldAcc, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, P, particle\_\-data::Pos, gravdata\_\-in::Pos, PTask, second(), set\_\-softenings(), gravdata\_\-index::SortIndex, SphP, TAG\_\-GRAV\_\-A, TAG\_\-GRAV\_\-B, gravdata\_\-index::Task, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, timediff(), global\_\-data\_\-all\_\-processes::TimeStep, global\_\-data\_\-all\_\-processes::TotNumOfForces, global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeAllocFactor, TreeReconstructFlag, particle\_\-data::Type, global\_\-data\_\-all\_\-processes::TypeOfOpeningCriterion, gravdata\_\-in::u, particle\_\-data::Vel, and gravdata\_\-in::w.



Referenced by compute\_\-accelerations().




\begin{DoxyCode}
{
  long long ntot;
  int numnodes, nexportsum = 0;
  int i, j, iter = 0;
  int *numnodeslist, maxnumnodes, nexport, *numlist, *nrecv, *ndonelist;
  double tstart, tend, timetree = 0, timecommsumm = 0, timeimbalance = 0, sumimba
      lance;
  double ewaldcount;
  double costtotal, ewaldtot, *costtreelist, *ewaldlist;
  double maxt, sumt, *timetreelist, *timecommlist;
  double fac, plb, plb_max, sumcomm;

#ifndef NOGRAVITY
  int *noffset, *nbuffer, *nsend, *nsend_local;
  long long ntotleft;
  int ndone, maxfill, ngrp;
  int k, place;
  int level, sendTask, recvTask;
  double ax, ay, az;
  MPI_Status status;
#endif

  /* set new softening lengths */
  if(All.ComovingIntegrationOn)
    set_softenings();


  /* contruct tree if needed */
  tstart = second();
  if(TreeReconstructFlag)
    {
      if(ThisTask == 0)
        printf("Tree construction.\n");

      force_treebuild(NumPart);

      TreeReconstructFlag = 0;

      if(ThisTask == 0)
        printf("Tree construction done.\n");
    }
  tend = second();
  All.CPU_TreeConstruction += timediff(tstart, tend);

  costtotal = ewaldcount = 0;

  /* Note: 'NumForceUpdate' has already been determined in find_next_sync_point_a
      nd_drift() */
  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumForceUpdate, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD)
      ;
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);


#ifndef NOGRAVITY
  if(ThisTask == 0)
    printf("Begin tree force.\n");


#ifdef SELECTIVE_NO_GRAVITY
  for(i = 0; i < NumPart; i++)
    if(((1 << P[i].Type) & (SELECTIVE_NO_GRAVITY)))
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;
#endif


  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common l
      ist */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  i = 0;                        /* beginn with this index */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      iter++;

      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      tstart = second();
      for(nexport = 0, ndone = 0; i < NumPart && nexport < All.BunchSizeForce - N
      Task; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          {
            ndone++;

            for(j = 0; j < NTask; j++)
              Exportflag[j] = 0;
#ifndef PMGRID
            costtotal += force_treeevaluate(i, 0, &ewaldcount);
#else
            costtotal += force_treeevaluate_shortrange(i, 0);
#endif
            for(j = 0; j < NTask; j++)
              {
                if(Exportflag[j])
                  {
                    for(k = 0; k < 3; k++)
                      GravDataGet[nexport].u.Pos[k] = P[i].Pos[k];
#ifdef COMPUTE_SELFINTERACTION_FORDARK
                    for(k = 0; k < 3; k++)
                      GravDataGet[nexport].u.Vel[k] = P[i].Vel[k];               
       
                    GravDataGet[nexport].u.Ti_begstep = P[i].Ti_begstep;
                    GravDataGet[nexport].u.Ti_endstep = P[i].Ti_endstep;
                    GravDataGet[nexport].u.ID = P[i].ID;
                    GravDataGet[nexport].Type = P[i].Type;
#endif
#ifdef UNEQUALSOFTENINGS
                    GravDataGet[nexport].Type = P[i].Type;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
                    if(P[i].Type == 0)
                      GravDataGet[nexport].Soft = SphP[i].Hsml;
#endif
#endif
                    GravDataGet[nexport].w.OldAcc = P[i].OldAcc;
                    GravDataIndexTable[nexport].Task = j;
                    GravDataIndexTable[nexport].Index = i;
                    GravDataIndexTable[nexport].SortIndex = nexport;
                    nexport++;
                    nexportsum++;
                    nsend_local[j]++;
                  }
              }
          }
      tend = second();
      timetree += timediff(tstart, tend);

      qsort(GravDataIndexTable, nexport, sizeof(struct gravdata_index), 
      grav_tree_compare_key);

      for(j = 0; j < nexport; j++)
        GravDataIn[j] = GravDataGet[GravDataIndexTable[j].SortIndex];

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      tstart = second();

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, MPI_COMM_
      WORLD);

      tend = second();
      timeimbalance += timediff(tstart, tend);

      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&GravDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in), MPI_BYTE,
                                   recvTask, TAG_GRAV_A,
                                   &GravDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct gravdata_in), MPI_BYTE,
                                   recvTask, TAG_GRAV_A, MPI_COMM_WORLD, &status)
      ;
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);


          tstart = second();
          for(j = 0; j < nbuffer[ThisTask]; j++)
            {
#ifndef PMGRID
              costtotal += force_treeevaluate(j, 1, &ewaldcount);
#else
              costtotal += force_treeevaluate_shortrange(j, 1);
#endif
            }
          tend = second();
          timetree += timediff(tstart, tend);

          tstart = second();
          MPI_Barrier(MPI_COMM_WORLD);
          tend = second();
          timeimbalance += timediff(tstart, tend);

          /* get the result */
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;
              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&GravDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct gravdata_in),
                                   MPI_BYTE, recvTask, TAG_GRAV_B,
                                   &GravDataOut[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in),
                                   MPI_BYTE, recvTask, TAG_GRAV_B, MPI_COMM_WORLD
      , &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          place = GravDataIndexTable[noffset[recvTask] + j].
      Index;

                          for(k = 0; k < 3; k++)
                            P[place].GravAccel[k] += GravDataOut[j + noffset[recv
      Task]].u.Acc[k];
#ifdef COMPUTE_SELFINTERACTION_FORDARK
                          for(k = 0; k < 3; k++)
                            P[place].Vel[k] += GravDataOut[j + noffset[recvTask]]
      .u.Vel[k];
#endif
                          P[place].GravCost += GravDataOut[j + noffset[recvTask]]
      .w.Ninteractions;
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);

          level = ngrp - 1;
        }

      MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD);
      for(j = 0; j < NTask; j++)
        ntotleft -= ndonelist[j];
    }

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);

  /* now add things for comoving integration */

#ifndef PERIODIC
#ifndef PMGRID
  if(All.ComovingIntegrationOn)
    {
      fac = 0.5 * All.Hubble * All.Hubble * All.Omega0 / All.G;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          for(j = 0; j < 3; j++)
            P[i].GravAccel[j] += fac * P[i].Pos[j];
    }
#endif
#endif

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      {
#ifdef PMGRID
        ax = P[i].GravAccel[0] + P[i].GravPM[0] / All.G;
        ay = P[i].GravAccel[1] + P[i].GravPM[1] / All.G;
        az = P[i].GravAccel[2] + P[i].GravPM[2] / All.G;
#else
        ax = P[i].GravAccel[0];
        ay = P[i].GravAccel[1];
        az = P[i].GravAccel[2];
#endif
        P[i].OldAcc = sqrt(ax * ax + ay * ay + az * az);
      }


  if(All.TypeOfOpeningCriterion == 1)
    All.ErrTolTheta = 0;        /* This will switch to the relative opening crite
      rion for the following force computations */

  /*  muliply by G */
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      for(j = 0; j < 3; j++)
        P[i].GravAccel[j] *= All.G;


  /* Finally, the following factor allows a computation of a cosmological simulat
      ion 
     with vacuum energy in physical coordinates */
#ifndef PERIODIC
#ifndef PMGRID
  if(All.ComovingIntegrationOn == 0)
    {
      fac = All.OmegaLambda * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          for(j = 0; j < 3; j++)
            P[i].GravAccel[j] += fac * P[i].Pos[j];
    }
#endif
#endif

#ifdef SELECTIVE_NO_GRAVITY
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;
#endif

  if(ThisTask == 0)
    printf("tree is done.\n");

#else /* gravity is switched off */

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      for(j = 0; j < 3; j++)
        P[i].GravAccel[j] = 0;

#endif




  /* Now the force computation is finished */

  /*  gather some diagnostic information */

  timetreelist = malloc(sizeof(double) * NTask);
  timecommlist = malloc(sizeof(double) * NTask);
  costtreelist = malloc(sizeof(double) * NTask);
  numnodeslist = malloc(sizeof(int) * NTask);
  ewaldlist = malloc(sizeof(double) * NTask);
  nrecv = malloc(sizeof(int) * NTask);

  numnodes = Numnodestree;

  MPI_Gather(&costtotal, 1, MPI_DOUBLE, costtreelist, 1, MPI_DOUBLE, 0, MPI_COMM_
      WORLD);
  MPI_Gather(&numnodes, 1, MPI_INT, numnodeslist, 1, MPI_INT, 0, MPI_COMM_WORLD);
      
  MPI_Gather(&timetree, 1, MPI_DOUBLE, timetreelist, 1, MPI_DOUBLE, 0, MPI_COMM_W
      ORLD);
  MPI_Gather(&timecommsumm, 1, MPI_DOUBLE, timecommlist, 1, MPI_DOUBLE, 0, MPI_CO
      MM_WORLD);
  MPI_Gather(&NumPart, 1, MPI_INT, nrecv, 1, MPI_INT, 0, MPI_COMM_WORLD);
  MPI_Gather(&ewaldcount, 1, MPI_DOUBLE, ewaldlist, 1, MPI_DOUBLE, 0, MPI_COMM_WO
      RLD);
  MPI_Reduce(&nexportsum, &nexport, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_W
      ORLD);

  if(ThisTask == 0)
    {
      All.TotNumOfForces += ntot;

      fprintf(FdTimings, "Step= %d  t= %g  dt= %g \n", All.NumCurrentTiStep, All.
      Time, All.TimeStep);
      fprintf(FdTimings, "Nf= %d%09d  total-Nf= %d%09d  ex-frac= %g  iter= %d\n",
      
              (int) (ntot / 1000000000), (int) (ntot % 1000000000),
              (int) (All.TotNumOfForces / 1000000000), (int) (All.TotNumOfForces 
      % 1000000000),
              nexport / ((double) ntot), iter);
      /* note: on Linux, the 8-byte integer could be printed with the format iden
      tifier "%qd", but doesn't work on AIX */

      fac = NTask / ((double) All.TotNumPart);

      for(i = 0, maxt = timetreelist[0], sumt = 0, plb_max = 0,
          maxnumnodes = 0, costtotal = 0, sumcomm = 0, ewaldtot = 0; i < NTask; i
      ++)
        {
          costtotal += costtreelist[i];

          sumcomm += timecommlist[i];

          if(maxt < timetreelist[i])
            maxt = timetreelist[i];
          sumt += timetreelist[i];

          plb = nrecv[i] * fac;

          if(plb > plb_max)
            plb_max = plb;

          if(numnodeslist[i] > maxnumnodes)
            maxnumnodes = numnodeslist[i];

          ewaldtot += ewaldlist[i];
        }
      fprintf(FdTimings, "work-load balance: %g  max=%g avg=%g PE0=%g\n",
              maxt / (sumt / NTask), maxt, sumt / NTask, timetreelist[0]);
      fprintf(FdTimings, "particle-load balance: %g\n", plb_max);
      fprintf(FdTimings, "max. nodes: %d, filled: %g\n", maxnumnodes,
              maxnumnodes / (All.TreeAllocFactor * All.MaxPart));
      fprintf(FdTimings, "part/sec=%g | %g  ia/part=%g (%g)\n", ntot / (sumt + 1.
      0e-20),
              ntot / (maxt * NTask), ((double) (costtotal)) / ntot, ((double) ewa
      ldtot) / ntot);
      fprintf(FdTimings, "\n");

      fflush(FdTimings);

      All.CPU_TreeWalk += sumt / NTask;
      All.CPU_Imbalance += sumimbalance / NTask;
      All.CPU_CommSum += sumcomm / NTask;
    }

  free(nrecv);
  free(ewaldlist);
  free(numnodeslist);
  free(costtreelist);
  free(timecommlist);
  free(timetreelist);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac559dc2aeb21d5a379a3751bea7736af_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac559dc2aeb21d5a379a3751bea7736af_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a483c8f5e73b8445bbb44e3bab59f2f1d}{
\index{proto.h@{proto.h}!gravity\_\-tree\_\-shortrange@{gravity\_\-tree\_\-shortrange}}
\index{gravity\_\-tree\_\-shortrange@{gravity\_\-tree\_\-shortrange}!proto.h@{proto.h}}
\subsubsection[{gravity\_\-tree\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}void gravity\_\-tree\_\-shortrange (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a483c8f5e73b8445bbb44e3bab59f2f1d}
\hypertarget{proto_8h_a2eafe05fb12d7f9d954d5b501e186051}{
\index{proto.h@{proto.h}!gravkick\_\-integ@{gravkick\_\-integ}}
\index{gravkick\_\-integ@{gravkick\_\-integ}!proto.h@{proto.h}}
\subsubsection[{gravkick\_\-integ}]{\setlength{\rightskip}{0pt plus 5cm}double gravkick\_\-integ (
\begin{DoxyParamCaption}
\item[{double}]{ a, }
\item[{void $\ast$}]{ param}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a2eafe05fb12d7f9d954d5b501e186051}
Integration kernel for gravitational kick factor computation. 

Definition at line 191 of file driftfac.c.



References All, global\_\-data\_\-all\_\-processes::Hubble, global\_\-data\_\-all\_\-processes::Omega0, and global\_\-data\_\-all\_\-processes::OmegaLambda.




\begin{DoxyCode}
{
  double h;

  h = All.Omega0 / (a * a * a) + (1 - All.Omega0 - All.OmegaLambda) / (a * a) + 
      All.OmegaLambda;
  h = All.Hubble * sqrt(h);

  return 1 / (h * a * a);
}
\end{DoxyCode}


\hypertarget{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a}{
\index{proto.h@{proto.h}!hydro\_\-compare\_\-key@{hydro\_\-compare\_\-key}}
\index{hydro\_\-compare\_\-key@{hydro\_\-compare\_\-key}!proto.h@{proto.h}}
\subsubsection[{hydro\_\-compare\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int hydro\_\-compare\_\-key (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a}
This is a comparison kernel for a sort routine, which is used to group particles that are going to be exported to the same CPU. 

Definition at line 563 of file hydra.c.



Referenced by hydro\_\-force().




\begin{DoxyCode}
{
  if(((struct hydrodata_in *) a)->Task < (((struct hydrodata_in *) b)->Task))
    return -1;
  if(((struct hydrodata_in *) a)->Task > (((struct hydrodata_in *) b)->Task))
    return +1;
  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e}{
\index{proto.h@{proto.h}!hydro\_\-evaluate@{hydro\_\-evaluate}}
\index{hydro\_\-evaluate@{hydro\_\-evaluate}!proto.h@{proto.h}}
\subsubsection[{hydro\_\-evaluate}]{\setlength{\rightskip}{0pt plus 5cm}void hydro\_\-evaluate (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e}
This function is the 'core' of the SPH force computation. A target particle is specified which may either be local, or reside in the communication buffer. 

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 



Definition at line 353 of file hydra.c.



References All, global\_\-data\_\-all\_\-processes::ArtBulkViscConst, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, sph\_\-particle\_\-data::CurlVel, hydrodata\_\-in::Density, sph\_\-particle\_\-data::Density, hydrodata\_\-in::DhsmlDensityFactor, sph\_\-particle\_\-data::DhsmlDensityFactor, dmin(), hydrodata\_\-out::DtEntropy, sph\_\-particle\_\-data::DtEntropy, hydrodata\_\-in::F1, fac\_\-mu, fac\_\-vsic\_\-fix, FLOAT, GAMMA, hydrodata\_\-in::Hsml, sph\_\-particle\_\-data::Hsml, hubble\_\-a2, HydroDataGet, HydroDataResult, imax(), KERNEL\_\-COEFF\_\-3, KERNEL\_\-COEFF\_\-6, state\_\-of\_\-system::Mass, hydrodata\_\-in::Mass, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MaxPart, hydrodata\_\-out::MaxSignalVel, sph\_\-particle\_\-data::MaxSignalVel, ngb\_\-treefind\_\-pairs(), Ngblist, P, hydrodata\_\-in::Pos, particle\_\-data::Pos, hydrodata\_\-in::Pressure, sph\_\-particle\_\-data::Pressure, SphP, particle\_\-data::Ti\_\-begstep, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, hydrodata\_\-in::Timestep, hydrodata\_\-in::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by hydro\_\-force().




\begin{DoxyCode}
{
  int j, k, n, timestep, startnode, numngb;
  FLOAT *pos, *vel;
  FLOAT mass, h_i, dhsmlDensityFactor, rho, pressure, f1, f2;
  double acc[3], dtEntropy, maxSignalVel;
  double dx, dy, dz, dvx, dvy, dvz;
  double h_i2, hinv, hinv4;
  double p_over_rho2_i, p_over_rho2_j, soundspeed_i, soundspeed_j;
  double hfc, dwk_i, vdotr, vdotr2, visc, mu_ij, rho_ij, vsig;
  double h_j, dwk_j, r, r2, u, hfc_visc;

#ifndef NOVISCOSITYLIMITER
  double dt;
#endif

  if(mode == 0)
    {
      pos = P[target].Pos;
      vel = SphP[target].VelPred;
      h_i = SphP[target].Hsml;
      mass = P[target].Mass;
      dhsmlDensityFactor = SphP[target].DhsmlDensityFactor;
      rho = SphP[target].Density;
      pressure = SphP[target].Pressure;
      timestep = P[target].Ti_endstep - P[target].Ti_begstep;
      soundspeed_i = sqrt(GAMMA * pressure / rho);
      f1 = fabs(SphP[target].DivVel) /
        (fabs(SphP[target].DivVel) + SphP[target].CurlVel +
         0.0001 * soundspeed_i / SphP[target].Hsml / fac_mu);
    }
  else
    {
      pos = HydroDataGet[target].Pos;
      vel = HydroDataGet[target].Vel;
      h_i = HydroDataGet[target].Hsml;
      mass = HydroDataGet[target].Mass;
      dhsmlDensityFactor = HydroDataGet[target].DhsmlDensityFactor;
      rho = HydroDataGet[target].Density;
      pressure = HydroDataGet[target].Pressure;
      timestep = HydroDataGet[target].Timestep;
      soundspeed_i = sqrt(GAMMA * pressure / rho);
      f1 = HydroDataGet[target].F1;
    }


  /* initialize variables before SPH loop is started */
  acc[0] = acc[1] = acc[2] = dtEntropy = 0;
  maxSignalVel = 0;

  p_over_rho2_i = pressure / (rho * rho) * dhsmlDensityFactor;
  h_i2 = h_i * h_i;

  /* Now start the actual SPH computation for this particle */
  startnode = All.MaxPart;
  do
    {
      numngb = ngb_treefind_pairs(&pos[0], h_i, &startnode);

      for(n = 0; n < numngb; n++)
        {
          j = Ngblist[n];

          dx = pos[0] - P[j].Pos[0];
          dy = pos[1] - P[j].Pos[1];
          dz = pos[2] - P[j].Pos[2];

#ifdef PERIODIC                 /*  find the closest image in the given box size 
       */
          if(dx > boxHalf_X)
            dx -= boxSize_X;
          if(dx < -boxHalf_X)
            dx += boxSize_X;
          if(dy > boxHalf_Y)
            dy -= boxSize_Y;
          if(dy < -boxHalf_Y)
            dy += boxSize_Y;
          if(dz > boxHalf_Z)
            dz -= boxSize_Z;
          if(dz < -boxHalf_Z)
            dz += boxSize_Z;
#endif
          r2 = dx * dx + dy * dy + dz * dz;
          h_j = SphP[j].Hsml;
          if(r2 < h_i2 || r2 < h_j * h_j)
            {
              r = sqrt(r2);
              if(r > 0)
                {
                  p_over_rho2_j = SphP[j].Pressure / (SphP[j].Density * SphP[j].
      Density);
                  soundspeed_j = sqrt(GAMMA * p_over_rho2_j * SphP[j].Density);
                  dvx = vel[0] - SphP[j].VelPred[0];
                  dvy = vel[1] - SphP[j].VelPred[1];
                  dvz = vel[2] - SphP[j].VelPred[2];
                  vdotr = dx * dvx + dy * dvy + dz * dvz;

                  if(All.ComovingIntegrationOn)
                    vdotr2 = vdotr + hubble_a2 * r2;
                  else
                    vdotr2 = vdotr;

                  if(r2 < h_i2)
                    {
                      hinv = 1.0 / h_i;
#ifndef  TWODIMS
                      hinv4 = hinv * hinv * hinv * hinv;
#else
                      hinv4 = hinv * hinv * hinv / boxSize_Z;
#endif
                      u = r * hinv;
                      if(u < 0.5)
                        dwk_i = hinv4 * u * (KERNEL_COEFF_3 * u - KERNEL_COEFF_4)
      ;
                      else
                        dwk_i = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                    }
                  else
                    {
                      dwk_i = 0;
                    }

                  if(r2 < h_j * h_j)
                    {
                      hinv = 1.0 / h_j;
#ifndef  TWODIMS
                      hinv4 = hinv * hinv * hinv * hinv;
#else
                      hinv4 = hinv * hinv * hinv / boxSize_Z;
#endif
                      u = r * hinv;
                      if(u < 0.5)
                        dwk_j = hinv4 * u * (KERNEL_COEFF_3 * u - KERNEL_COEFF_4)
      ;
                      else
                        dwk_j = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                    }
                  else
                    {
                      dwk_j = 0;
                    }

                  if(soundspeed_i + soundspeed_j > maxSignalVel)
                    maxSignalVel = soundspeed_i + soundspeed_j;

                  if(vdotr2 < 0)        /* ... artificial viscosity */
                    {
                      mu_ij = fac_mu * vdotr2 / r;      /* note: this is negative
      ! */

                      vsig = soundspeed_i + soundspeed_j - 3 * mu_ij;

                      if(vsig > maxSignalVel)
                        maxSignalVel = vsig;

                      rho_ij = 0.5 * (rho + SphP[j].Density);
                      f2 =
                        fabs(SphP[j].DivVel) / (fabs(SphP[j].DivVel) + SphP[j].
      CurlVel +
                                                0.0001 * soundspeed_j / fac_mu / 
      SphP[j].Hsml);

                      visc = 0.25 * All.ArtBulkViscConst * vsig * (-mu_ij) / rho_
      ij * (f1 + f2);

                      /* .... end artificial viscosity evaluation */
#ifndef NOVISCOSITYLIMITER
                      /* make sure that viscous acceleration is not too large */
                      dt = imax(timestep, (P[j].Ti_endstep - P[j].Ti_begstep)) * 
      All.Timebase_interval;
                      if(dt > 0 && (dwk_i + dwk_j) < 0)
                        {
                          visc = dmin(visc, 0.5 * fac_vsic_fix * vdotr2 /
                                      (0.5 * (mass + P[j].Mass) * (dwk_i + dwk_j)
       * r * dt));
                        }
#endif
                    }
                  else
                    visc = 0;

                  p_over_rho2_j *= SphP[j].DhsmlDensityFactor;

                  hfc_visc = 0.5 * P[j].Mass * visc * (dwk_i + dwk_j) / r;

                  hfc = hfc_visc + P[j].Mass * (p_over_rho2_i * dwk_i + p_over_rh
      o2_j * dwk_j) / r;

                  acc[0] -= hfc * dx;
                  acc[1] -= hfc * dy;
                  acc[2] -= hfc * dz;
                  dtEntropy += 0.5 * hfc_visc * vdotr2;
                }
            }
        }
    }
  while(startnode >= 0);

  /* Now collect the result at the right place */
  if(mode == 0)
    {
      for(k = 0; k < 3; k++)
        SphP[target].HydroAccel[k] = acc[k];
      SphP[target].DtEntropy = dtEntropy;
      SphP[target].MaxSignalVel = maxSignalVel;
    }
  else
    {
      for(k = 0; k < 3; k++)
        HydroDataResult[target].Acc[k] = acc[k];
      HydroDataResult[target].DtEntropy = dtEntropy;
      HydroDataResult[target].MaxSignalVel = maxSignalVel;
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a6789381bce7d1c316df8ecf04b47a607}{
\index{proto.h@{proto.h}!hydro\_\-force@{hydro\_\-force}}
\index{hydro\_\-force@{hydro\_\-force}!proto.h@{proto.h}}
\subsubsection[{hydro\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void hydro\_\-force (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a6789381bce7d1c316df8ecf04b47a607}
This function is the driver routine for the calculation of hydrodynamical force and rate of change of entropy due to shock heating for all active particles . 

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 



Definition at line 50 of file hydra.c.



References a3inv, All, atime, boxHalf, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, global\_\-data\_\-all\_\-processes::BoxSize, boxSize, boxSize\_\-X, boxSize\_\-Y, boxSize\_\-Z, global\_\-data\_\-all\_\-processes::BunchSizeHydro, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-HydCommSumm, global\_\-data\_\-all\_\-processes::CPU\_\-HydCompWalk, global\_\-data\_\-all\_\-processes::CPU\_\-HydImbalance, sph\_\-particle\_\-data::CurlVel, sph\_\-particle\_\-data::Density, hydrodata\_\-in::Density, sph\_\-particle\_\-data::DhsmlDensityFactor, hydrodata\_\-in::DhsmlDensityFactor, hydrodata\_\-out::DtEntropy, sph\_\-particle\_\-data::DtEntropy, Exportflag, hydrodata\_\-in::F1, fac\_\-egy, fac\_\-mu, fac\_\-vsic\_\-fix, GAMMA, GAMMA\_\-MINUS1, sph\_\-particle\_\-data::Hsml, hydrodata\_\-in::Hsml, global\_\-data\_\-all\_\-processes::Hubble, hubble\_\-a, hubble\_\-a2, hydro\_\-compare\_\-key(), hydro\_\-evaluate(), HydroDataGet, HydroDataIn, HydroDataPartialResult, HydroDataResult, hydrodata\_\-in::Index, particle\_\-data::Mass, hydrodata\_\-in::Mass, hydrodata\_\-out::MaxSignalVel, sph\_\-particle\_\-data::MaxSignalVel, N\_\-gas, NTask, NumSphUpdate, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, P, particle\_\-data::Pos, hydrodata\_\-in::Pos, pow(), sph\_\-particle\_\-data::Pressure, hydrodata\_\-in::Pressure, PTask, second(), SphP, TAG\_\-HYDRO\_\-A, TAG\_\-HYDRO\_\-B, hydrodata\_\-in::Task, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, timediff(), hydrodata\_\-in::Timestep, hydrodata\_\-in::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by compute\_\-accelerations().




\begin{DoxyCode}
{
  long long ntot, ntotleft;
  int i, j, k, n, ngrp, maxfill, source, ndone;
  int *nbuffer, *noffset, *nsend_local, *nsend, *numlist, *ndonelist;
  int level, sendTask, recvTask, nexport, place;
  double soundspeed_i;
  double tstart, tend, sumt, sumcomm;
  double timecomp = 0, timecommsumm = 0, timeimbalance = 0, sumimbalance;
  MPI_Status status;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif

  if(All.ComovingIntegrationOn)
    {
      /* Factors for comoving integration of hydro */
      hubble_a = All.Omega0 / (All.Time * All.Time * All.Time)
        + (1 - All.Omega0 - All.OmegaLambda) / (All.Time * All.Time) + All.
      OmegaLambda;

      hubble_a = All.Hubble * sqrt(hubble_a);
      hubble_a2 = All.Time * All.Time * hubble_a;

      fac_mu = pow(All.Time, 3 * (GAMMA - 1) / 2) / All.Time;

      fac_egy = pow(All.Time, 3 * (GAMMA - 1));

      fac_vsic_fix = hubble_a * pow(All.Time, 3 * GAMMA_MINUS1);

      a3inv = 1 / (All.Time * All.Time * All.Time);
      atime = All.Time;
    }
  else
    hubble_a = hubble_a2 = atime = fac_mu = fac_vsic_fix = a3inv = fac_egy = 1.0;
      


  /* `NumSphUpdate' gives the number of particles on this processor that want a f
      orce update */
  for(n = 0, NumSphUpdate = 0; n < N_gas; n++)
    {
      if(P[n].Ti_endstep == All.Ti_Current)
        NumSphUpdate++;
    }

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumSphUpdate, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);


  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common l
      ist */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);


  i = 0;                        /* first particle for this task */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      tstart = second();
      for(nexport = 0, ndone = 0; i < N_gas && nexport < All.BunchSizeHydro - NTa
      sk; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          {
            ndone++;

            for(j = 0; j < NTask; j++)
              Exportflag[j] = 0;

            hydro_evaluate(i, 0);

            for(j = 0; j < NTask; j++)
              {
                if(Exportflag[j])
                  {
                    for(k = 0; k < 3; k++)
                      {
                        HydroDataIn[nexport].Pos[k] = P[i].Pos[k];
                        HydroDataIn[nexport].Vel[k] = SphP[i].VelPred[k];
                      }
                    HydroDataIn[nexport].Hsml = SphP[i].Hsml;
                    HydroDataIn[nexport].Mass = P[i].Mass;
                    HydroDataIn[nexport].DhsmlDensityFactor = SphP[i].
      DhsmlDensityFactor;
                    HydroDataIn[nexport].Density = SphP[i].Density;
                    HydroDataIn[nexport].Pressure = SphP[i].Pressure;
                    HydroDataIn[nexport].Timestep = P[i].Ti_endstep - P[i].
      Ti_begstep;

                    /* calculation of F1 */
                    soundspeed_i = sqrt(GAMMA * SphP[i].Pressure / SphP[i].Densit
      y);
                    HydroDataIn[nexport].F1 = fabs(SphP[i].DivVel) /
                      (fabs(SphP[i].DivVel) + SphP[i].CurlVel +
                       0.0001 * soundspeed_i / SphP[i].Hsml / fac_mu);

                    HydroDataIn[nexport].Index = i;
                    HydroDataIn[nexport].Task = j;
                    nexport++;
                    nsend_local[j]++;
                  }
              }
          }
      tend = second();
      timecomp += timediff(tstart, tend);

      qsort(HydroDataIn, nexport, sizeof(struct hydrodata_in), hydro_compare_key)
      ;

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      tstart = second();

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, MPI_COMM_
      WORLD);

      tend = second();
      timeimbalance += timediff(tstart, tend);



      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeHydro)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&HydroDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      hydrodata_in), MPI_BYTE,
                                   recvTask, TAG_HYDRO_A,
                                   &HydroDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct hydrodata_in), MPI_BYTE,
                                   recvTask, TAG_HYDRO_A, MPI_COMM_WORLD, &status
      );
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);

          /* now do the imported particles */
          tstart = second();
          for(j = 0; j < nbuffer[ThisTask]; j++)
            hydro_evaluate(j, 1);
          tend = second();
          timecomp += timediff(tstart, tend);

          /* do a block to measure imbalance */
          tstart = second();
          MPI_Barrier(MPI_COMM_WORLD);
          tend = second();
          timeimbalance += timediff(tstart, tend);

          /* get the result */
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeHydro)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask * N
      Task + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&HydroDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(st
      ruct hydrodata_out),
                                   MPI_BYTE, recvTask, TAG_HYDRO_B,
                                   &HydroDataPartialResult[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      hydrodata_out),
                                   MPI_BYTE, recvTask, TAG_HYDRO_B, MPI_COMM_WORL
      D, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          source = j + noffset[recvTask];
                          place = HydroDataIn[source].Index;

                          for(k = 0; k < 3; k++)
                            SphP[place].HydroAccel[k] += HydroDataPartialResult[s
      ource].Acc[k];

                          SphP[place].DtEntropy += HydroDataPartialResult[source]
      .DtEntropy;

                          if(SphP[place].MaxSignalVel < HydroDataPartialResult[so
      urce].MaxSignalVel)
                            SphP[place].MaxSignalVel = HydroDataPartialResult[sou
      rce].MaxSignalVel;
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);

          level = ngrp - 1;
        }

      MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD);
      for(j = 0; j < NTask; j++)
        ntotleft -= ndonelist[j];
    }

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);



  /* do final operations on results */
  tstart = second();

  for(i = 0; i < N_gas; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      {
        SphP[i].DtEntropy *= GAMMA_MINUS1 / (hubble_a2 * pow(SphP[i].Density, 
      GAMMA_MINUS1));
#ifdef SPH_BND_PARTICLES
        if(P[i].ID == 0)
          {
            SphP[i].DtEntropy = 0;
            for(k = 0; k < 3; k++)
              SphP[i].HydroAccel[k] = 0;
          }
#endif
      }

  tend = second();
  timecomp += timediff(tstart, tend);

  /* collect some timing information */

  MPI_Reduce(&timecomp, &sumt, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecommsumm, &sumcomm, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
      
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_W
      ORLD);

  if(ThisTask == 0)
    {
      All.CPU_HydCompWalk += sumt / NTask;
      All.CPU_HydCommSumm += sumcomm / NTask;
      All.CPU_HydImbalance += sumimbalance / NTask;
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a6789381bce7d1c316df8ecf04b47a607_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a6789381bce7d1c316df8ecf04b47a607_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d}{
\index{proto.h@{proto.h}!hydrokick\_\-integ@{hydrokick\_\-integ}}
\index{hydrokick\_\-integ@{hydrokick\_\-integ}!proto.h@{proto.h}}
\subsubsection[{hydrokick\_\-integ}]{\setlength{\rightskip}{0pt plus 5cm}double hydrokick\_\-integ (
\begin{DoxyParamCaption}
\item[{double}]{ a, }
\item[{void $\ast$}]{ param}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d}
Integration kernel for hydrodynamical kick factor computation. 

$<$ adiabatic index of simulated gas 



Definition at line 204 of file driftfac.c.



References All, GAMMA\_\-MINUS1, global\_\-data\_\-all\_\-processes::Hubble, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, and pow().




\begin{DoxyCode}
{
  double h;

  h = All.Omega0 / (a * a * a) + (1 - All.Omega0 - All.OmegaLambda) / (a * a) + 
      All.OmegaLambda;
  h = All.Hubble * sqrt(h);

  return 1 / (h * pow(a, 3 * GAMMA_MINUS1) * a);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=244pt]{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d_cgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a05ba897ffe0dfe737254a09c91c50d10}{
\index{proto.h@{proto.h}!imax@{imax}}
\index{imax@{imax}!proto.h@{proto.h}}
\subsubsection[{imax}]{\setlength{\rightskip}{0pt plus 5cm}int imax (
\begin{DoxyParamCaption}
\item[{int}]{ x, }
\item[{int}]{ y}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a05ba897ffe0dfe737254a09c91c50d10}
returns the maximum of two integers 

Definition at line 111 of file system.c.



Referenced by hydro\_\-evaluate(), and pm\_\-init\_\-periodic\_\-allocate().




\begin{DoxyCode}
{
  if(x > y)
    return x;
  else
    return y;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a05ba897ffe0dfe737254a09c91c50d10_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af52841aeeb1b5bf6787e1e2036088644}{
\index{proto.h@{proto.h}!imin@{imin}}
\index{imin@{imin}!proto.h@{proto.h}}
\subsubsection[{imin}]{\setlength{\rightskip}{0pt plus 5cm}int imin (
\begin{DoxyParamCaption}
\item[{int}]{ x, }
\item[{int}]{ y}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af52841aeeb1b5bf6787e1e2036088644}
returns the minimum of two integers 

Definition at line 121 of file system.c.



Referenced by domain\_\-findExchangeNumbers().




\begin{DoxyCode}
{
  if(x < y)
    return x;
  else
    return y;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af52841aeeb1b5bf6787e1e2036088644_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a2858154e2009b0e6e616f313177762bc}{
\index{proto.h@{proto.h}!init@{init}}
\index{init@{init}!proto.h@{proto.h}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void init (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a2858154e2009b0e6e616f313177762bc}
This function reads the initial conditions, and allocates storage for the tree. Various variables of the particle data are initialised and An intial domain decomposition is performed. If SPH particles are present, the inial SPH smoothing lengths are determined. 

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ defines maximum length of neighbour list

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 



Definition at line 20 of file init.c.



References All, check\_\-omega(), global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, sph\_\-particle\_\-data::Density, domain\_\-Decomposition(), sph\_\-particle\_\-data::DtEntropy, endrun(), io\_\-header::flag\_\-entropy\_\-instead\_\-u, Flag\_\-FullStep, force\_\-treeallocate(), GAMMA\_\-MINUS1, get\_\-random\_\-number(), particle\_\-data::GravCost, header, sph\_\-particle\_\-data::Hsml, sph\_\-particle\_\-data::HydroAccel, global\_\-data\_\-all\_\-processes::ICFormat, global\_\-data\_\-all\_\-processes::InitCondFile, MAX\_\-NGB, global\_\-data\_\-all\_\-processes::MaxPart, N\_\-gas, ngb\_\-treeallocate(), ngb\_\-treebuild(), global\_\-data\_\-all\_\-processes::NumCurrentTiStep, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, particle\_\-data::OldAcc, P, global\_\-data\_\-all\_\-processes::PeriodicBoundariesOn, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-begstep, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, particle\_\-data::Potential, pow(), read\_\-ic(), RestartFlag, seed\_\-glass(), set\_\-softenings(), setup\_\-smoothinglengths(), global\_\-data\_\-all\_\-processes::SnapshotFileCount, SphP, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, TIMEBASE, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, global\_\-data\_\-all\_\-processes::TimeBegin, global\_\-data\_\-all\_\-processes::TimeBetStatistics, global\_\-data\_\-all\_\-processes::TimeLastStatistics, global\_\-data\_\-all\_\-processes::TimeMax, global\_\-data\_\-all\_\-processes::TotNumOfForces, global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeAllocFactor, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, TreeReconstructFlag, particle\_\-data::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by begrun().




\begin{DoxyCode}
{
  int i, j;
  double a3;

  All.Time = All.TimeBegin;

  switch (All.ICFormat)
    {
    case 1:
#if (MAKEGLASS > 1)
      seed_glass();
#else
      read_ic(All.InitCondFile);
#endif
      break;
    case 2:
    case 3:
      read_ic(All.InitCondFile);
      break;
    default:
      if(ThisTask == 0)
        printf("ICFormat=%d not supported.\n", All.ICFormat);
      endrun(0);
    }

  All.Time = All.TimeBegin;
  All.Ti_Current = 0;

  if(All.ComovingIntegrationOn)
    {
      All.Timebase_interval = (log(All.TimeMax) - log(All.TimeBegin)) / TIMEBASE;
      
      a3 = All.Time * All.Time * All.Time;
    }
  else
    {
      All.Timebase_interval = (All.TimeMax - All.TimeBegin) / TIMEBASE;
      a3 = 1;
    }

  set_softenings();

  All.NumCurrentTiStep = 0;     /* setup some counters */
  All.SnapshotFileCount = 0;

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  All.Nself_interactions = 0;
  for (i = 0; i < INTERACTION_TABLE_LENGTH; i++)
    for(j = 0; j < PARTICLE_MAX_INTERACTIONS; j++)
      InteractionTable[i][j]= 0;
#endif

  if(RestartFlag == 2)
    All.SnapshotFileCount = atoi(All.InitCondFile + strlen(All.InitCondFile) - 3)
       + 1;

  All.TotNumOfForces = 0;
  All.NumForcesSinceLastDomainDecomp = 0;

  if(All.ComovingIntegrationOn)
    if(All.PeriodicBoundariesOn == 1)
      check_omega();

  All.TimeLastStatistics = All.TimeBegin - All.TimeBetStatistics;

  if(All.ComovingIntegrationOn) /*  change to new velocity variable */
    {
      for(i = 0; i < NumPart; i++)
        for(j = 0; j < 3; j++)
          P[i].Vel[j] *= sqrt(All.Time) * All.Time;
    }

  for(i = 0; i < NumPart; i++)  /*  start-up initialization */
    {
      for(j = 0; j < 3; j++)
        P[i].GravAccel[j] = 0;
#ifdef PMGRID
      for(j = 0; j < 3; j++)
        P[i].GravPM[j] = 0;
#endif
      P[i].Ti_endstep = 0;
      P[i].Ti_begstep = 0;

      P[i].OldAcc = 0;
      P[i].GravCost = 1;
      P[i].Potential = 0;
    }

#ifdef PMGRID
  All.PM_Ti_endstep = All.PM_Ti_begstep = 0;
#endif

#ifdef FLEXSTEPS
  All.PresentMinStep = TIMEBASE;
  for(i = 0; i < NumPart; i++)  /*  start-up initialization */
    {
      P[i].FlexStepGrp = (int) (TIMEBASE * get_random_number(P[i].ID));
    }
#endif


  for(i = 0; i < N_gas; i++)    /* initialize sph_properties */
    {
      for(j = 0; j < 3; j++)
        {
          SphP[i].VelPred[j] = P[i].Vel[j];
          SphP[i].HydroAccel[j] = 0;
        }

      SphP[i].DtEntropy = 0;

      if(RestartFlag == 0)
        {
          SphP[i].Hsml = 0;
          SphP[i].Density = -1;
        }
    }

  ngb_treeallocate(MAX_NGB);

  force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);

  All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;

  Flag_FullStep = 1;            /* to ensure that Peano-Hilber order is done */

  domain_Decomposition();       /* do initial domain decomposition (gives equal n
      umbers of particles) */

  ngb_treebuild();              /* will build tree */

  setup_smoothinglengths();

  TreeReconstructFlag = 1;

  /* at this point, the entropy variable normally contains the 
   * internal energy, read in from the initial conditions file, unless the file
   * explicitly signals that the initial conditions contain the entropy directly.
       
   * Once the density has been computed, we can convert thermal energy to entropy
      .
   */
#ifndef ISOTHERM_EQS
  if(header.flag_entropy_instead_u == 0)
    for(i = 0; i < N_gas; i++)
      SphP[i].Entropy = GAMMA_MINUS1 * SphP[i].Entropy / pow(SphP[i].Density / a3
      , GAMMA_MINUS1);
#endif
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=600pt]{proto_8h_a2858154e2009b0e6e616f313177762bc_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=276pt]{proto_8h_a2858154e2009b0e6e616f313177762bc_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aea1f81063199abb9d89802b444098018}{
\index{proto.h@{proto.h}!init\_\-drift\_\-table@{init\_\-drift\_\-table}}
\index{init\_\-drift\_\-table@{init\_\-drift\_\-table}!proto.h@{proto.h}}
\subsubsection[{init\_\-drift\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}void init\_\-drift\_\-table (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aea1f81063199abb9d89802b444098018}
This function computes look-\/up tables for factors needed in cosmological integrations. The (simple) integrations are carried out with the GSL library. Separate factors are computed for the \char`\"{}drift\char`\"{}, and the gravitational and hydrodynamical \char`\"{}kicks\char`\"{}. The lookup-\/table is used for reasons of speed. 

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 



Definition at line 26 of file driftfac.c.



References All, DriftTable, GravKickTable, HydroKickTable, logTimeBegin, logTimeMax, global\_\-data\_\-all\_\-processes::TimeBegin, global\_\-data\_\-all\_\-processes::TimeMax, WORKSIZE, and workspace.



Referenced by begrun().




\begin{DoxyCode}
{
#define WORKSIZE 100000
  int i;
  double result, abserr;
  gsl_function F;
  gsl_integration_workspace *workspace;

  logTimeBegin = log(All.TimeBegin);
  logTimeMax = log(All.TimeMax);

  workspace = gsl_integration_workspace_alloc(WORKSIZE);

  for(i = 0; i < DRIFT_TABLE_LENGTH; i++)
    {
      F.function = &drift_integ;
      gsl_integration_qag(&F, exp(logTimeBegin), exp(logTimeBegin + ((logTimeMax 
      - logTimeBegin) / DRIFT_TABLE_LENGTH) * (i + 1)), 0,
                          1.0e-8, WORKSIZE, GSL_INTEG_GAUSS41, workspace, &result
      , &abserr);
      DriftTable[i] = result;


      F.function = &gravkick_integ;
      gsl_integration_qag(&F, exp(logTimeBegin), exp(logTimeBegin + ((logTimeMax 
      - logTimeBegin) / DRIFT_TABLE_LENGTH) * (i + 1)), 0,
                          1.0e-8, WORKSIZE, GSL_INTEG_GAUSS41, workspace, &result
      , &abserr);
      GravKickTable[i] = result;


      F.function = &hydrokick_integ;
      gsl_integration_qag(&F, exp(logTimeBegin), exp(logTimeBegin + ((logTimeMax 
      - logTimeBegin) / DRIFT_TABLE_LENGTH) * (i + 1)), 0,
                          1.0e-8, WORKSIZE, GSL_INTEG_GAUSS41, workspace, &result
      , &abserr);
      HydroKickTable[i] = result;
    }

  gsl_integration_workspace_free(workspace);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{proto_8h_aea1f81063199abb9d89802b444098018_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5052a0489feb425d7d910e57d7ad8102}{
\index{proto.h@{proto.h}!init\_\-peano\_\-map@{init\_\-peano\_\-map}}
\index{init\_\-peano\_\-map@{init\_\-peano\_\-map}!proto.h@{proto.h}}
\subsubsection[{init\_\-peano\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}void init\_\-peano\_\-map (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a5052a0489feb425d7d910e57d7ad8102}
\hypertarget{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25}{
\index{proto.h@{proto.h}!long\_\-range\_\-force@{long\_\-range\_\-force}}
\index{long\_\-range\_\-force@{long\_\-range\_\-force}!proto.h@{proto.h}}
\subsubsection[{long\_\-range\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void long\_\-range\_\-force (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25}
This function is a driver routine for the long-\/range PM force computation. It calls periodic and/or non-\/periodic FFT routines as needed for the present simulation set-\/up. 

Definition at line 56 of file longrange.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, endrun(), global\_\-data\_\-all\_\-processes::Hubble, NumPart, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, P, pm\_\-init\_\-regionsize(), pm\_\-setup\_\-nonperiodic\_\-kernel(), pmforce\_\-nonperiodic(), and pmforce\_\-periodic().



Referenced by compute\_\-accelerations().




\begin{DoxyCode}
{
  int i;

#ifndef PERIODIC
  int j;
  double fac;
#endif


  for(i = 0; i < NumPart; i++)
    P[i].GravPM[0] = P[i].GravPM[1] = P[i].GravPM[2] = 0;

#ifdef NOGRAVITY
  return;
#endif


#ifdef PERIODIC
  pmforce_periodic();
#ifdef PLACEHIGHRESREGION
  i = pmforce_nonperiodic(1);
  if(i == 1)                    /* this is returned if a particle lied outside al
      lowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmforce_nonperiodic(1);       /* try again */
    }
  if(i == 1)
    endrun(68686);
#endif
#else
  i = pmforce_nonperiodic(0);
  if(i == 1)                    /* this is returned if a particle lied outside al
      lowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmforce_nonperiodic(0);       /* try again */
    }
  if(i == 1)
    endrun(68687);
#ifdef PLACEHIGHRESREGION
  i = pmforce_nonperiodic(1);
  if(i == 1)                    /* this is returned if a particle lied outside al
      lowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();

      /* try again */

      for(i = 0; i < NumPart; i++)
        P[i].GravPM[0] = P[i].GravPM[1] = P[i].GravPM[2] = 0;

      i = pmforce_nonperiodic(0) + pmforce_nonperiodic(1);
    }
  if(i != 0)
    endrun(68688);
#endif
#endif


#ifndef PERIODIC
  if(All.ComovingIntegrationOn)
    {
      fac = 0.5 * All.Hubble * All.Hubble * All.Omega0;

      for(i = 0; i < NumPart; i++)
        for(j = 0; j < 3; j++)
          P[i].GravPM[j] += fac * P[i].Pos[j];
    }


  /* Finally, the following factor allows a computation of cosmological simulatio
      n 
     with vacuum energy in physical coordinates */

  if(All.ComovingIntegrationOn == 0)
    {
      fac = All.OmegaLambda * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        for(j = 0; j < 3; j++)
          P[i].GravPM[j] += fac * P[i].Pos[j];
    }
#endif

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af52079f2c63002aca9463ba0b13727df}{
\index{proto.h@{proto.h}!long\_\-range\_\-init@{long\_\-range\_\-init}}
\index{long\_\-range\_\-init@{long\_\-range\_\-init}!proto.h@{proto.h}}
\subsubsection[{long\_\-range\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void long\_\-range\_\-init (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af52079f2c63002aca9463ba0b13727df}
Calls initializiation routines of periodic or/and non-\/periodic FFT routines. 

Definition at line 20 of file longrange.c.



References pm\_\-init\_\-nonperiodic(), and pm\_\-init\_\-periodic().



Referenced by begrun().




\begin{DoxyCode}
{
#ifdef PERIODIC
  pm_init_periodic();
#ifdef PLACEHIGHRESREGION
  pm_init_nonperiodic();
#endif
#else
  pm_init_nonperiodic();
#endif
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_af52079f2c63002aca9463ba0b13727df_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=334pt]{proto_8h_af52079f2c63002aca9463ba0b13727df_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad295b3023b3d8fad337637a640362262}{
\index{proto.h@{proto.h}!long\_\-range\_\-init\_\-regionsize@{long\_\-range\_\-init\_\-regionsize}}
\index{long\_\-range\_\-init\_\-regionsize@{long\_\-range\_\-init\_\-regionsize}!proto.h@{proto.h}}
\subsubsection[{long\_\-range\_\-init\_\-regionsize}]{\setlength{\rightskip}{0pt plus 5cm}void long\_\-range\_\-init\_\-regionsize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad295b3023b3d8fad337637a640362262}
This function calls subroutines that determine the spatial region covered by the PM mesh. 

Definition at line 36 of file longrange.c.



References pm\_\-init\_\-regionsize(), pm\_\-setup\_\-nonperiodic\_\-kernel(), and RestartFlag.



Referenced by begrun().




\begin{DoxyCode}
{
#ifdef PERIODIC
#ifdef PLACEHIGHRESREGION
  if(RestartFlag != 1)
    pm_init_regionsize();
  pm_setup_nonperiodic_kernel();
#endif
#else
  if(RestartFlag != 1)
    pm_init_regionsize();
  pm_setup_nonperiodic_kernel();
#endif
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad295b3023b3d8fad337637a640362262_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=388pt]{proto_8h_ad295b3023b3d8fad337637a640362262_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31}{
\index{proto.h@{proto.h}!move\_\-particles@{move\_\-particles}}
\index{move\_\-particles@{move\_\-particles}!proto.h@{proto.h}}
\subsubsection[{move\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void move\_\-particles (
\begin{DoxyParamCaption}
\item[{int}]{ time0, }
\item[{int}]{ time1}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31}
This function drifts all particles from the current time to the future: time0 -\/ $>$ time1

If there is no explicit tree construction in the following timestep, the tree nodes are also drifted and updated accordingly. Note: For periodic boundary conditions, the mapping of coordinates onto the interval \mbox{[}0,All.BoxSize\mbox{]} is only done before the domain decomposition, or for outputs to snapshot files. This simplifies dynamic tree updates, and allows the domain decomposition to be carried out only every once in a while. 

$<$ adiabatic index of simulated gas 



Definition at line 31 of file predict.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-Predict, NODE::d, sph\_\-particle\_\-data::Density, sph\_\-particle\_\-data::DtEntropy, sph\_\-particle\_\-data::Entropy, Extnodes, force\_\-update\_\-len(), force\_\-update\_\-pseudoparticles(), GAMMA, get\_\-drift\_\-factor(), get\_\-gravkick\_\-factor(), get\_\-hydrokick\_\-factor(), particle\_\-data::GravAccel, particle\_\-data::GravPM, sph\_\-particle\_\-data::Hsml, sph\_\-particle\_\-data::HydroAccel, global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MinGasHsml, Nodes, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, Numnodestree, NumPart, P, particle\_\-data::Pos, pow(), sph\_\-particle\_\-data::Pressure, second(), SphP, particle\_\-data::Ti\_\-begstep, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, timediff(), global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, particle\_\-data::Type, NODE::u, particle\_\-data::Vel, and extNODE::vs.



Referenced by find\_\-next\_\-sync\_\-point\_\-and\_\-drift().




\begin{DoxyCode}
{
  int i, j;
  double dt_drift, dt_gravkick, dt_hydrokick, dt_entr;
  double t0, t1;


  t0 = second();

  if(All.ComovingIntegrationOn)
    {
      dt_drift = get_drift_factor(time0, time1);
      dt_gravkick = get_gravkick_factor(time0, time1);
      dt_hydrokick = get_hydrokick_factor(time0, time1);
    }
  else
    {
      dt_drift = dt_gravkick = dt_hydrokick = (time1 - time0) * All.
      Timebase_interval;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        P[i].Pos[j] += P[i].Vel[j] * dt_drift;

      if(P[i].Type == 0)
        {
#ifdef PMGRID
          for(j = 0; j < 3; j++)
            SphP[i].VelPred[j] +=
              (P[i].GravAccel[j] + P[i].GravPM[j]) * dt_gravkick + SphP[i].
      HydroAccel[j] * dt_hydrokick;
#else
          for(j = 0; j < 3; j++)
            SphP[i].VelPred[j] += P[i].GravAccel[j] * dt_gravkick + SphP[i].Hydro
      Accel[j] * dt_hydrokick;
#endif
          SphP[i].Density *= exp(-SphP[i].DivVel * dt_drift);
          SphP[i].Hsml *= exp(0.333333333333 * SphP[i].DivVel * dt_drift);

          if(SphP[i].Hsml < All.MinGasHsml)
            SphP[i].Hsml = All.MinGasHsml;

          dt_entr = (time1 - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * All.
      Timebase_interval;

          SphP[i].Pressure = (SphP[i].Entropy + SphP[i].DtEntropy * dt_entr) * 
      pow(SphP[i].Density, GAMMA);
        }
    }

  /* if domain-decomp and tree are not going to be reconstructed, update dynamica
      lly.  */
  if(All.NumForcesSinceLastDomainDecomp < All.TotNumPart * All.
      TreeDomainUpdateFrequency)
    {
      for(i = 0; i < Numnodestree; i++)
        for(j = 0; j < 3; j++)
          Nodes[All.MaxPart + i].u.d.s[j] += Extnodes[All.MaxPart + i].vs[j] * dt
      _drift;

      force_update_len();

      force_update_pseudoparticles();
    }

  t1 = second();

  All.CPU_Predict += timediff(t0, t1);
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a1609620c03f6b0068601735c42e3c660}{
\index{proto.h@{proto.h}!my\_\-fread@{my\_\-fread}}
\index{my\_\-fread@{my\_\-fread}!proto.h@{proto.h}}
\subsubsection[{my\_\-fread}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t my\_\-fread (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ ptr, }
\item[{size\_\-t}]{ size, }
\item[{size\_\-t}]{ nmemb, }
\item[{FILE $\ast$}]{ stream}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a1609620c03f6b0068601735c42e3c660}
This catches I/O errors occuring for fread(). In this case we better stop. 

Definition at line 1139 of file io.c.



References endrun(), and ThisTask.



Referenced by byten(), ewald\_\-init(), in(), and read\_\-file().




\begin{DoxyCode}
{
  size_t nread;

  if((nread = fread(ptr, size, nmemb, stream)) != nmemb)
    {
      printf("I/O error (fread) on task=%d has occured: %s\n", ThisTask, strerror
      (errno));
      fflush(stdout);
      endrun(778);
    }
  return nread;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=382pt]{proto_8h_a1609620c03f6b0068601735c42e3c660_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a1609620c03f6b0068601735c42e3c660_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21}{
\index{proto.h@{proto.h}!my\_\-fwrite@{my\_\-fwrite}}
\index{my\_\-fwrite@{my\_\-fwrite}!proto.h@{proto.h}}
\subsubsection[{my\_\-fwrite}]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t my\_\-fwrite (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ ptr, }
\item[{size\_\-t}]{ size, }
\item[{size\_\-t}]{ nmemb, }
\item[{FILE $\ast$}]{ stream}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21}
This catches I/O errors occuring for \hyperlink{io_8c_aab1e6568bf14b3a23c66f70c94aabd21}{my\_\-fwrite()}. In this case we better stop. 

Definition at line 1122 of file io.c.



References endrun(), and ThisTask.



Referenced by byten(), dump\_\-particles(), ewald\_\-init(), in(), and write\_\-file().




\begin{DoxyCode}
{
  size_t nwritten;

  if((nwritten = fwrite(ptr, size, nmemb, stream)) != nmemb)
    {
      printf("I/O error (fwrite) on task=%d has occured: %s\n", ThisTask, strerro
      r(errno));
      fflush(stdout);
      endrun(777);
    }
  return nwritten;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=382pt]{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a72ee1196e73c7c6e8683d35e4692d840}{
\index{proto.h@{proto.h}!ngb\_\-clear\_\-buf@{ngb\_\-clear\_\-buf}}
\index{ngb\_\-clear\_\-buf@{ngb\_\-clear\_\-buf}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-clear\_\-buf}]{\setlength{\rightskip}{0pt plus 5cm}int ngb\_\-clear\_\-buf (
\begin{DoxyParamCaption}
\item[{float}]{ searchcenter\mbox{[}3\mbox{]}, }
\item[{float}]{ hsml, }
\item[{int}]{ numngb}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a72ee1196e73c7c6e8683d35e4692d840}
The buffer for the neighbour list has a finite length MAX\_\-NGB. For a large search region, this buffer can get full, in which case this routine can be called to eliminate some of the superfluous particles in the \char`\"{}corners\char`\"{} of the search box -\/ only the ones in the inscribed sphere need to be kept. 

Definition at line 320 of file ngb.c.



References FLOAT, NGB\_\-PERIODIC\_\-X, NGB\_\-PERIODIC\_\-Y, NGB\_\-PERIODIC\_\-Z, Ngblist, P, and particle\_\-data::Pos.



Referenced by ngb\_\-treefind\_\-variable().




\begin{DoxyCode}
{
  int i, p;
  FLOAT dx, dy, dz, r2;

#ifdef PERIODIC
  double xtmp;
#endif

  for(i = 0; i < numngb; i++)
    {
      p = Ngblist[i];
#ifdef PERIODIC
      dx = NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]);
      dy = NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]);
      dz = NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]);
#else
      dx = P[p].Pos[0] - searchcenter[0];
      dy = P[p].Pos[1] - searchcenter[1];
      dz = P[p].Pos[2] - searchcenter[2];
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(r2 > hsml * hsml)
        {
          Ngblist[i] = Ngblist[numngb - 1];
          i--;
          numngb--;
        }
    }

  return numngb;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a72ee1196e73c7c6e8683d35e4692d840_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55}{
\index{proto.h@{proto.h}!ngb\_\-treeallocate@{ngb\_\-treeallocate}}
\index{ngb\_\-treeallocate@{ngb\_\-treeallocate}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treeallocate}]{\setlength{\rightskip}{0pt plus 5cm}void ngb\_\-treeallocate (
\begin{DoxyParamCaption}
\item[{int}]{ npart}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55}
Allocates memory for the neighbour list buffer. 

Definition at line 358 of file ngb.c.



References All, boxHalf, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, global\_\-data\_\-all\_\-processes::BoxSize, boxSize, boxSize\_\-X, boxSize\_\-Y, boxSize\_\-Z, endrun(), Ngblist, and ThisTask.



Referenced by init(), and restart().




\begin{DoxyCode}
{
  double totbytes = 0;
  size_t bytes;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif

  if(!(Ngblist = malloc(bytes = npart * (long) sizeof(int))))
    {
      printf("Failed to allocate %g MB for ngblist array\n", bytes / (1024.0 * 10
      24.0));
      endrun(78);
    }
  totbytes += bytes;

  if(ThisTask == 0)
    printf("allocated %g Mbyte for ngb search.\n", totbytes / (1024.0 * 1024.0));
      
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac56af97a1dbbbbb07db8207246852f79}{
\index{proto.h@{proto.h}!ngb\_\-treebuild@{ngb\_\-treebuild}}
\index{ngb\_\-treebuild@{ngb\_\-treebuild}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treebuild}]{\setlength{\rightskip}{0pt plus 5cm}void ngb\_\-treebuild (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ac56af97a1dbbbbb07db8207246852f79}
This function constructs the neighbour tree. To this end, we actually need to construct the gravitational tree, because we use it now for the neighbour search. 

Definition at line 403 of file ngb.c.



References force\_\-treebuild(), N\_\-gas, and ThisTask.



Referenced by init().




\begin{DoxyCode}
{
  if(ThisTask == 0)
    printf("Begin Ngb-tree construction.\n");

  force_treebuild(N_gas);

  if(ThisTask == 0)
    printf("Ngb-Tree contruction finished \n");
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ac56af97a1dbbbbb07db8207246852f79_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=394pt]{proto_8h_ac56af97a1dbbbbb07db8207246852f79_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd}{
\index{proto.h@{proto.h}!ngb\_\-treefind\_\-pairs@{ngb\_\-treefind\_\-pairs}}
\index{ngb\_\-treefind\_\-pairs@{ngb\_\-treefind\_\-pairs}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treefind\_\-pairs}]{\setlength{\rightskip}{0pt plus 5cm}int ngb\_\-treefind\_\-pairs (
\begin{DoxyParamCaption}
\item[{float}]{ searchcenter\mbox{[}3\mbox{]}, }
\item[{float}]{ hsml, }
\item[{int $\ast$}]{ startnode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd}
This routine finds all neighbours `j' that can interact with the particle `i' in the communication buffer.

Note that an interaction can take place if $ r_{ij} < h_i $ OR if $ r_{ij} < h_j $.

In the range-\/search this is taken into account, i.e. it is guaranteed that all particles are found that fulfil this condition, including the (more difficult) second part of it. For this purpose, each node knows the maximum h occuring among the particles it represents. 

$<$ defines maximum length of neighbour list 



Definition at line 64 of file ngb.c.



References All, NODE::center, DomainTask, Exportflag, Extnodes, FLOAT, extNODE::hmax, sph\_\-particle\_\-data::Hsml, NODE::len, MAX\_\-NGB, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nextnode, NGB\_\-PERIODIC\_\-X, NGB\_\-PERIODIC\_\-Y, NGB\_\-PERIODIC\_\-Z, Ngblist, Nodes, P, SphP, ThisTask, and NODE::u.



Referenced by hydro\_\-evaluate().




\begin{DoxyCode}
{
  int k, no, p, numngb;
  FLOAT hdiff;
  FLOAT searchmin[3], searchmax[3];
  struct NODE *this;

#ifdef PERIODIC
  double xtmp;
#endif

  for(k = 0; k < 3; k++)        /* cube-box window */
    {
      searchmin[k] = searchcenter[k] - hsml;
      searchmax[k] = searchcenter[k] + hsml;
    }

  numngb = 0;
  no = *startnode;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          p = no;
          no = Nextnode[no];

          if(P[p].Type > 0)
            continue;

          hdiff = SphP[p].Hsml - hsml;
          if(hdiff < 0)
            hdiff = 0;

#ifdef PERIODIC
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) < (-hsml - hdiff))
            continue;
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) > (hsml + hdiff))
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) < (-hsml - hdiff))
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) > (hsml + hdiff))
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) < (-hsml - hdiff))
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) > (hsml + hdiff))
            continue;
#else
          if(P[p].Pos[0] < (searchmin[0] - hdiff))
            continue;
          if(P[p].Pos[0] > (searchmax[0] + hdiff))
            continue;
          if(P[p].Pos[1] < (searchmin[1] - hdiff))
            continue;
          if(P[p].Pos[1] > (searchmax[1] + hdiff))
            continue;
          if(P[p].Pos[2] < (searchmin[2] - hdiff))
            continue;
          if(P[p].Pos[2] > (searchmax[2] + hdiff))
            continue;
#endif
          Ngblist[numngb++] = p;

          if(numngb == MAX_NGB)
            {
              printf
                ("ThisTask=%d: Need to do a second neighbour loop in hydro-force 
      for (%g|%g|%g) hsml=%g no=%d\n",
                 ThisTask, searchcenter[0], searchcenter[1], searchcenter[2], hsm
      l, no);
              *startnode = no;
              return numngb;
            }
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
              no = Nextnode[no - MaxNodes];
              continue;
            }

          this = &Nodes[no];
          hdiff = Extnodes[no].hmax - hsml;
          if(hdiff < 0)
            hdiff = 0;

          no = this->u.d.sibling;       /* in case the node can be discarded */

#ifdef PERIODIC
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) + 0.5 * this->
      len) < (-hsml - hdiff))
            continue;
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) - 0.5 * this->
      len) > (hsml + hdiff))
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) + 0.5 * this->
      len) < (-hsml - hdiff))
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) - 0.5 * this->
      len) > (hsml + hdiff))
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) + 0.5 * this->
      len) < (-hsml - hdiff))
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) - 0.5 * this->
      len) > (hsml + hdiff))
            continue;
#else
          if((this->center[0] + 0.5 * this->len) < (searchmin[0] - hdiff))
            continue;
          if((this->center[0] - 0.5 * this->len) > (searchmax[0] + hdiff))
            continue;
          if((this->center[1] + 0.5 * this->len) < (searchmin[1] - hdiff))
            continue;
          if((this->center[1] - 0.5 * this->len) > (searchmax[1] + hdiff))
            continue;
          if((this->center[2] + 0.5 * this->len) < (searchmin[2] - hdiff))
            continue;
          if((this->center[2] - 0.5 * this->len) > (searchmax[2] + hdiff))
            continue;
#endif
          no = this->u.d.nextnode;      /* ok, we need to open the node */
        }
    }

  *startnode = -1;
  return numngb;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8}{
\index{proto.h@{proto.h}!ngb\_\-treefind\_\-variable@{ngb\_\-treefind\_\-variable}}
\index{ngb\_\-treefind\_\-variable@{ngb\_\-treefind\_\-variable}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treefind\_\-variable}]{\setlength{\rightskip}{0pt plus 5cm}int ngb\_\-treefind\_\-variable (
\begin{DoxyParamCaption}
\item[{float}]{ searchcenter\mbox{[}3\mbox{]}, }
\item[{float}]{ hsml, }
\item[{int $\ast$}]{ startnode}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8}
This function returns neighbours with distance $<$= hsml and returns them in Ngblist. Actually, particles in a box of half side length hsml are returned, i.e. the reduction to a sphere still needs to be done in the calling routine. 

$<$ defines maximum length of neighbour list

$<$ defines maximum length of neighbour list 



Definition at line 194 of file ngb.c.



References All, NODE::center, DomainTask, Exportflag, FLOAT, NODE::len, MAX\_\-NGB, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, Nextnode, ngb\_\-clear\_\-buf(), NGB\_\-PERIODIC\_\-X, NGB\_\-PERIODIC\_\-Y, NGB\_\-PERIODIC\_\-Z, Ngblist, Nodes, P, ThisTask, and NODE::u.



Referenced by density\_\-evaluate().




\begin{DoxyCode}
{
  int k, numngb;
  int no, p;
  struct NODE *this;
  FLOAT searchmin[3], searchmax[3];

#ifdef PERIODIC
  double xtmp;
#endif

  for(k = 0; k < 3; k++)        /* cube-box window */
    {
      searchmin[k] = searchcenter[k] - hsml;
      searchmax[k] = searchcenter[k] + hsml;
    }

  numngb = 0;
  no = *startnode;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          p = no;
          no = Nextnode[no];

          if(P[p].Type > 0)
            continue;

#ifdef PERIODIC
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) < -hsml)
            continue;
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) > hsml)
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) < -hsml)
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) > hsml)
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) < -hsml)
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) > hsml)
            continue;
#else
          if(P[p].Pos[0] < searchmin[0])
            continue;
          if(P[p].Pos[0] > searchmax[0])
            continue;
          if(P[p].Pos[1] < searchmin[1])
            continue;
          if(P[p].Pos[1] > searchmax[1])
            continue;
          if(P[p].Pos[2] < searchmin[2])
            continue;
          if(P[p].Pos[2] > searchmax[2])
            continue;
#endif
          Ngblist[numngb++] = p;

          if(numngb == MAX_NGB)
            {
              numngb = ngb_clear_buf(searchcenter, hsml, numngb);
              if(numngb == MAX_NGB)
                {
                  printf("ThisTask=%d: Need to do a second neighbour loop for (%g
      |%g|%g) hsml=%g no=%d\n",
                         ThisTask, searchcenter[0], searchcenter[1], searchcenter
      [2], hsml, no);
                  *startnode = no;
                  return numngb;
                }
            }
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
              no = Nextnode[no - MaxNodes];
              continue;
            }

          this = &Nodes[no];

          no = this->u.d.sibling;       /* in case the node can be discarded */
#ifdef PERIODIC
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) + 0.5 * this->
      len) < -hsml)
            continue;
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) - 0.5 * this->
      len) > hsml)
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) + 0.5 * this->
      len) < -hsml)
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) - 0.5 * this->
      len) > hsml)
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) + 0.5 * this->
      len) < -hsml)
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) - 0.5 * this->
      len) > hsml)
            continue;
#else
          if((this->center[0] + 0.5 * this->len) < (searchmin[0]))
            continue;
          if((this->center[0] - 0.5 * this->len) > (searchmax[0]))
            continue;
          if((this->center[1] + 0.5 * this->len) < (searchmin[1]))
            continue;
          if((this->center[1] - 0.5 * this->len) > (searchmax[1]))
            continue;
          if((this->center[2] + 0.5 * this->len) < (searchmin[2]))
            continue;
          if((this->center[2] - 0.5 * this->len) > (searchmax[2]))
            continue;
#endif
          no = this->u.d.nextnode;      /* ok, we need to open the node */
        }
    }

  *startnode = -1;
  return numngb;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aab22cf240079ef5846d83729e4565f97}{
\index{proto.h@{proto.h}!ngb\_\-treefree@{ngb\_\-treefree}}
\index{ngb\_\-treefree@{ngb\_\-treefree}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treefree}]{\setlength{\rightskip}{0pt plus 5cm}void ngb\_\-treefree (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aab22cf240079ef5846d83729e4565f97}
free memory allocated for neighbour list buffer. 

Definition at line 394 of file ngb.c.



References Ngblist.




\begin{DoxyCode}
{
  free(Ngblist);
}
\end{DoxyCode}


\hypertarget{proto_8h_ab68e970cf33f44c3ff421fc2ea6e9290}{
\index{proto.h@{proto.h}!ngb\_\-treesearch@{ngb\_\-treesearch}}
\index{ngb\_\-treesearch@{ngb\_\-treesearch}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treesearch}]{\setlength{\rightskip}{0pt plus 5cm}void ngb\_\-treesearch (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ab68e970cf33f44c3ff421fc2ea6e9290}
\hypertarget{proto_8h_ad387916b04773b495483e10f3d24e9d6}{
\index{proto.h@{proto.h}!ngb\_\-treesearch\_\-pairs@{ngb\_\-treesearch\_\-pairs}}
\index{ngb\_\-treesearch\_\-pairs@{ngb\_\-treesearch\_\-pairs}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-treesearch\_\-pairs}]{\setlength{\rightskip}{0pt plus 5cm}void ngb\_\-treesearch\_\-pairs (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad387916b04773b495483e10f3d24e9d6}
\hypertarget{proto_8h_a6895b316b66ff5f9f78910d65823bf00}{
\index{proto.h@{proto.h}!ngb\_\-update\_\-nodes@{ngb\_\-update\_\-nodes}}
\index{ngb\_\-update\_\-nodes@{ngb\_\-update\_\-nodes}!proto.h@{proto.h}}
\subsubsection[{ngb\_\-update\_\-nodes}]{\setlength{\rightskip}{0pt plus 5cm}void ngb\_\-update\_\-nodes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a6895b316b66ff5f9f78910d65823bf00}
\hypertarget{proto_8h_a6f629274f7b036874c743fb81d58ce68}{
\index{proto.h@{proto.h}!open\_\-outputfiles@{open\_\-outputfiles}}
\index{open\_\-outputfiles@{open\_\-outputfiles}!proto.h@{proto.h}}
\subsubsection[{open\_\-outputfiles}]{\setlength{\rightskip}{0pt plus 5cm}void open\_\-outputfiles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a6f629274f7b036874c743fb81d58ce68}
This function opens various log-\/files that report on the status and performance of the simulstion. On restart from restart-\/files (start-\/option 1), the code will append to these files. 

Definition at line 203 of file begrun.c.



References All, global\_\-data\_\-all\_\-processes::CpuFile, endrun(), global\_\-data\_\-all\_\-processes::EnergyFile, FdCPU, FdEnergy, FdForceTest, FdInfo, FdTimings, global\_\-data\_\-all\_\-processes::InfoFile, global\_\-data\_\-all\_\-processes::OutputDir, RestartFlag, ThisTask, and global\_\-data\_\-all\_\-processes::TimingsFile.



Referenced by begrun().




\begin{DoxyCode}
{
  char mode[2], buf[200];

  if(ThisTask != 0)             /* only the root processor writes to the log file
      s */
    return;

  if(RestartFlag == 0)
    strcpy(mode, "w");
  else
    strcpy(mode, "a");


  sprintf(buf, "%s%s", All.OutputDir, All.CpuFile);
  if(!(FdCPU = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.InfoFile);
  if(!(FdInfo = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.EnergyFile);
  if(!(FdEnergy = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.TimingsFile);
  if(!(FdTimings = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

#ifdef FORCETEST
  if(RestartFlag == 0)
    {
      sprintf(buf, "%s%s", All.OutputDir, "forcetest.txt");
      if(!(FdForceTest = fopen(buf, "w")))
        {
          printf("error in opening file '%s'\n", buf);
          endrun(1);
        }
      fclose(FdForceTest);
    }
#endif
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a6f629274f7b036874c743fb81d58ce68_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{proto_8h_a6f629274f7b036874c743fb81d58ce68_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df}{
\index{proto.h@{proto.h}!peano\_\-hilbert\_\-key@{peano\_\-hilbert\_\-key}}
\index{peano\_\-hilbert\_\-key@{peano\_\-hilbert\_\-key}!proto.h@{proto.h}}
\subsubsection[{peano\_\-hilbert\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}{\bf peanokey} peano\_\-hilbert\_\-key (
\begin{DoxyParamCaption}
\item[{int}]{ x, }
\item[{int}]{ y, }
\item[{int}]{ z, }
\item[{int}]{ bits}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df}
This function computes a Peano-\/Hilbert key for an integer triplet (x,y,z), with x,y,z in the range between 0 and 2$^\wedge$bits-\/1. 

Definition at line 263 of file peano.c.



References quadrants, rotx\_\-table, rotxmap\_\-table, roty\_\-table, rotymap\_\-table, and sense\_\-table.



Referenced by domain\_\-determineTopTree(), force\_\-create\_\-empty\_\-nodes(), and force\_\-treebuild\_\-single().




\begin{DoxyCode}
{
  int i, quad, bitx, bity, bitz;
  int mask, rotation, rotx, roty, sense;
  peanokey key;


  mask = 1 << (bits - 1);
  key = 0;
  rotation = 0;
  sense = 1;


  for(i = 0; i < bits; i++, mask >>= 1)
    {
      bitx = (x & mask) ? 1 : 0;
      bity = (y & mask) ? 1 : 0;
      bitz = (z & mask) ? 1 : 0;

      quad = quadrants[rotation][bitx][bity][bitz];

      key <<= 3;
      key += (sense == 1) ? (quad) : (7 - quad);

      rotx = rotx_table[quad];
      roty = roty_table[quad];
      sense *= sense_table[quad];

      while(rotx > 0)
        {
          rotation = rotxmap_table[rotation];
          rotx--;
        }

      while(roty > 0)
        {
          rotation = rotymap_table[rotation];
          roty--;
        }
    }

  return key;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af3e45a4293584b3fe28e83af75c6ed71}{
\index{proto.h@{proto.h}!peano\_\-hilbert\_\-order@{peano\_\-hilbert\_\-order}}
\index{peano\_\-hilbert\_\-order@{peano\_\-hilbert\_\-order}!proto.h@{proto.h}}
\subsubsection[{peano\_\-hilbert\_\-order}]{\setlength{\rightskip}{0pt plus 5cm}void peano\_\-hilbert\_\-order (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af3e45a4293584b3fe28e83af75c6ed71}
This function puts the particles into Peano-\/Hilbert order by sorting them according to their keys. The latter half already been computed in the domain decomposition. Since gas particles need to stay at the beginning of the particle list, they are sorted as a separate block. 

Definition at line 34 of file peano.c.



References compare\_\-key(), Id, peano\_\-hilbert\_\-data::index, Key, peano\_\-hilbert\_\-data::key, mp, N\_\-gas, NumPart, reorder\_\-gas(), reorder\_\-particles(), and ThisTask.



Referenced by domain\_\-Decomposition().




\begin{DoxyCode}
{
  int i;

  if(ThisTask == 0)
    printf("begin Peano-Hilbert order...\n");

  if(N_gas)
    {
      mp = malloc(sizeof(struct peano_hilbert_data) * N_gas);
      Id = malloc(sizeof(int) * N_gas);

      for(i = 0; i < N_gas; i++)
        {
          mp[i].index = i;
          mp[i].key = Key[i];
        }

      qsort(mp, N_gas, sizeof(struct peano_hilbert_data), compare_key);

      for(i = 0; i < N_gas; i++)
        Id[mp[i].index] = i;

      reorder_gas();

      free(Id);
      free(mp);
    }


  if(NumPart - N_gas > 0)
    {
      mp = malloc(sizeof(struct peano_hilbert_data) * (NumPart - N_gas));
      mp -= (N_gas);

      Id = malloc(sizeof(int) * (NumPart - N_gas));
      Id -= (N_gas);

      for(i = N_gas; i < NumPart; i++)
        {
          mp[i].index = i;
          mp[i].key = Key[i];
        }

      qsort(mp + N_gas, NumPart - N_gas, sizeof(struct peano_hilbert_data), 
      compare_key);

      for(i = N_gas; i < NumPart; i++)
        Id[mp[i].index] = i;

      reorder_particles();

      Id += N_gas;
      free(Id);
      mp += N_gas;
      free(mp);
    }

  if(ThisTask == 0)
    printf("Peano-Hilbert done.\n");
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{proto_8h_af3e45a4293584b3fe28e83af75c6ed71_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af3e45a4293584b3fe28e83af75c6ed71_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0}{
\index{proto.h@{proto.h}!pm\_\-init\_\-nonperiodic@{pm\_\-init\_\-nonperiodic}}
\index{pm\_\-init\_\-nonperiodic@{pm\_\-init\_\-nonperiodic}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-nonperiodic}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-nonperiodic (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0}


Referenced by long\_\-range\_\-init().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac8030592010e755c61e6ee358ee0895d}{
\index{proto.h@{proto.h}!pm\_\-init\_\-nonperiodic\_\-allocate@{pm\_\-init\_\-nonperiodic\_\-allocate}}
\index{pm\_\-init\_\-nonperiodic\_\-allocate@{pm\_\-init\_\-nonperiodic\_\-allocate}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-nonperiodic\_\-allocate}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-nonperiodic\_\-allocate (
\begin{DoxyParamCaption}
\item[{int}]{ dimprod}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ac8030592010e755c61e6ee358ee0895d}
\hypertarget{proto_8h_afd73e48ecc5be43d057dd718f78d187d}{
\index{proto.h@{proto.h}!pm\_\-init\_\-nonperiodic\_\-free@{pm\_\-init\_\-nonperiodic\_\-free}}
\index{pm\_\-init\_\-nonperiodic\_\-free@{pm\_\-init\_\-nonperiodic\_\-free}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-nonperiodic\_\-free}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-nonperiodic\_\-free (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_afd73e48ecc5be43d057dd718f78d187d}
\hypertarget{proto_8h_a13e381f05efdb739cf5026384e908409}{
\index{proto.h@{proto.h}!pm\_\-init\_\-periodic@{pm\_\-init\_\-periodic}}
\index{pm\_\-init\_\-periodic@{pm\_\-init\_\-periodic}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-periodic}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-periodic (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a13e381f05efdb739cf5026384e908409}
This routines generates the FFTW-\/plans to carry out the parallel FFTs later on. Some auxiliary variables are also initialized. 

$<$ @-\/ASMTH gives the scale of the short-\/range/long-\/range force split in units of FFT-\/mesh cells

$<$ @-\/RCUT gives the maximum distance (in units of the scale used for the force split) out to which short-\/range forces are evaluated in the short-\/range tree walk. 



Definition at line 55 of file pm\_\-periodic.c.



References All, ASMTH, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, fft\_\-forward\_\-plan, fft\_\-inverse\_\-plan, fftsize, first\_\-slab\_\-of\_\-task, maxfftsize, meshmax\_\-list, meshmin\_\-list, nslab\_\-x, nslab\_\-y, NTask, RCUT, global\_\-data\_\-all\_\-processes::Rcut, slab\_\-to\_\-task, slabs\_\-per\_\-task, slabstart\_\-x, slabstart\_\-y, smallest\_\-slab, ThisTask, and to\_\-slab\_\-fac.



Referenced by long\_\-range\_\-init().




\begin{DoxyCode}
{
  int i;
  int slab_to_task_local[PMGRID];

  All.Asmth[0] = ASMTH * All.BoxSize / PMGRID;
  All.Rcut[0] = RCUT * All.Asmth[0];

  /* Set up the FFTW plan files. */

  fft_forward_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, PMGRID, PMGRID, PMGR
      ID,
                                             FFTW_REAL_TO_COMPLEX, FFTW_ESTIMATE 
      | FFTW_IN_PLACE);
  fft_inverse_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, PMGRID, PMGRID, PMGR
      ID,
                                             FFTW_COMPLEX_TO_REAL, FFTW_ESTIMATE 
      | FFTW_IN_PLACE);

  /* Workspace out the ranges on each processor. */

  rfftwnd_mpi_local_sizes(fft_forward_plan, &nslab_x, &slabstart_x, &nslab_y, &
      slabstart_y, &fftsize);

  for(i = 0; i < PMGRID; i++)
    slab_to_task_local[i] = 0;

  for(i = 0; i < nslab_x; i++)
    slab_to_task_local[slabstart_x + i] = ThisTask;

  MPI_Allreduce(slab_to_task_local, slab_to_task, PMGRID, MPI_INT, MPI_SUM, MPI_C
      OMM_WORLD);

  MPI_Allreduce(&nslab_x, &smallest_slab, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);

  slabs_per_task = malloc(NTask * sizeof(int));
  MPI_Allgather(&nslab_x, 1, MPI_INT, slabs_per_task, 1, MPI_INT, MPI_COMM_WORLD)
      ;

  if(ThisTask == 0)
    {
      for(i = 0; i < NTask; i++)
        printf("Task=%d  FFT-Slabs=%d\n", i, slabs_per_task[i]);
    }

  first_slab_of_task = malloc(NTask * sizeof(int));
  MPI_Allgather(&slabstart_x, 1, MPI_INT, first_slab_of_task, 1, MPI_INT, MPI_COM
      M_WORLD);

  meshmin_list = malloc(3 * NTask * sizeof(int));
  meshmax_list = malloc(3 * NTask * sizeof(int));


  to_slab_fac = PMGRID / All.BoxSize;

  MPI_Allreduce(&fftsize, &maxfftsize, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a13e381f05efdb739cf5026384e908409_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e}{
\index{proto.h@{proto.h}!pm\_\-init\_\-periodic\_\-allocate@{pm\_\-init\_\-periodic\_\-allocate}}
\index{pm\_\-init\_\-periodic\_\-allocate@{pm\_\-init\_\-periodic\_\-allocate}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-periodic\_\-allocate}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-periodic\_\-allocate (
\begin{DoxyParamCaption}
\item[{int}]{ dimprod}
\end{DoxyParamCaption}
)}}
\label{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e}
This function allocates the memory neeed to compute the long-\/range PM force. Three fields are used, one to hold the density (and its FFT, and then the real-\/space potential), one to hold the force field obtained by finite differencing, and finally a workspace field, which is used both as workspace for the parallel FFT, and as buffer for the communication algorithm used in the force computation. 

Definition at line 113 of file pm\_\-periodic.c.



References endrun(), fft\_\-of\_\-rhogrid, fftsize, forcegrid, imax(), maxfftsize, rhogrid, ThisTask, and workspace.



Referenced by pmforce\_\-periodic(), and pmpotential\_\-periodic().




\begin{DoxyCode}
{
  static int first_alloc = 1;
  int dimprodmax;
  double bytes_tot = 0;
  size_t bytes;

  MPI_Allreduce(&dimprod, &dimprodmax, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);

  /* allocate the memory to hold the FFT fields */

  if(!(rhogrid = (fftw_real *) malloc(bytes = fftsize * sizeof(fftw_real))))
    {
      printf("failed to allocate memory for `FFT-rhogrid' (%g MB).\n", bytes / (1
      024.0 * 1024.0));
      endrun(1);
    }
  bytes_tot += bytes;


  if(!(forcegrid = (fftw_real *) malloc(bytes = imax(fftsize, dimprodmax) * sizeo
      f(fftw_real))))
    {
      printf("failed to allocate memory for `FFT-forcegrid' (%g MB).\n", bytes / 
      (1024.0 * 1024.0));
      endrun(1);
    }
  bytes_tot += bytes;

  if(!(workspace = (fftw_real *) malloc(bytes = imax(maxfftsize, dimprodmax) * si
      zeof(fftw_real))))
    {
      printf("failed to allocate memory for `FFT-workspace' (%g MB).\n", bytes / 
      (1024.0 * 1024.0));
      endrun(1);
    }
  bytes_tot += bytes;

  if(first_alloc == 1)
    {
      first_alloc = 0;
      if(ThisTask == 0)
        printf("\nAllocated %g MByte for FFT data.\n\n", bytes_tot / (1024.0 * 10
      24.0));
    }

  fft_of_rhogrid = (fftw_complex *) & rhogrid[0];
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a259e6f8400ee889c64bc667334060742}{
\index{proto.h@{proto.h}!pm\_\-init\_\-periodic\_\-free@{pm\_\-init\_\-periodic\_\-free}}
\index{pm\_\-init\_\-periodic\_\-free@{pm\_\-init\_\-periodic\_\-free}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-periodic\_\-free}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-periodic\_\-free (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a259e6f8400ee889c64bc667334060742}
This routine frees the space allocated for the parallel FFT algorithm. 

Definition at line 160 of file pm\_\-periodic.c.



References forcegrid, rhogrid, and workspace.



Referenced by pmforce\_\-periodic(), and pmpotential\_\-periodic().




\begin{DoxyCode}
{
  /* allocate the memory to hold the FFT fields */
  free(workspace);
  free(forcegrid);
  free(rhogrid);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a259e6f8400ee889c64bc667334060742_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a57f2f415791cd83ace42bff59b2feb97}{
\index{proto.h@{proto.h}!pm\_\-init\_\-regionsize@{pm\_\-init\_\-regionsize}}
\index{pm\_\-init\_\-regionsize@{pm\_\-init\_\-regionsize}!proto.h@{proto.h}}
\subsubsection[{pm\_\-init\_\-regionsize}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-init\_\-regionsize (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a57f2f415791cd83ace42bff59b2feb97}


Referenced by compute\_\-potential(), long\_\-range\_\-force(), and long\_\-range\_\-init\_\-regionsize().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a57f2f415791cd83ace42bff59b2feb97_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae3950c19708f6a2886dd32897efa10c4}{
\index{proto.h@{proto.h}!pm\_\-setup\_\-nonperiodic\_\-kernel@{pm\_\-setup\_\-nonperiodic\_\-kernel}}
\index{pm\_\-setup\_\-nonperiodic\_\-kernel@{pm\_\-setup\_\-nonperiodic\_\-kernel}!proto.h@{proto.h}}
\subsubsection[{pm\_\-setup\_\-nonperiodic\_\-kernel}]{\setlength{\rightskip}{0pt plus 5cm}void pm\_\-setup\_\-nonperiodic\_\-kernel (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ae3950c19708f6a2886dd32897efa10c4}


Referenced by compute\_\-potential(), long\_\-range\_\-force(), and long\_\-range\_\-init\_\-regionsize().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ae3950c19708f6a2886dd32897efa10c4_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8821224474d8690f0db99b8cfab3a8fc}{
\index{proto.h@{proto.h}!pmforce\_\-nonperiodic@{pmforce\_\-nonperiodic}}
\index{pmforce\_\-nonperiodic@{pmforce\_\-nonperiodic}!proto.h@{proto.h}}
\subsubsection[{pmforce\_\-nonperiodic}]{\setlength{\rightskip}{0pt plus 5cm}int pmforce\_\-nonperiodic (
\begin{DoxyParamCaption}
\item[{int}]{ grnr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a8821224474d8690f0db99b8cfab3a8fc}


Referenced by long\_\-range\_\-force().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a8821224474d8690f0db99b8cfab3a8fc_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b}{
\index{proto.h@{proto.h}!pmforce\_\-periodic@{pmforce\_\-periodic}}
\index{pmforce\_\-periodic@{pmforce\_\-periodic}!proto.h@{proto.h}}
\subsubsection[{pmforce\_\-periodic}]{\setlength{\rightskip}{0pt plus 5cm}void pmforce\_\-periodic (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b}
Calculates the long-\/range periodic force given the particle positions using the PM method. The force is Gaussian filtered with Asmth, given in mesh-\/cell units. We carry out a CIC charge assignment, and compute the potenial by Fourier transform methods. The potential is finite differenced using a 4-\/point finite differencing formula, and the forces are interpolated tri-\/linearly to the particle positions. The CIC kernel is deconvolved. Note that the particle distribution is not in the slab decomposition that is used for the FFT. Instead, overlapping patches between local domains and FFT slabs are communicated as needed. 

Definition at line 180 of file pm\_\-periodic.c.



References All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, fft\_\-forward\_\-plan, fft\_\-inverse\_\-plan, fft\_\-of\_\-rhogrid, fftsize, first\_\-slab\_\-of\_\-task, force\_\-treeallocate(), force\_\-treefree(), forcegrid, global\_\-data\_\-all\_\-processes::G, particle\_\-data::GravPM, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MaxPart, meshmax\_\-list, meshmin\_\-list, nslab\_\-y, NTask, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, P, pm\_\-init\_\-periodic\_\-allocate(), pm\_\-init\_\-periodic\_\-free(), PMGRID2, particle\_\-data::Pos, PTask, rhogrid, slab\_\-to\_\-task, slabs\_\-per\_\-task, slabstart\_\-y, TAG\_\-PERIODIC\_\-A, TAG\_\-PERIODIC\_\-B, ThisTask, to\_\-slab\_\-fac, global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeAllocFactor, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, and workspace.



Referenced by long\_\-range\_\-force().




\begin{DoxyCode}
{
  double k2, kx, ky, kz, smth;
  double dx, dy, dz;
  double fx, fy, fz, ff;
  double asmth2, fac, acc_dim;
  int i, j, slab, level, sendTask, recvTask;
  int x, y, z, xl, yl, zl, xr, yr, zr, xll, yll, zll, xrr, yrr, zrr, ip, dim;
  int slab_x, slab_y, slab_z;
  int slab_xx, slab_yy, slab_zz;
  int meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
  int rep, ncont, cont_sendmin[2], cont_sendmax[2], cont_recvmin[2], cont_recvmax
      [2];
  int dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
  MPI_Status status;


  if(ThisTask == 0)
    {
      printf("Starting periodic PM calculation.\n");
      fflush(stdout);
    }


  force_treefree();


  asmth2 = (2 * M_PI) * All.Asmth[0] / All.BoxSize;
  asmth2 *= asmth2;

  fac = All.G / (M_PI * All.BoxSize);   /* to get potential */
  fac *= 1 / (2 * All.BoxSize / PMGRID);        /* for finite differencing */

  /* first, establish the extension of the local patch in the PMGRID  */

  for(j = 0; j < 3; j++)
    {
      meshmin[j] = PMGRID;
      meshmax[j] = 0;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          slab = to_slab_fac * P[i].Pos[j];
          if(slab >= PMGRID)
            slab = PMGRID - 1;

          if(slab < meshmin[j])
            meshmin[j] = slab;

          if(slab > meshmax[j])
            meshmax[j] = slab;
        }
    }

  MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
  MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);

  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  pm_init_periodic_allocate((dimx + 4) * (dimy + 4) * (dimz + 4));

  for(i = 0; i < dimx * dimy * dimz; i++)
    workspace[i] = 0;

  for(i = 0; i < NumPart; i++)
    {
      slab_x = to_slab_fac * P[i].Pos[0];
      if(slab_x >= PMGRID)
        slab_x = PMGRID - 1;
      dx = to_slab_fac * P[i].Pos[0] - slab_x;
      slab_x -= meshmin[0];
      slab_xx = slab_x + 1;

      slab_y = to_slab_fac * P[i].Pos[1];
      if(slab_y >= PMGRID)
        slab_y = PMGRID - 1;
      dy = to_slab_fac * P[i].Pos[1] - slab_y;
      slab_y -= meshmin[1];
      slab_yy = slab_y + 1;

      slab_z = to_slab_fac * P[i].Pos[2];
      if(slab_z >= PMGRID)
        slab_z = PMGRID - 1;
      dz = to_slab_fac * P[i].Pos[2] - slab_z;
      slab_z -= meshmin[2];
      slab_zz = slab_z + 1;

      workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (1.0 - d
      x) * (1.0 - dy) * (1.0 - dz);
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (1.0 - 
      dx) * dy * (1.0 - dz);
      workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (1.0 - 
      dx) * (1.0 - dy) * dz;
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (1.0 -
       dx) * dy * dz;

      workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (dx) * 
      (1.0 - dy) * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (dx) *
       dy * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (dx) *
       (1.0 - dy) * dz;
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (dx) 
      * dy * dz;
    }


  for(i = 0; i < fftsize; i++)  /* clear local density field */
    rhogrid[i] = 0;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is t
      he same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;
      if(recvTask < NTask)
        {
          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -1;
          for(slab_x = meshmin[0]; slab_x < meshmax[0] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == recvTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -1)
            sendmin = 0;

          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -1;
          for(slab_x = meshmin_list[3 * recvTask]; slab_x < meshmax_list[3 * recv
      Task] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == sendTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -1)
            recvmin = 0;


          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok, we
       have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvT
      ask + 0] + 2;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvT
      ask + 1] + 2;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvT
      ask + 2] + 2;

              if(level > 0)
                {
                  MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz,
                               (sendmax - sendmin + 1) * dimy * dimz * sizeof(fft
      w_real), MPI_BYTE, recvTask,
                               TAG_PERIODIC_A, forcegrid,
                               (recvmax - recvmin + 1) * recv_dimy * recv_dimz * 
      sizeof(fftw_real), MPI_BYTE,
                               recvTask, TAG_PERIODIC_A, MPI_COMM_WORLD, &status)
      ;
                }
              else
                {
                  memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy * d
      imz,
                         (sendmax - sendmin + 1) * dimy * dimz * sizeof(fftw_real
      ));
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  slab_xx = (slab_x % PMGRID) - first_slab_of_task[ThisTask];

                  if(slab_xx >= 0 && slab_xx < slabs_per_task[ThisTask])
                    {
                      for(slab_y = meshmin_list[3 * recvTask + 1];
                          slab_y <= meshmax_list[3 * recvTask + 1] + 1; slab_y++)
      
                        {
                          slab_yy = slab_y;
                          if(slab_yy >= PMGRID)
                            slab_yy -= PMGRID;

                          for(slab_z = meshmin_list[3 * recvTask + 2];
                              slab_z <= meshmax_list[3 * recvTask + 2] + 1; slab_
      z++)
                            {
                              slab_zz = slab_z;
                              if(slab_zz >= PMGRID)
                                slab_zz -= PMGRID;

                              rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2 * slab
      _yy + slab_zz] +=
                                forcegrid[((slab_x - recvmin) * recv_dimy +
                                           (slab_y - meshmin_list[3 * recvTask + 
      1])) * recv_dimz +
                                          (slab_z - meshmin_list[3 * recvTask + 2
      ])];
                            }
                        }
                    }
                }
            }
        }
    }

  /* Do the FFT of the density field */

  rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* multiply with Green's function for the potential */

  for(y = slabstart_y; y < slabstart_y + nslab_y; y++)
    for(x = 0; x < PMGRID; x++)
      for(z = 0; z < PMGRID / 2 + 1; z++)
        {
          if(x > PMGRID / 2)
            kx = x - PMGRID;
          else
            kx = x;
          if(y > PMGRID / 2)
            ky = y - PMGRID;
          else
            ky = y;
          if(z > PMGRID / 2)
            kz = z - PMGRID;
          else
            kz = z;

          k2 = kx * kx + ky * ky + kz * kz;

          if(k2 > 0)
            {
              smth = -exp(-k2 * asmth2) / k2;

              /* do deconvolution */

              fx = fy = fz = 1;
              if(kx != 0)
                {
                  fx = (M_PI * kx) / PMGRID;
                  fx = sin(fx) / fx;
                }
              if(ky != 0)
                {
                  fy = (M_PI * ky) / PMGRID;
                  fy = sin(fy) / fy;
                }
              if(kz != 0)
                {
                  fz = (M_PI * kz) / PMGRID;
                  fz = sin(fz) / fz;
                }
              ff = 1 / (fx * fy * fz);
              smth *= ff * ff * ff * ff;

              /* end deconvolution */

              ip = PMGRID * (PMGRID / 2 + 1) * (y - slabstart_y) + (PMGRID / 2 + 
      1) * x + z;
              fft_of_rhogrid[ip].re *= smth;
              fft_of_rhogrid[ip].im *= smth;
            }
        }

  if(slabstart_y == 0)
    fft_of_rhogrid[0].re = fft_of_rhogrid[0].im = 0.0;

  /* Do the FFT to get the potential */

  rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* Now rhogrid holds the potential */
  /* construct the potential for the local patch */


  dimx = meshmax[0] - meshmin[0] + 6;
  dimy = meshmax[1] - meshmin[1] + 6;
  dimz = meshmax[2] - meshmin[2] + 6;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is t
      he same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        {

          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -PMGRID;
          for(slab_x = meshmin_list[3 * recvTask] - 2; slab_x < meshmax_list[3 * 
      recvTask] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == sendTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -PMGRID)
            sendmin = sendmax + 1;


          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -PMGRID;
          for(slab_x = meshmin[0] - 2; slab_x < meshmax[0] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == recvTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -PMGRID)
            recvmin = recvmax + 1;

          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok, we
       have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvT
      ask + 0] + 6;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvT
      ask + 1] + 6;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvT
      ask + 2] + 6;

              ncont = 1;
              cont_sendmin[0] = sendmin;
              cont_sendmax[0] = sendmax;
              cont_sendmin[1] = sendmax + 1;
              cont_sendmax[1] = sendmax;

              cont_recvmin[0] = recvmin;
              cont_recvmax[0] = recvmax;
              cont_recvmin[1] = recvmax + 1;
              cont_recvmax[1] = recvmax;

              for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
                    {
                      /* non-contiguous */
                      cont_sendmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
      
                        slab_x++;
                      cont_sendmin[1] = slab_x;
                      ncont++;
                    }
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
                    {
                      /* non-contiguous */
                      cont_recvmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
      
                        slab_x++;
                      cont_recvmin[1] = slab_x;
                      if(ncont == 1)
                        ncont++;
                    }
                }


              for(rep = 0; rep < ncont; rep++)
                {
                  sendmin = cont_sendmin[rep];
                  sendmax = cont_sendmax[rep];
                  recvmin = cont_recvmin[rep];
                  recvmax = cont_recvmax[rep];

                  /* prepare what we want to send */
                  if(sendmax - sendmin >= 0)
                    {
                      for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                        {
                          slab_xx = ((slab_x + PMGRID) % PMGRID) - 
      first_slab_of_task[ThisTask];

                          for(slab_y = meshmin_list[3 * recvTask + 1] - 2;
                              slab_y < meshmax_list[3 * recvTask + 1] + 4; slab_y
      ++)
                            {
                              slab_yy = (slab_y + PMGRID) % PMGRID;

                              for(slab_z = meshmin_list[3 * recvTask + 2] - 2;
                                  slab_z < meshmax_list[3 * recvTask + 2] + 4; sl
      ab_z++)
                                {
                                  slab_zz = (slab_z + PMGRID) % PMGRID;

                                  forcegrid[((slab_x - sendmin) * recv_dimy +
                                             (slab_y - (meshmin_list[3 * recvTask
       + 1] - 2))) * recv_dimz +
                                            slab_z - (meshmin_list[3 * recvTask +
       2] - 2)] =
                                    rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2 
      * slab_yy + slab_zz];
                                }
                            }
                        }
                    }

                  if(level > 0)
                    {
                      MPI_Sendrecv(forcegrid,
                                   (sendmax - sendmin + 1) * recv_dimy * recv_dim
      z * sizeof(fftw_real),
                                   MPI_BYTE, recvTask, TAG_PERIODIC_B,
                                   workspace + (recvmin - (meshmin[0] - 2)) * dim
      y * dimz,
                                   (recvmax - recvmin + 1) * dimy * dimz * sizeof
      (fftw_real), MPI_BYTE,
                                   recvTask, TAG_PERIODIC_B, MPI_COMM_WORLD, &sta
      tus);
                    }
                  else
                    {
                      memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * di
      mz,
                             forcegrid, (recvmax - recvmin + 1) * dimy * dimz * s
      izeof(fftw_real));
                    }
                }
            }
        }
    }


  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  recv_dimx = meshmax[0] - meshmin[0] + 6;
  recv_dimy = meshmax[1] - meshmin[1] + 6;
  recv_dimz = meshmax[2] - meshmin[2] + 6;


  for(dim = 0; dim < 3; dim++)  /* Calculate each component of the force. */
    {
      /* get the force component by finite differencing the potential */
      /* note: "workspace" now contains the potential for the local patch, plus a
       suffiently large buffer region */

      for(x = 0; x < meshmax[0] - meshmin[0] + 2; x++)
        for(y = 0; y < meshmax[1] - meshmin[1] + 2; y++)
          for(z = 0; z < meshmax[2] - meshmin[2] + 2; z++)
            {
              xrr = xll = xr = xl = x;
              yrr = yll = yr = yl = y;
              zrr = zll = zr = zl = z;

              switch (dim)
                {
                case 0:
                  xr = x + 1;
                  xrr = x + 2;
                  xl = x - 1;
                  xll = x - 2;
                  break;
                case 1:
                  yr = y + 1;
                  yl = y - 1;
                  yrr = y + 2;
                  yll = y - 2;
                  break;
                case 2:
                  zr = z + 1;
                  zl = z - 1;
                  zrr = z + 2;
                  zll = z - 2;
                  break;
                }

              forcegrid[(x * dimy + y) * dimz + z]
                =
                fac * ((4.0 / 3) *
                       (workspace[((xl + 2) * recv_dimy + (yl + 2)) * recv_dimz +
       (zl + 2)]
                        - workspace[((xr + 2) * recv_dimy + (yr + 2)) * recv_dimz
       + (zr + 2)]) -
                       (1.0 / 6) *
                       (workspace[((xll + 2) * recv_dimy + (yll + 2)) * recv_dimz
       + (zll + 2)] -
                        workspace[((xrr + 2) * recv_dimy + (yrr + 2)) * recv_dimz
       + (zrr + 2)]));
            }

      /* read out the forces */

      for(i = 0; i < NumPart; i++)
        {
          slab_x = to_slab_fac * P[i].Pos[0];
          if(slab_x >= PMGRID)
            slab_x = PMGRID - 1;
          dx = to_slab_fac * P[i].Pos[0] - slab_x;
          slab_x -= meshmin[0];
          slab_xx = slab_x + 1;

          slab_y = to_slab_fac * P[i].Pos[1];
          if(slab_y >= PMGRID)
            slab_y = PMGRID - 1;
          dy = to_slab_fac * P[i].Pos[1] - slab_y;
          slab_y -= meshmin[1];
          slab_yy = slab_y + 1;

          slab_z = to_slab_fac * P[i].Pos[2];
          if(slab_z >= PMGRID)
            slab_z = PMGRID - 1;
          dz = to_slab_fac * P[i].Pos[2] - slab_z;
          slab_z -= meshmin[2];
          slab_zz = slab_z + 1;

          acc_dim =
            forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1
      .0 - dy) * (1.0 - dz);
          acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1.0 
      - dx) * dy * (1.0 - dz);
          acc_dim += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1.0 
      - dx) * (1.0 - dy) * dz;
          acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (1.0
       - dx) * dy * dz;

          acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (dx) 
      * (1.0 - dy) * (1.0 - dz);
          acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (dx)
       * dy * (1.0 - dz);
          acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (dx)
       * (1.0 - dy) * dz;
          acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * (dx
      ) * dy * dz;

          P[i].GravPM[dim] = acc_dim;
        }
    }

  pm_init_periodic_free();
  force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);

  All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;

  if(ThisTask == 0)
    {
      printf("done PM.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9}{
\index{proto.h@{proto.h}!pmpotential\_\-nonperiodic@{pmpotential\_\-nonperiodic}}
\index{pmpotential\_\-nonperiodic@{pmpotential\_\-nonperiodic}!proto.h@{proto.h}}
\subsubsection[{pmpotential\_\-nonperiodic}]{\setlength{\rightskip}{0pt plus 5cm}int pmpotential\_\-nonperiodic (
\begin{DoxyParamCaption}
\item[{int}]{ grnr}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9}


Referenced by compute\_\-potential().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a7938f2181f23d56ac46f3625d1a855a0}{
\index{proto.h@{proto.h}!pmpotential\_\-periodic@{pmpotential\_\-periodic}}
\index{pmpotential\_\-periodic@{pmpotential\_\-periodic}!proto.h@{proto.h}}
\subsubsection[{pmpotential\_\-periodic}]{\setlength{\rightskip}{0pt plus 5cm}void pmpotential\_\-periodic (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a7938f2181f23d56ac46f3625d1a855a0}
Calculates the long-\/range potential using the PM method. The potential is Gaussian filtered with Asmth, given in mesh-\/cell units. We carry out a CIC charge assignment, and compute the potenial by Fourier transform methods. The CIC kernel is deconvolved. 

Definition at line 693 of file pm\_\-periodic.c.



References All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::BoxSize, fft\_\-forward\_\-plan, fft\_\-inverse\_\-plan, fft\_\-of\_\-rhogrid, fftsize, first\_\-slab\_\-of\_\-task, force\_\-treeallocate(), force\_\-treefree(), forcegrid, global\_\-data\_\-all\_\-processes::G, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MaxPart, meshmax\_\-list, meshmin\_\-list, nslab\_\-y, NTask, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, P, pm\_\-init\_\-periodic\_\-allocate(), pm\_\-init\_\-periodic\_\-free(), PMGRID2, particle\_\-data::Pos, particle\_\-data::Potential, PTask, rhogrid, slab\_\-to\_\-task, slabs\_\-per\_\-task, slabstart\_\-y, TAG\_\-PERIODIC\_\-C, TAG\_\-PERIODIC\_\-D, ThisTask, to\_\-slab\_\-fac, global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeAllocFactor, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, and workspace.



Referenced by compute\_\-potential().




\begin{DoxyCode}
{
  double k2, kx, ky, kz, smth;
  double dx, dy, dz;
  double fx, fy, fz, ff;
  double asmth2, fac;
  int i, j, slab, level, sendTask, recvTask;
  int x, y, z, ip;
  int slab_x, slab_y, slab_z;
  int slab_xx, slab_yy, slab_zz;
  int meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
  int rep, ncont, cont_sendmin[2], cont_sendmax[2], cont_recvmin[2], cont_recvmax
      [2];
  int dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
  MPI_Status status;

  if(ThisTask == 0)
    {
      printf("Starting periodic PM calculation.\n");
      fflush(stdout);
    }

  asmth2 = (2 * M_PI) * All.Asmth[0] / All.BoxSize;
  asmth2 *= asmth2;

  fac = All.G / (M_PI * All.BoxSize);   /* to get potential */

  force_treefree();

  /* first, establish the extension of the local patch in the PMGRID  */

  for(j = 0; j < 3; j++)
    {
      meshmin[j] = PMGRID;
      meshmax[j] = 0;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          slab = to_slab_fac * P[i].Pos[j];
          if(slab >= PMGRID)
            slab = PMGRID - 1;

          if(slab < meshmin[j])
            meshmin[j] = slab;

          if(slab > meshmax[j])
            meshmax[j] = slab;
        }
    }

  MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
  MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);

  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  pm_init_periodic_allocate((dimx + 4) * (dimy + 4) * (dimz + 4));

  for(i = 0; i < dimx * dimy * dimz; i++)
    workspace[i] = 0;

  for(i = 0; i < NumPart; i++)
    {
      slab_x = to_slab_fac * P[i].Pos[0];
      if(slab_x >= PMGRID)
        slab_x = PMGRID - 1;
      dx = to_slab_fac * P[i].Pos[0] - slab_x;
      slab_x -= meshmin[0];
      slab_xx = slab_x + 1;

      slab_y = to_slab_fac * P[i].Pos[1];
      if(slab_y >= PMGRID)
        slab_y = PMGRID - 1;
      dy = to_slab_fac * P[i].Pos[1] - slab_y;
      slab_y -= meshmin[1];
      slab_yy = slab_y + 1;

      slab_z = to_slab_fac * P[i].Pos[2];
      if(slab_z >= PMGRID)
        slab_z = PMGRID - 1;
      dz = to_slab_fac * P[i].Pos[2] - slab_z;
      slab_z -= meshmin[2];
      slab_zz = slab_z + 1;

      workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (1.0 - d
      x) * (1.0 - dy) * (1.0 - dz);
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (1.0 - 
      dx) * dy * (1.0 - dz);
      workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (1.0 - 
      dx) * (1.0 - dy) * dz;
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (1.0 -
       dx) * dy * dz;

      workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (dx) * 
      (1.0 - dy) * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (dx) *
       dy * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (dx) *
       (1.0 - dy) * dz;
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (dx) 
      * dy * dz;
    }


  for(i = 0; i < fftsize; i++)  /* clear local density field */
    rhogrid[i] = 0;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is t
      he same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;
      if(recvTask < NTask)
        {
          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -1;
          for(slab_x = meshmin[0]; slab_x < meshmax[0] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == recvTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -1)
            sendmin = 0;

          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -1;
          for(slab_x = meshmin_list[3 * recvTask]; slab_x < meshmax_list[3 * recv
      Task] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == sendTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -1)
            recvmin = 0;


          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok, we
       have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvT
      ask + 0] + 2;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvT
      ask + 1] + 2;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvT
      ask + 2] + 2;

              if(level > 0)
                {
                  MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz,
                               (sendmax - sendmin + 1) * dimy * dimz * sizeof(fft
      w_real), MPI_BYTE, recvTask,
                               TAG_PERIODIC_C, forcegrid,
                               (recvmax - recvmin + 1) * recv_dimy * recv_dimz * 
      sizeof(fftw_real), MPI_BYTE,
                               recvTask, TAG_PERIODIC_C, MPI_COMM_WORLD, &status)
      ;
                }
              else
                {
                  memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy * d
      imz,
                         (sendmax - sendmin + 1) * dimy * dimz * sizeof(fftw_real
      ));
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  slab_xx = (slab_x % PMGRID) - first_slab_of_task[ThisTask];

                  if(slab_xx >= 0 && slab_xx < slabs_per_task[ThisTask])
                    {
                      for(slab_y = meshmin_list[3 * recvTask + 1];
                          slab_y <= meshmax_list[3 * recvTask + 1] + 1; slab_y++)
      
                        {
                          slab_yy = slab_y;
                          if(slab_yy >= PMGRID)
                            slab_yy -= PMGRID;

                          for(slab_z = meshmin_list[3 * recvTask + 2];
                              slab_z <= meshmax_list[3 * recvTask + 2] + 1; slab_
      z++)
                            {
                              slab_zz = slab_z;
                              if(slab_zz >= PMGRID)
                                slab_zz -= PMGRID;

                              rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2 * slab
      _yy + slab_zz] +=
                                forcegrid[((slab_x - recvmin) * recv_dimy +
                                           (slab_y - meshmin_list[3 * recvTask + 
      1])) * recv_dimz +
                                          (slab_z - meshmin_list[3 * recvTask + 2
      ])];
                            }
                        }
                    }
                }
            }
        }
    }



  /* Do the FFT of the density field */

  rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* multiply with Green's function for the potential */

  for(y = slabstart_y; y < slabstart_y + nslab_y; y++)
    for(x = 0; x < PMGRID; x++)
      for(z = 0; z < PMGRID / 2 + 1; z++)
        {
          if(x > PMGRID / 2)
            kx = x - PMGRID;
          else
            kx = x;
          if(y > PMGRID / 2)
            ky = y - PMGRID;
          else
            ky = y;
          if(z > PMGRID / 2)
            kz = z - PMGRID;
          else
            kz = z;

          k2 = kx * kx + ky * ky + kz * kz;

          if(k2 > 0)
            {
              smth = -exp(-k2 * asmth2) / k2 * fac;
              /* do deconvolution */
              fx = fy = fz = 1;
              if(kx != 0)
                {
                  fx = (M_PI * kx) / PMGRID;
                  fx = sin(fx) / fx;
                }
              if(ky != 0)
                {
                  fy = (M_PI * ky) / PMGRID;
                  fy = sin(fy) / fy;
                }
              if(kz != 0)
                {
                  fz = (M_PI * kz) / PMGRID;
                  fz = sin(fz) / fz;
                }
              ff = 1 / (fx * fy * fz);
              smth *= ff * ff * ff * ff;
              /* end deconvolution */

              ip = PMGRID * (PMGRID / 2 + 1) * (y - slabstart_y) + (PMGRID / 2 + 
      1) * x + z;
              fft_of_rhogrid[ip].re *= smth;
              fft_of_rhogrid[ip].im *= smth;
            }
        }

  if(slabstart_y == 0)
    fft_of_rhogrid[0].re = fft_of_rhogrid[0].im = 0.0;

  /* Do the FFT to get the potential */

  rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* note: "rhogrid" now contains the potential */



  dimx = meshmax[0] - meshmin[0] + 6;
  dimy = meshmax[1] - meshmin[1] + 6;
  dimz = meshmax[2] - meshmin[2] + 6;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is t
      he same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        {

          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -PMGRID;
          for(slab_x = meshmin_list[3 * recvTask] - 2; slab_x < meshmax_list[3 * 
      recvTask] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == sendTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -PMGRID)
            sendmin = sendmax + 1;


          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -PMGRID;
          for(slab_x = meshmin[0] - 2; slab_x < meshmax[0] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == recvTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -PMGRID)
            recvmin = recvmax + 1;

          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok, we
       have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * recvT
      ask + 0] + 6;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * recvT
      ask + 1] + 6;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * recvT
      ask + 2] + 6;

              ncont = 1;
              cont_sendmin[0] = sendmin;
              cont_sendmax[0] = sendmax;
              cont_sendmin[1] = sendmax + 1;
              cont_sendmax[1] = sendmax;

              cont_recvmin[0] = recvmin;
              cont_recvmax[0] = recvmax;
              cont_recvmin[1] = recvmax + 1;
              cont_recvmax[1] = recvmax;

              for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
                    {
                      /* non-contiguous */
                      cont_sendmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
      
                        slab_x++;
                      cont_sendmin[1] = slab_x;
                      ncont++;
                    }
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
                    {
                      /* non-contiguous */
                      cont_recvmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
      
                        slab_x++;
                      cont_recvmin[1] = slab_x;
                      if(ncont == 1)
                        ncont++;
                    }
                }


              for(rep = 0; rep < ncont; rep++)
                {
                  sendmin = cont_sendmin[rep];
                  sendmax = cont_sendmax[rep];
                  recvmin = cont_recvmin[rep];
                  recvmax = cont_recvmax[rep];

                  /* prepare what we want to send */
                  if(sendmax - sendmin >= 0)
                    {
                      for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                        {
                          slab_xx = ((slab_x + PMGRID) % PMGRID) - 
      first_slab_of_task[ThisTask];

                          for(slab_y = meshmin_list[3 * recvTask + 1] - 2;
                              slab_y < meshmax_list[3 * recvTask + 1] + 4; slab_y
      ++)
                            {
                              slab_yy = (slab_y + PMGRID) % PMGRID;

                              for(slab_z = meshmin_list[3 * recvTask + 2] - 2;
                                  slab_z < meshmax_list[3 * recvTask + 2] + 4; sl
      ab_z++)
                                {
                                  slab_zz = (slab_z + PMGRID) % PMGRID;

                                  forcegrid[((slab_x - sendmin) * recv_dimy +
                                             (slab_y - (meshmin_list[3 * recvTask
       + 1] - 2))) * recv_dimz +
                                            slab_z - (meshmin_list[3 * recvTask +
       2] - 2)] =
                                    rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2 
      * slab_yy + slab_zz];
                                }
                            }
                        }
                    }

                  if(level > 0)
                    {
                      MPI_Sendrecv(forcegrid,
                                   (sendmax - sendmin + 1) * recv_dimy * recv_dim
      z * sizeof(fftw_real),
                                   MPI_BYTE, recvTask, TAG_PERIODIC_D,
                                   workspace + (recvmin - (meshmin[0] - 2)) * dim
      y * dimz,
                                   (recvmax - recvmin + 1) * dimy * dimz * sizeof
      (fftw_real), MPI_BYTE,
                                   recvTask, TAG_PERIODIC_D, MPI_COMM_WORLD, &sta
      tus);
                    }
                  else
                    {
                      memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * di
      mz,
                             forcegrid, (recvmax - recvmin + 1) * dimy * dimz * s
      izeof(fftw_real));
                    }
                }
            }
        }
    }


  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  recv_dimx = meshmax[0] - meshmin[0] + 6;
  recv_dimy = meshmax[1] - meshmin[1] + 6;
  recv_dimz = meshmax[2] - meshmin[2] + 6;



  for(x = 0; x < meshmax[0] - meshmin[0] + 2; x++)
    for(y = 0; y < meshmax[1] - meshmin[1] + 2; y++)
      for(z = 0; z < meshmax[2] - meshmin[2] + 2; z++)
        {
          forcegrid[(x * dimy + y) * dimz + z] =
            workspace[((x + 2) * recv_dimy + (y + 2)) * recv_dimz + (z + 2)];
        }


  /* read out the potential */

  for(i = 0; i < NumPart; i++)
    {
      slab_x = to_slab_fac * P[i].Pos[0];
      if(slab_x >= PMGRID)
        slab_x = PMGRID - 1;
      dx = to_slab_fac * P[i].Pos[0] - slab_x;
      slab_x -= meshmin[0];
      slab_xx = slab_x + 1;

      slab_y = to_slab_fac * P[i].Pos[1];
      if(slab_y >= PMGRID)
        slab_y = PMGRID - 1;
      dy = to_slab_fac * P[i].Pos[1] - slab_y;
      slab_y -= meshmin[1];
      slab_yy = slab_y + 1;

      slab_z = to_slab_fac * P[i].Pos[2];
      if(slab_z >= PMGRID)
        slab_z = PMGRID - 1;
      dz = to_slab_fac * P[i].Pos[2] - slab_z;
      slab_z -= meshmin[2];
      slab_zz = slab_z + 1;

      P[i].Potential +=
        forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1.0 -
       dy) * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1
      .0 - dx) * dy * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1
      .0 - dx) * (1.0 - dy) * dz;
      P[i].Potential += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (
      1.0 - dx) * dy * dz;

      P[i].Potential += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (d
      x) * (1.0 - dy) * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (
      dx) * dy * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (
      dx) * (1.0 - dy) * dz;
      P[i].Potential += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * 
      (dx) * dy * dz;
    }

  pm_init_periodic_free();
  force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);

  All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;

  if(ThisTask == 0)
    {
      printf("done PM-Potential.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a7938f2181f23d56ac46f3625d1a855a0_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a7938f2181f23d56ac46f3625d1a855a0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e}{
\index{proto.h@{proto.h}!pow@{pow}}
\index{pow@{pow}!proto.h@{proto.h}}
\subsubsection[{pow}]{\setlength{\rightskip}{0pt plus 5cm}double pow (
\begin{DoxyParamCaption}
\item[{double}]{, }
\item[{double}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e}


Referenced by advance\_\-and\_\-find\_\-timesteps(), compute\_\-global\_\-quantities\_\-of\_\-system(), compute\_\-potential(), density(), fill\_\-write\_\-buffer(), find\_\-dt\_\-displacement\_\-constraint(), growthfactor\_\-integ(), hydro\_\-force(), hydrokick\_\-integ(), init(), move\_\-particles(), set\_\-units(), setup\_\-smoothinglengths(), and timediff().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1}{
\index{proto.h@{proto.h}!read\_\-file@{read\_\-file}}
\index{read\_\-file@{read\_\-file}!proto.h@{proto.h}}
\subsubsection[{read\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void read\_\-file (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname, }
\item[{int}]{ readTask, }
\item[{int}]{ lastTask}
\end{DoxyParamCaption}
)}}
\label{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1}
This function reads a snapshot file and distributes the data it contains to tasks 'readTask' to 'lastTask'. 

$<$ total number of defined 0 0 for snapshot files. Must be equal to the number of entries in \char`\"{}enum iofields\char`\"{} 



Definition at line 244 of file read\_\-ic.c.



References All, allocate\_\-memory(), blockpresent(), global\_\-data\_\-all\_\-processes::BufferSize, CommBuffer, empty\_\-read\_\-buffer(), endrun(), fd, get\_\-bytes\_\-per\_\-blockelement(), get\_\-dataset\_\-name(), get\_\-datatype\_\-in\_\-block(), get\_\-particles\_\-in\_\-block(), get\_\-values\_\-per\_\-blockelement(), header, global\_\-data\_\-all\_\-processes::ICFormat, IO\_\-U, io\_\-header::mass, global\_\-data\_\-all\_\-processes::MassTable, global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MaxPartSph, my\_\-fread(), N\_\-gas, io\_\-header::npart, io\_\-header::npartTotal, io\_\-header::npartTotalHighWord, NTask, io\_\-header::num\_\-files, NumPart, P, global\_\-data\_\-all\_\-processes::PartAllocFactor, read\_\-header\_\-attributes\_\-in\_\-hdf5(), RestartFlag, Tab\_\-IO\_\-Labels, TAG\_\-HEADER, TAG\_\-PDATA, ThisTask, io\_\-header::time, global\_\-data\_\-all\_\-processes::Time, global\_\-data\_\-all\_\-processes::TimeBegin, global\_\-data\_\-all\_\-processes::TotN\_\-gas, and global\_\-data\_\-all\_\-processes::TotNumPart.



Referenced by read\_\-ic().




\begin{DoxyCode}
{
  int blockmaxlen;
  int i, n_in_file, n_for_this_task, ntask, pc, offset = 0, task;
  int blksize1, blksize2;
  MPI_Status status;
  FILE *fd = 0;
  int nall;
  int type;
  char label[4];
  int nstart, bytes_per_blockelement, npart, nextblock, typelist[6];
  enum iofields blocknr;

#ifdef HAVE_HDF5
  char buf[500];
  int rank, pcsum;
  hid_t hdf5_file, hdf5_grp[6], hdf5_dataspace_in_file;
  hid_t hdf5_datatype, hdf5_dataspace_in_memory, hdf5_dataset;
  hsize_t dims[2], count[2], start[2];
#endif

#define SKIP  {my_fread(&blksize1,sizeof(int),1,fd);}
#define SKIP2  {my_fread(&blksize2,sizeof(int),1,fd);}

  if(ThisTask == readTask)
    {
      if(All.ICFormat == 1 || All.ICFormat == 2)
        {
          if(!(fd = fopen(fname, "r")))
            {
              printf("can't open file `%s' for reading initial conditions.\n", fn
      ame);
              endrun(123);
            }

          if(All.ICFormat == 2)
            {
              SKIP;
              my_fread(&label, sizeof(char), 4, fd);
              my_fread(&nextblock, sizeof(int), 1, fd);
              printf("Reading header => '%c%c%c%c' (%d byte)\n", label[0], label[
      1], label[2], label[3],
                     nextblock);
              SKIP2;
            }

          SKIP;
          my_fread(&header, sizeof(header), 1, fd);
          SKIP2;

          if(blksize1 != 256 || blksize2 != 256)
            {
              printf("incorrect header format\n");
              fflush(stdout);
              endrun(890);
            }
        }


#ifdef HAVE_HDF5
      if(All.ICFormat == 3)
        {
          read_header_attributes_in_hdf5(fname);

          hdf5_file = H5Fopen(fname, H5F_ACC_RDONLY, H5P_DEFAULT);

          for(type = 0; type < 6; type++)
            {
              if(header.npart[type] > 0)
                {
                  sprintf(buf, "/PartType%d", type);
                  hdf5_grp[type] = H5Gopen(hdf5_file, buf);
                }
            }
        }
#endif

      for(task = readTask + 1; task <= lastTask; task++)
        MPI_Ssend(&header, sizeof(header), MPI_BYTE, task, TAG_HEADER, MPI_COMM_W
      ORLD);
    }
  else
    MPI_Recv(&header, sizeof(header), MPI_BYTE, readTask, TAG_HEADER, MPI_COMM_WO
      RLD, &status);


  if(All.TotNumPart == 0)
    {
      if(header.num_files <= 1)
        for(i = 0; i < 6; i++)
          header.npartTotal[i] = header.npart[i];

      All.TotN_gas = header.npartTotal[0] + (((long long) header.
      npartTotalHighWord[0]) << 32);

      for(i = 0, All.TotNumPart = 0; i < 6; i++)
        {
          All.TotNumPart += header.npartTotal[i];
          All.TotNumPart += (((long long) header.npartTotalHighWord[i]) << 32);
        }


      for(i = 0; i < 6; i++)
        All.MassTable[i] = header.mass[i];

      All.MaxPart = All.PartAllocFactor * (All.TotNumPart / NTask);     /* sets t
      he maximum number of particles that may */
      All.MaxPartSph = All.PartAllocFactor * (All.TotN_gas / NTask);    /* sets t
      he maximum number of particles that may 
                                                                           reside
       on a processor */
      allocate_memory();

      if(RestartFlag == 2)
        All.Time = All.TimeBegin = header.time;
    }

  if(ThisTask == readTask)
    {
      for(i = 0, n_in_file = 0; i < 6; i++)
        n_in_file += header.npart[i];

      printf("\nreading file `%s' on task=%d (contains %d particles.)\n"
             "distributing this file to tasks %d-%d\n"
             "Type 0 (gas):   %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 1 (halo):  %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 2 (disk):  %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 3 (bulge): %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 4 (stars): %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 5 (bndry): %8d  (tot=%6d%09d) masstab=%g\n\n", fname, 
      ThisTask, n_in_file, readTask,
             lastTask, header.npart[0], (int) (header.npartTotal[0] / 1000000000)
      ,
             (int) (header.npartTotal[0] % 1000000000), All.MassTable[0], header.
      npart[1],
             (int) (header.npartTotal[1] / 1000000000), (int) (header.npartTotal[
      1] % 1000000000),
             All.MassTable[1], header.npart[2], (int) (header.npartTotal[2] / 100
      0000000),
             (int) (header.npartTotal[2] % 1000000000), All.MassTable[2], header.
      npart[3],
             (int) (header.npartTotal[3] / 1000000000), (int) (header.npartTotal[
      3] % 1000000000),
             All.MassTable[3], header.npart[4], (int) (header.npartTotal[4] / 100
      0000000),
             (int) (header.npartTotal[4] % 1000000000), All.MassTable[4], header.
      npart[5],
             (int) (header.npartTotal[5] / 1000000000), (int) (header.npartTotal[
      5] % 1000000000),
             All.MassTable[5]);
      fflush(stdout);
    }


  ntask = lastTask - readTask + 1;


  /* to collect the gas particles all at the beginning (in case several
     snapshot files are read on the current CPU) we move the collisionless
     particles such that a gap of the right size is created */

  for(type = 0, nall = 0; type < 6; type++)
    {
      n_in_file = header.npart[type];

      n_for_this_task = n_in_file / ntask;
      if((ThisTask - readTask) < (n_in_file % ntask))
        n_for_this_task++;

      nall += n_for_this_task;
    }

  memmove(&P[N_gas + nall], &P[N_gas], (NumPart - N_gas) * sizeof(struct 
      particle_data));
  nstart = N_gas;



  for(blocknr = 0; blocknr < IO_NBLOCKS; blocknr++)
    {
      if(blockpresent(blocknr))
        {
          if(RestartFlag == 0 && blocknr > IO_U)
            continue;           /* ignore all other blocks in initial conditions 
      */

          bytes_per_blockelement = get_bytes_per_blockelement(blocknr);

          blockmaxlen = ((int) (All.BufferSize * 1024 * 1024)) / bytes_per_blocke
      lement;

          npart = get_particles_in_block(blocknr, &typelist[0]);

          if(npart > 0)
            {
              if(ThisTask == readTask)
                {
                  if(All.ICFormat == 2)
                    {
                      SKIP;
                      my_fread(&label, sizeof(char), 4, fd);
                      my_fread(&nextblock, sizeof(int), 1, fd);
                      printf("Reading header => '%c%c%c%c' (%d byte)\n", label[0]
      , label[1], label[2],
                             label[3], nextblock);
                      SKIP2;

                      if(strncmp(label, Tab_IO_Labels[blocknr], 4) != 0)
                        {
                          printf("incorrect block-structure!\n");
                          printf("expected '%c%c%c%c' but found '%c%c%c%c'\n",
                                 label[0], label[1], label[2], label[3],
                                 Tab_IO_Labels[blocknr][0], Tab_IO_Labels[blocknr
      ][1],
                                 Tab_IO_Labels[blocknr][2], Tab_IO_Labels[blocknr
      ][3]);
                          fflush(stdout);
                          endrun(1890);
                        }
                    }

                  if(All.ICFormat == 1 || All.ICFormat == 2)
                    SKIP;
                }

              for(type = 0, offset = 0; type < 6; type++)
                {
                  n_in_file = header.npart[type];
#ifdef HAVE_HDF5
                  pcsum = 0;
#endif
                  if(typelist[type] == 0)
                    {
                      n_for_this_task = n_in_file / ntask;
                      if((ThisTask - readTask) < (n_in_file % ntask))
                        n_for_this_task++;

                      offset += n_for_this_task;
                    }
                  else
                    {
                      for(task = readTask; task <= lastTask; task++)
                        {
                          n_for_this_task = n_in_file / ntask;
                          if((task - readTask) < (n_in_file % ntask))
                            n_for_this_task++;

                          if(task == ThisTask)
                            if(NumPart + n_for_this_task > All.MaxPart)
                              {
                                printf("too many particles\n");
                                endrun(1313);
                              }


                          do
                            {
                              pc = n_for_this_task;

                              if(pc > blockmaxlen)
                                pc = blockmaxlen;

                              if(ThisTask == readTask)
                                {
                                  if(All.ICFormat == 1 || All.ICFormat == 2)
                                    my_fread(CommBuffer, bytes_per_blockelement, 
      pc, fd);
#ifdef HAVE_HDF5
                                  if(All.ICFormat == 3)
                                    {
                                      get_dataset_name(blocknr, buf);
                                      hdf5_dataset = H5Dopen(hdf5_grp[type], buf)
      ;

                                      dims[0] = header.npart[type];
                                      dims[1] = get_values_per_blockelement(block
      nr);
                                      if(dims[1] == 1)
                                        rank = 1;
                                      else
                                        rank = 2;

                                      hdf5_dataspace_in_file = H5Screate_simple(r
      ank, dims, NULL);

                                      dims[0] = pc;
                                      hdf5_dataspace_in_memory = H5Screate_simple
      (rank, dims, NULL);

                                      start[0] = pcsum;
                                      start[1] = 0;

                                      count[0] = pc;
                                      count[1] = get_values_per_blockelement(bloc
      knr);
                                      pcsum += pc;

                                      H5Sselect_hyperslab(hdf5_dataspace_in_file,
       H5S_SELECT_SET,
                                                          start, NULL, count, NUL
      L);

                                      switch (get_datatype_in_block(blocknr))
                                        {
                                        case 0:
                                          hdf5_datatype = H5Tcopy(H5T_NATIVE_UINT
      );
                                          break;
                                        case 1:
                                          hdf5_datatype = H5Tcopy(H5T_NATIVE_FLOA
      T);
                                          break;
                                        case 2:
                                          hdf5_datatype = H5Tcopy(H5T_NATIVE_UINT
      64);
                                          break;
                                        }

                                      H5Dread(hdf5_dataset, hdf5_datatype, hdf5_d
      ataspace_in_memory,
                                              hdf5_dataspace_in_file, H5P_DEFAULT
      , CommBuffer);

                                      H5Tclose(hdf5_datatype);
                                      H5Sclose(hdf5_dataspace_in_memory);
                                      H5Sclose(hdf5_dataspace_in_file);
                                      H5Dclose(hdf5_dataset);
                                    }
#endif
                                }

                              if(ThisTask == readTask && task != readTask)
                                MPI_Ssend(CommBuffer, bytes_per_blockelement * pc
      , MPI_BYTE, task, TAG_PDATA,
                                          MPI_COMM_WORLD);

                              if(ThisTask != readTask && task == ThisTask)
                                MPI_Recv(CommBuffer, bytes_per_blockelement * pc,
       MPI_BYTE, readTask,
                                         TAG_PDATA, MPI_COMM_WORLD, &status);

                              if(ThisTask == task)
                                {
                                  empty_read_buffer(blocknr, nstart + offset, pc,
       type);

                                  offset += pc;
                                }

                              n_for_this_task -= pc;
                            }
                          while(n_for_this_task > 0);
                        }
                    }
                }
              if(ThisTask == readTask)
                {
                  if(All.ICFormat == 1 || All.ICFormat == 2)
                    {
                      SKIP2;
                      if(blksize1 != blksize2)
                        {
                          printf("incorrect block-sizes detected!\n");
                          printf("Task=%d   blocknr=%d  blksize1=%d  blksize2=%d\
      n", ThisTask, blocknr,
                                 blksize1, blksize2);
                          fflush(stdout);
                          endrun(1889);
                        }
                    }
                }
            }
        }
    }


  for(type = 0; type < 6; type++)
    {
      n_in_file = header.npart[type];

      n_for_this_task = n_in_file / ntask;
      if((ThisTask - readTask) < (n_in_file % ntask))
        n_for_this_task++;

      NumPart += n_for_this_task;

      if(type == 0)
        N_gas += n_for_this_task;
    }

  if(ThisTask == readTask)
    {
      if(All.ICFormat == 1 || All.ICFormat == 2)
        fclose(fd);
#ifdef HAVE_HDF5
      if(All.ICFormat == 3)
        {
          for(type = 5; type >= 0; type--)
            if(header.npart[type] > 0)
              H5Gclose(hdf5_grp[type]);
          H5Fclose(hdf5_file);
        }
#endif
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9}{
\index{proto.h@{proto.h}!read\_\-header\_\-attributes\_\-in\_\-hdf5@{read\_\-header\_\-attributes\_\-in\_\-hdf5}}
\index{read\_\-header\_\-attributes\_\-in\_\-hdf5@{read\_\-header\_\-attributes\_\-in\_\-hdf5}!proto.h@{proto.h}}
\subsubsection[{read\_\-header\_\-attributes\_\-in\_\-hdf5}]{\setlength{\rightskip}{0pt plus 5cm}void read\_\-header\_\-attributes\_\-in\_\-hdf5 (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9}
This function reads the header information in case the HDF5 file format is used. 

Definition at line 764 of file read\_\-ic.c.



References io\_\-header::flag\_\-entropy\_\-instead\_\-u, header, io\_\-header::mass, io\_\-header::npart, io\_\-header::npartTotal, io\_\-header::npartTotalHighWord, io\_\-header::num\_\-files, and io\_\-header::time.



Referenced by find\_\-files(), and read\_\-file().




\begin{DoxyCode}
{
  hid_t hdf5_file, hdf5_headergrp, hdf5_attribute;


  hdf5_file = H5Fopen(fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  hdf5_headergrp = H5Gopen(hdf5_file, "/Header");


  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumPart_ThisFile");
  H5Aread(hdf5_attribute, H5T_NATIVE_INT, header.npart);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumPart_Total");
  H5Aread(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotal);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumPart_Total_HighWord");
  H5Aread(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotalHighWord);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "MassTable");
  H5Aread(hdf5_attribute, H5T_NATIVE_DOUBLE, header.mass);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "Time");
  H5Aread(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.time);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumFilesPerSnapshot");
  H5Aread(hdf5_attribute, H5T_NATIVE_INT, &header.num_files);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "Flag_Entropy_ICs");
  H5Aread(hdf5_attribute, H5T_NATIVE_INT, &header.flag_entropy_instead_u);
  H5Aclose(hdf5_attribute);

  H5Gclose(hdf5_headergrp);
  H5Fclose(hdf5_file);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a150344fdc0c6e132aecdb6c646529df1}{
\index{proto.h@{proto.h}!read\_\-ic@{read\_\-ic}}
\index{read\_\-ic@{read\_\-ic}!proto.h@{proto.h}}
\subsubsection[{read\_\-ic}]{\setlength{\rightskip}{0pt plus 5cm}void read\_\-ic (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a150344fdc0c6e132aecdb6c646529df1}
This function reads initial conditions, in one of the three possible file formats currently supported by Gadget. Note: When a snapshot file is started from initial conditions (start-\/option 0), not all the information in the header is used, in particular, the STARTING TIME needs to be set in the parameterfile. Also, for gas particles, only the internal energy is read, the density and mean molecular weight will be recomputed by the code. When InitGasTemp$>$0 is given, the gas temperature will be initialzed to this value assuming a mean colecular weight either corresponding to complete neutrality, or full ionization.

However, when the code is started with start-\/option 2, then all the this data in the snapshot files is preserved, i.e. this is also the way to resume a simulation from a snapshot file in case a regular restart file is not available. 

$<$ adiabatic index of simulated gas

$<$ mass fraction of hydrogen, relevant only for radiative cooling

$<$ mass fraction of hydrogen, relevant only for radiative cooling 



Definition at line 31 of file read\_\-ic.c.



References All, BOLTZMANN, distribute\_\-file(), dmax(), sph\_\-particle\_\-data::Entropy, fill\_\-Tab\_\-IO\_\-Labels(), find\_\-files(), GAMMA\_\-MINUS1, global\_\-data\_\-all\_\-processes::ICFormat, global\_\-data\_\-all\_\-processes::InitGasTemp, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MassTable, global\_\-data\_\-all\_\-processes::MinEgySpec, N\_\-gas, NTask, global\_\-data\_\-all\_\-processes::NumFilesWrittenInParallel, NumPart, P, read\_\-file(), RestartFlag, SphP, ThisTask, global\_\-data\_\-all\_\-processes::TotNumPart, particle\_\-data::Type, global\_\-data\_\-all\_\-processes::UnitEnergy\_\-in\_\-cgs, and global\_\-data\_\-all\_\-processes::UnitMass\_\-in\_\-g.



Referenced by init().




\begin{DoxyCode}
{
  int i, num_files, rest_files, ngroups, gr, filenr, masterTask, lastTask, groupM
      aster;
  double u_init;
  char buf[500];

#ifndef ISOTHERM_EQS
  double molecular_weight;
#endif
#ifdef SFR
  double original_gas_mass, mass, masstot;
#endif

  NumPart = 0;
  N_gas = 0;
  All.TotNumPart = 0;

  num_files = find_files(fname);

  rest_files = num_files;

  fill_Tab_IO_Labels();

  while(rest_files > NTask)
    {
      sprintf(buf, "%s.%d", fname, ThisTask + (rest_files - NTask));
      if(All.ICFormat == 3)
        sprintf(buf, "%s.%d.hdf5", fname, ThisTask + (rest_files - NTask));

      ngroups = NTask / All.NumFilesWrittenInParallel;
      if((NTask % All.NumFilesWrittenInParallel))
        ngroups++;
      groupMaster = (ThisTask / ngroups) * ngroups;

      for(gr = 0; gr < ngroups; gr++)
        {
          if(ThisTask == (groupMaster + gr))    /* ok, it's this processor's turn
       */
            read_file(buf, ThisTask, ThisTask);
          MPI_Barrier(MPI_COMM_WORLD);
        }

      rest_files -= NTask;
    }


  if(rest_files > 0)
    {
      distribute_file(rest_files, 0, 0, NTask - 1, &filenr, &masterTask, &lastTas
      k);

      if(num_files > 1)
        {
          sprintf(buf, "%s.%d", fname, filenr);
          if(All.ICFormat == 3)
            sprintf(buf, "%s.%d.hdf5", fname, filenr);
        }
      else
        {
          sprintf(buf, "%s", fname);
          if(All.ICFormat == 3)
            sprintf(buf, "%s.hdf5", fname);
        }

      ngroups = rest_files / All.NumFilesWrittenInParallel;
      if((rest_files % All.NumFilesWrittenInParallel))
        ngroups++;

      for(gr = 0; gr < ngroups; gr++)
        {
          if((filenr / All.NumFilesWrittenInParallel) == gr)    /* ok, it's this 
      processor's turn */
            read_file(buf, masterTask, lastTask);
          MPI_Barrier(MPI_COMM_WORLD);
        }
    }


  /* this makes sure that masses are initialized in the case that the mass-block
     is completely empty */
  for(i = 0; i < NumPart; i++)
    {
      if(All.MassTable[P[i].Type] != 0)
        P[i].Mass = All.MassTable[P[i].Type];
    }

  if(RestartFlag == 0)
    {
      if(All.InitGasTemp > 0)
        {
          u_init = (BOLTZMANN / PROTONMASS) * All.InitGasTemp;
          u_init *= All.UnitMass_in_g / All.UnitEnergy_in_cgs;  /* unit conversio
      n */

#ifdef ISOTHERM_EQS
          u_init *= 1.0;
#else
          u_init *= (1.0 / GAMMA_MINUS1);

          if(All.InitGasTemp > 1.0e4)   /* assuming FULL ionization */
            molecular_weight = 4 / (8 - 5 * (1 - HYDROGEN_MASSFRAC));
          else                  /* assuming NEUTRAL GAS */
            molecular_weight = 4 / (1 + 3 * HYDROGEN_MASSFRAC);

          u_init /= molecular_weight;
#endif

          for(i = 0; i < N_gas; i++)
            {
              if(SphP[i].Entropy == 0)
                SphP[i].Entropy = u_init;

              /* Note: the coversion to entropy will be done in the function init
      (),
                 after the densities have been computed */
            }
        }
    }

  for(i = 0; i < N_gas; i++)
    SphP[i].Entropy = dmax(All.MinEgySpec, SphP[i].Entropy);

  MPI_Barrier(MPI_COMM_WORLD);

  if(ThisTask == 0)
    {
      printf("reading done.\n");
      fflush(stdout);
    }

  if(ThisTask == 0)
    {
      printf("Total number of particles :  %d%09d\n\n",
             (int) (All.TotNumPart / 1000000000), (int) (All.TotNumPart % 1000000
      000));
      fflush(stdout);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a150344fdc0c6e132aecdb6c646529df1_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=364pt]{proto_8h_a150344fdc0c6e132aecdb6c646529df1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a849a294ac908c933ffb82dc4319af513}{
\index{proto.h@{proto.h}!read\_\-outputlist@{read\_\-outputlist}}
\index{read\_\-outputlist@{read\_\-outputlist}!proto.h@{proto.h}}
\subsubsection[{read\_\-outputlist}]{\setlength{\rightskip}{0pt plus 5cm}int read\_\-outputlist (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a849a294ac908c933ffb82dc4319af513}
this function reads a table with a list of desired output times. The table does not have to be ordered in any way, but may not contain more than MAXLEN\_\-OUTPUTLIST entries. 

$<$ maxmimum number of entries in list of snapshot output times 



Definition at line 769 of file begrun.c.



References All, fd, MAXLEN\_\-OUTPUTLIST, global\_\-data\_\-all\_\-processes::OutputListLength, and global\_\-data\_\-all\_\-processes::OutputListTimes.



Referenced by read\_\-parameter\_\-file().




\begin{DoxyCode}
{
  FILE *fd;

  if(!(fd = fopen(fname, "r")))
    {
      printf("can't read output list in file '%s'\n", fname);
      return 1;
    }

  All.OutputListLength = 0;
  do
    {
      if(fscanf(fd, " %lg ", &All.OutputListTimes[All.OutputListLength]) == 1)
        All.OutputListLength++;
      else
        break;
    }
  while(All.OutputListLength < MAXLEN_OUTPUTLIST);

  fclose(fd);

  printf("\nfound %d times in output-list.\n", All.OutputListLength);

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a849a294ac908c933ffb82dc4319af513_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a952eae1977b498c4fdfabed1742a3ba2}{
\index{proto.h@{proto.h}!read\_\-parameter\_\-file@{read\_\-parameter\_\-file}}
\index{read\_\-parameter\_\-file@{read\_\-parameter\_\-file}!proto.h@{proto.h}}
\subsubsection[{read\_\-parameter\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void read\_\-parameter\_\-file (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a952eae1977b498c4fdfabed1742a3ba2}
This function parses the parameterfile in a simple way. Each paramater is defined by a keyword (`tag'), and can be either of type double, int, or character string. The routine makes sure that each parameter appears exactly once in the parameterfile, otherwise error messages are produced that complain about the missing parameters. 

Definition at line 284 of file begrun.c.



References All, global\_\-data\_\-all\_\-processes::ArtBulkViscConst, global\_\-data\_\-all\_\-processes::BoxSize, global\_\-data\_\-all\_\-processes::BufferSize, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CourantFac, global\_\-data\_\-all\_\-processes::CpuFile, global\_\-data\_\-all\_\-processes::CpuTimeBetRestartFile, global\_\-data\_\-all\_\-processes::DesNumNgb, DOUBLE, endrun(), global\_\-data\_\-all\_\-processes::EnergyFile, global\_\-data\_\-all\_\-processes::ErrTolForceAcc, global\_\-data\_\-all\_\-processes::ErrTolIntAccuracy, global\_\-data\_\-all\_\-processes::ErrTolTheta, fd, global\_\-data\_\-all\_\-processes::GravityConstantInternal, global\_\-data\_\-all\_\-processes::HubbleParam, global\_\-data\_\-all\_\-processes::ICFormat, global\_\-data\_\-all\_\-processes::InfoFile, global\_\-data\_\-all\_\-processes::InitCondFile, global\_\-data\_\-all\_\-processes::InitGasTemp, INT, global\_\-data\_\-all\_\-processes::MaxNumNgbDeviation, global\_\-data\_\-all\_\-processes::MaxRMSDisplacementFac, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, global\_\-data\_\-all\_\-processes::MinGasHsmlFractional, global\_\-data\_\-all\_\-processes::MinGasTemp, global\_\-data\_\-all\_\-processes::MinSizeTimestep, NTask, global\_\-data\_\-all\_\-processes::NumFilesPerSnapshot, global\_\-data\_\-all\_\-processes::NumFilesWrittenInParallel, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaBaryon, global\_\-data\_\-all\_\-processes::OmegaLambda, global\_\-data\_\-all\_\-processes::OutputDir, global\_\-data\_\-all\_\-processes::OutputListFilename, global\_\-data\_\-all\_\-processes::OutputListLength, global\_\-data\_\-all\_\-processes::OutputListOn, global\_\-data\_\-all\_\-processes::PartAllocFactor, global\_\-data\_\-all\_\-processes::PeriodicBoundariesOn, read\_\-outputlist(), global\_\-data\_\-all\_\-processes::RestartFile, global\_\-data\_\-all\_\-processes::ResubmitCommand, global\_\-data\_\-all\_\-processes::ResubmitOn, global\_\-data\_\-all\_\-processes::SnapFormat, global\_\-data\_\-all\_\-processes::SnapshotFileBase, global\_\-data\_\-all\_\-processes::SofteningBndry, global\_\-data\_\-all\_\-processes::SofteningBndryMaxPhys, global\_\-data\_\-all\_\-processes::SofteningBulge, global\_\-data\_\-all\_\-processes::SofteningBulgeMaxPhys, global\_\-data\_\-all\_\-processes::SofteningDisk, global\_\-data\_\-all\_\-processes::SofteningDiskMaxPhys, global\_\-data\_\-all\_\-processes::SofteningGas, global\_\-data\_\-all\_\-processes::SofteningGasMaxPhys, global\_\-data\_\-all\_\-processes::SofteningHalo, global\_\-data\_\-all\_\-processes::SofteningHaloMaxPhys, global\_\-data\_\-all\_\-processes::SofteningStars, global\_\-data\_\-all\_\-processes::SofteningStarsMaxPhys, STRING, ThisTask, global\_\-data\_\-all\_\-processes::TimeBegin, global\_\-data\_\-all\_\-processes::TimeBetSnapshot, global\_\-data\_\-all\_\-processes::TimeBetStatistics, global\_\-data\_\-all\_\-processes::TimeLimitCPU, global\_\-data\_\-all\_\-processes::TimeMax, global\_\-data\_\-all\_\-processes::TimeOfFirstSnapshot, global\_\-data\_\-all\_\-processes::TimingsFile, global\_\-data\_\-all\_\-processes::TreeAllocFactor, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, global\_\-data\_\-all\_\-processes::TypeOfOpeningCriterion, global\_\-data\_\-all\_\-processes::TypeOfTimestepCriterion, global\_\-data\_\-all\_\-processes::UnitLength\_\-in\_\-cm, global\_\-data\_\-all\_\-processes::UnitMass\_\-in\_\-g, and global\_\-data\_\-all\_\-processes::UnitVelocity\_\-in\_\-cm\_\-per\_\-s.



Referenced by begrun().




\begin{DoxyCode}
{
#define DOUBLE 1
#define STRING 2
#define INT 3
#define MAXTAGS 300

  FILE *fd, *fdout;
  char buf[200], buf1[200], buf2[200], buf3[400];
  int i, j, nt;
  int id[MAXTAGS];
  void *addr[MAXTAGS];
  char tag[MAXTAGS][50];
  int  errorFlag = 0;


  if(sizeof(long long) != 8)
    {
      if(ThisTask == 0)
        printf("\nType `long long' is not 64 bit on this platform. Stopping.\n\n"
      );
      endrun(0);
    }

  if(sizeof(int) != 4)
    {
      if(ThisTask == 0)
        printf("\nType `int' is not 32 bit on this platform. Stopping.\n\n");
      endrun(0);
    }

  if(sizeof(float) != 4)
    {
      if(ThisTask == 0)
        printf("\nType `float' is not 32 bit on this platform. Stopping.\n\n");
      endrun(0);
    }

  if(sizeof(double) != 8)
    {
      if(ThisTask == 0)
        printf("\nType `double' is not 64 bit on this platform. Stopping.\n\n");
      endrun(0);
    }


  if(ThisTask == 0)             /* read parameter file on process 0 */
    {
      nt = 0;

      strcpy(tag[nt], "InitCondFile");
      addr[nt] = All.InitCondFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputDir");
      addr[nt] = All.OutputDir;
      id[nt++] = STRING;

      strcpy(tag[nt], "SnapshotFileBase");
      addr[nt] = All.SnapshotFileBase;
      id[nt++] = STRING;

      strcpy(tag[nt], "EnergyFile");
      addr[nt] = All.EnergyFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "CpuFile");
      addr[nt] = All.CpuFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "InfoFile");
      addr[nt] = All.InfoFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "TimingsFile");
      addr[nt] = All.TimingsFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "RestartFile");
      addr[nt] = All.RestartFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "ResubmitCommand");
      addr[nt] = All.ResubmitCommand;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputListFilename");
      addr[nt] = All.OutputListFilename;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputListOn");
      addr[nt] = &All.OutputListOn;
      id[nt++] = INT;

      strcpy(tag[nt], "Omega0");
      addr[nt] = &All.Omega0;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "OmegaBaryon");
      addr[nt] = &All.OmegaBaryon;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "OmegaLambda");
      addr[nt] = &All.OmegaLambda;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "HubbleParam");
      addr[nt] = &All.HubbleParam;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "BoxSize");
      addr[nt] = &All.BoxSize;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "PeriodicBoundariesOn");
      addr[nt] = &All.PeriodicBoundariesOn;
      id[nt++] = INT;

      strcpy(tag[nt], "TimeOfFirstSnapshot");
      addr[nt] = &All.TimeOfFirstSnapshot;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "CpuTimeBetRestartFile");
      addr[nt] = &All.CpuTimeBetRestartFile;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBetStatistics");
      addr[nt] = &All.TimeBetStatistics;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBegin");
      addr[nt] = &All.TimeBegin;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeMax");
      addr[nt] = &All.TimeMax;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBetSnapshot");
      addr[nt] = &All.TimeBetSnapshot;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitVelocity_in_cm_per_s");
      addr[nt] = &All.UnitVelocity_in_cm_per_s;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitLength_in_cm");
      addr[nt] = &All.UnitLength_in_cm;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitMass_in_g");
      addr[nt] = &All.UnitMass_in_g;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TreeDomainUpdateFrequency");
      addr[nt] = &All.TreeDomainUpdateFrequency;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolIntAccuracy");
      addr[nt] = &All.ErrTolIntAccuracy;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolTheta");
      addr[nt] = &All.ErrTolTheta;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolForceAcc");
      addr[nt] = &All.ErrTolForceAcc;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinGasHsmlFractional");
      addr[nt] = &All.MinGasHsmlFractional;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxSizeTimestep");
      addr[nt] = &All.MaxSizeTimestep;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinSizeTimestep");
      addr[nt] = &All.MinSizeTimestep;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxRMSDisplacementFac");
      addr[nt] = &All.MaxRMSDisplacementFac;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ArtBulkViscConst");
      addr[nt] = &All.ArtBulkViscConst;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "CourantFac");
      addr[nt] = &All.CourantFac;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "DesNumNgb");
      addr[nt] = &All.DesNumNgb;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxNumNgbDeviation");
      addr[nt] = &All.MaxNumNgbDeviation;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ComovingIntegrationOn");
      addr[nt] = &All.ComovingIntegrationOn;
      id[nt++] = INT;

      strcpy(tag[nt], "ICFormat");
      addr[nt] = &All.ICFormat;
      id[nt++] = INT;

      strcpy(tag[nt], "SnapFormat");
      addr[nt] = &All.SnapFormat;
      id[nt++] = INT;

      strcpy(tag[nt], "NumFilesPerSnapshot");
      addr[nt] = &All.NumFilesPerSnapshot;
      id[nt++] = INT;

      strcpy(tag[nt], "NumFilesWrittenInParallel");
      addr[nt] = &All.NumFilesWrittenInParallel;
      id[nt++] = INT;

      strcpy(tag[nt], "ResubmitOn");
      addr[nt] = &All.ResubmitOn;
      id[nt++] = INT;

      strcpy(tag[nt], "TypeOfTimestepCriterion");
      addr[nt] = &All.TypeOfTimestepCriterion;
      id[nt++] = INT;

      strcpy(tag[nt], "TypeOfOpeningCriterion");
      addr[nt] = &All.TypeOfOpeningCriterion;
      id[nt++] = INT;

      strcpy(tag[nt], "TimeLimitCPU");
      addr[nt] = &All.TimeLimitCPU;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningHalo");
      addr[nt] = &All.SofteningHalo;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningDisk");
      addr[nt] = &All.SofteningDisk;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBulge");
      addr[nt] = &All.SofteningBulge;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningGas");
      addr[nt] = &All.SofteningGas;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningStars");
      addr[nt] = &All.SofteningStars;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBndry");
      addr[nt] = &All.SofteningBndry;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningHaloMaxPhys");
      addr[nt] = &All.SofteningHaloMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningDiskMaxPhys");
      addr[nt] = &All.SofteningDiskMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBulgeMaxPhys");
      addr[nt] = &All.SofteningBulgeMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningGasMaxPhys");
      addr[nt] = &All.SofteningGasMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningStarsMaxPhys");
      addr[nt] = &All.SofteningStarsMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBndryMaxPhys");
      addr[nt] = &All.SofteningBndryMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "BufferSize");
      addr[nt] = &All.BufferSize;
      id[nt++] = INT;

      strcpy(tag[nt], "PartAllocFactor");
      addr[nt] = &All.PartAllocFactor;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TreeAllocFactor");
      addr[nt] = &All.TreeAllocFactor;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "GravityConstantInternal");
      addr[nt] = &All.GravityConstantInternal;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "InitGasTemp");
      addr[nt] = &All.InitGasTemp;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinGasTemp");
      addr[nt] = &All.MinGasTemp;
      id[nt++] = DOUBLE;

#ifdef COMPUTE_SELFINTERACTION_FORDARK 
      strcpy(tag[nt], "InteractionCrossSection");
      addr[nt] = &All.InteractionCrossSection;
      id[nt++] = DOUBLE;
#endif

      if((fd = fopen(fname, "r")))
        {
          sprintf(buf, "%s%s", fname, "-usedvalues");
          if(!(fdout = fopen(buf, "w")))
            {
              printf("error opening file '%s' \n", buf);
              errorFlag = 1;
            }
          else
            {
              while(!feof(fd))
                {
                  *buf = 0;
                  fgets(buf, 200, fd);
                  if(sscanf(buf, "%s%s%s", buf1, buf2, buf3) < 2)
                    continue;

                  if(buf1[0] == '%')
                    continue;

                  for(i = 0, j = -1; i < nt; i++)
                    if(strcmp(buf1, tag[i]) == 0)
                      {
                        j = i;
                        tag[i][0] = 0;
                        break;
                      }

                  if(j >= 0)
                    {
                      switch (id[j])
                        {
                        case DOUBLE:
                          *((double *) addr[j]) = atof(buf2);
                          fprintf(fdout, "%-35s%g\n", buf1, *((double *) addr[j])
      );
                          break;
                        case STRING:
                          strcpy(addr[j], buf2);
                          fprintf(fdout, "%-35s%s\n", buf1, buf2);
                          break;
                        case INT:
                          *((int *) addr[j]) = atoi(buf2);
                          fprintf(fdout, "%-35s%d\n", buf1, *((int *) addr[j]));
                          break;
                        }
                    }
                  else
                    {
                      fprintf(stdout, "Error in file %s:   Tag '%s' not allowed o
      r multiple defined.\n",
                              fname, buf1);
                      errorFlag = 1;
                    }
                }
              fclose(fd);
              fclose(fdout);

              i = strlen(All.OutputDir);
              if(i > 0)
                if(All.OutputDir[i - 1] != '/')
                  strcat(All.OutputDir, "/");

              sprintf(buf1, "%s%s", fname, "-usedvalues");
              sprintf(buf2, "%s%s", All.OutputDir, "parameters-usedvalues");
              sprintf(buf3, "cp %s %s", buf1, buf2);
              system(buf3);
            }
        }
      else
        {
          printf("\nParameter file %s not found.\n\n", fname);
          errorFlag = 2;
        }

      if(errorFlag != 2)
        for(i = 0; i < nt; i++)
          {
            if(*tag[i])
              {
                printf("Error. I miss a value for tag '%s' in parameter file '%s'
      .\n", tag[i], fname);
                errorFlag = 1;
              }
          }

      if(All.OutputListOn && errorFlag == 0)
        errorFlag += read_outputlist(All.OutputListFilename);
      else
        All.OutputListLength = 0;
    }

  MPI_Bcast(&errorFlag, 1, MPI_INT, 0, MPI_COMM_WORLD);

  if(errorFlag)
    {
      MPI_Finalize();
      exit(0);
    }

  /* now communicate the relevant parameters to the other processes */
  MPI_Bcast(&All, sizeof(struct global_data_all_processes), MPI_BYTE, 0, MPI_COMM
      _WORLD);


  if(All.NumFilesWrittenInParallel < 1)
    {
      if(ThisTask == 0)
        printf("NumFilesWrittenInParallel MUST be at least 1\n");
      endrun(0);
    }

  if(All.NumFilesWrittenInParallel > NTask)
    {
      if(ThisTask == 0)
        printf("NumFilesWrittenInParallel MUST be smaller than number of processo
      rs\n");
      endrun(0);
    }

#ifdef PERIODIC
  if(All.PeriodicBoundariesOn == 0)
    {
      if(ThisTask == 0)
        {
          printf("Code was compiled with periodic boundary conditions switched on
      .\n");
          printf("You must set `PeriodicBoundariesOn=1', or recompile the code.\n
      ");
        }
      endrun(0);
    }
#else
  if(All.PeriodicBoundariesOn == 1)
    {
      if(ThisTask == 0)
        {
          printf("Code was compiled with periodic boundary conditions switched of
      f.\n");
          printf("You must set `PeriodicBoundariesOn=0', or recompile the code.\n
      ");
        }
      endrun(0);
    }
#endif


  if(All.TypeOfTimestepCriterion >= 1)
    {
      if(ThisTask == 0)
        {
          printf("The specified timestep criterion\n");
          printf("is not valid\n");
        }
      endrun(0);
    }

#if defined(LONG_X) ||  defined(LONG_Y) || defined(LONG_Z)
#ifndef NOGRAVITY
  if(ThisTask == 0)
    {
      printf("Code was compiled with LONG_X/Y/Z, but not with NOGRAVITY.\n");
      printf("Stretched periodic boxes are not implemented for gravity yet.\n");
    }
  endrun(0);
#endif
#endif

#undef DOUBLE
#undef STRING
#undef INT
#undef MAXTAGS
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a952eae1977b498c4fdfabed1742a3ba2_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=358pt]{proto_8h_a952eae1977b498c4fdfabed1742a3ba2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98}{
\index{proto.h@{proto.h}!readjust\_\-timebase@{readjust\_\-timebase}}
\index{readjust\_\-timebase@{readjust\_\-timebase}!proto.h@{proto.h}}
\subsubsection[{readjust\_\-timebase}]{\setlength{\rightskip}{0pt plus 5cm}void readjust\_\-timebase (
\begin{DoxyParamCaption}
\item[{double}]{ TimeMax\_\-old, }
\item[{double}]{ TimeMax\_\-new}
\end{DoxyParamCaption}
)}}
\label{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98}
If a restart from restart-\/files is carried out where the TimeMax variable is increased, then the integer timeline needs to be adjusted. The approach taken here is to reduce the resolution of the integer timeline by factors of 2 until the new final time can be reached within TIMEBASE. 

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 



Definition at line 803 of file begrun.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, endrun(), NumPart, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-begstep, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, TIMEBASE, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, global\_\-data\_\-all\_\-processes::TimeBegin, and global\_\-data\_\-all\_\-processes::TimeMax.



Referenced by begrun().




\begin{DoxyCode}
{
  int i;
  long long ti_end;

  if(ThisTask == 0)
    {
      printf("\nAll.TimeMax has been changed in the parameterfile\n");
      printf("Need to adjust integer timeline\n\n\n");
    }

  if(TimeMax_new < TimeMax_old)
    {
      if(ThisTask == 0)
        printf("\nIt is not allowed to reduce All.TimeMax\n\n");
      endrun(556);
    }

  if(All.ComovingIntegrationOn)
    ti_end = log(TimeMax_new / All.TimeBegin) / All.Timebase_interval;
  else
    ti_end = (TimeMax_new - All.TimeBegin) / All.Timebase_interval;

  while(ti_end > TIMEBASE)
    {
      All.Timebase_interval *= 2.0;

      ti_end /= 2;
      All.Ti_Current /= 2;

#ifdef PMGRID
      All.PM_Ti_begstep /= 2;
      All.PM_Ti_endstep /= 2;
#endif

      for(i = 0; i < NumPart; i++)
        {
          P[i].Ti_begstep /= 2;
          P[i].Ti_endstep /= 2;
        }
    }

  All.TimeMax = TimeMax_new;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af744cef873e3093ba2924da8265d1711}{
\index{proto.h@{proto.h}!reorder\_\-gas@{reorder\_\-gas}}
\index{reorder\_\-gas@{reorder\_\-gas}!proto.h@{proto.h}}
\subsubsection[{reorder\_\-gas}]{\setlength{\rightskip}{0pt plus 5cm}void reorder\_\-gas (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af744cef873e3093ba2924da8265d1711}
This function brings the gas particles into the same order as the sorted keys. (The sort is first done only on the keys themselves and done directly on the gas particles in order to reduce the amount of data that needs to be moved in memory. Only once the order is established, the gas particles are rearranged, such that each particle has to be moved at most once.) 

Definition at line 117 of file peano.c.



References Id, N\_\-gas, P, and SphP.



Referenced by peano\_\-hilbert\_\-order().




\begin{DoxyCode}
{
  int i;
  struct particle_data Psave, Psource;
  struct sph_particle_data SphPsave, SphPsource;
  int idsource, idsave, dest;

  for(i = 0; i < N_gas; i++)
    {
      if(Id[i] != i)
        {
          Psource = P[i];
          SphPsource = SphP[i];

          idsource = Id[i];
          dest = Id[i];

          do
            {
              Psave = P[dest];
              SphPsave = SphP[dest];
              idsave = Id[dest];

              P[dest] = Psource;
              SphP[dest] = SphPsource;
              Id[dest] = idsource;

              if(dest == i)
                break;

              Psource = Psave;
              SphPsource = SphPsave;
              idsource = idsave;

              dest = idsource;
            }
          while(1);
        }
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af744cef873e3093ba2924da8265d1711_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba}{
\index{proto.h@{proto.h}!reorder\_\-particles@{reorder\_\-particles}}
\index{reorder\_\-particles@{reorder\_\-particles}!proto.h@{proto.h}}
\subsubsection[{reorder\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void reorder\_\-particles (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba}
This function brings the collisionless particles into the same order as the sorted keys. (The sort is first done only on the keys themselves and done directly on the particles in order to reduce the amount of data that needs to be moved in memory. Only once the order is established, the particles are rearranged, such that each particle has to be moved at most once.) 

Definition at line 166 of file peano.c.



References Id, N\_\-gas, NumPart, and P.



Referenced by peano\_\-hilbert\_\-order().




\begin{DoxyCode}
{
  int i;
  struct particle_data Psave, Psource;
  int idsource, idsave, dest;

  for(i = N_gas; i < NumPart; i++)
    {
      if(Id[i] != i)
        {
          Psource = P[i];
          idsource = Id[i];

          dest = Id[i];

          do
            {
              Psave = P[dest];
              idsave = Id[dest];

              P[dest] = Psource;
              Id[dest] = idsource;

              if(dest == i)
                break;

              Psource = Psave;
              idsource = idsave;

              dest = idsource;
            }
          while(1);
        }
    }
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}{
\index{proto.h@{proto.h}!restart@{restart}}
\index{restart@{restart}!proto.h@{proto.h}}
\subsubsection[{restart}]{\setlength{\rightskip}{0pt plus 5cm}void restart (
\begin{DoxyParamCaption}
\item[{int}]{ modus}
\end{DoxyParamCaption}
)}}
\label{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}
This function reads or writes the restart files. Each processor writes its own restart file, with the I/O being done in parallel. To avoid congestion of the disks you can tell the program to restrict the number of files that are simultaneously written to NumFilesWrittenInParallel.

If modus$>$0 the \hyperlink{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}{restart()}-\/routine reads, if modus==0 it writes a restart file. 

$<$ defines maximum length of neighbour list

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ Maximum number of nodes in the top-\/level tree used for domain decomposition 



Definition at line 35 of file restart.c.



References All, allocate\_\-memory(), byten(), NODE::d, DomainCenter, DomainCorner, DomainEndList, DomainFac, DomainHmax, DomainLen, DomainMoment, DomainMyLast, DomainMyStart, DomainNodeIndex, DomainStartList, DomainTask, DomainTreeNodeLen, endrun(), Extnodes\_\-base, Father, fd, FLOAT, force\_\-treeallocate(), in(), MAX\_\-NGB, MaxNodes, global\_\-data\_\-all\_\-processes::MaxPart, global\_\-data\_\-all\_\-processes::MaxPartSph, MAXTOPNODES, N\_\-gas, Nextnode, ngb\_\-treeallocate(), Nodes\_\-base, NTask, global\_\-data\_\-all\_\-processes::NumFilesWrittenInParallel, Numnodestree, NumPart, global\_\-data\_\-all\_\-processes::OutputDir, P, global\_\-data\_\-all\_\-processes::PartAllocFactor, random\_\-generator, global\_\-data\_\-all\_\-processes::RestartFile, SphP, ThisTask, global\_\-data\_\-all\_\-processes::Time, global\_\-data\_\-all\_\-processes::TotN\_\-gas, global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeAllocFactor, and NODE::u.



Referenced by begrun(), and run().




\begin{DoxyCode}
{
  char buf[200], buf_bak[200], buf_mv[500];
  double save_PartAllocFactor, save_TreeAllocFactor;
  int i, nprocgroup, masterTask, groupTask, old_MaxPart, old_MaxNodes;
  struct global_data_all_processes all_task0;


  sprintf(buf, "%s%s.%d", All.OutputDir, All.RestartFile, ThisTask);
  sprintf(buf_bak, "%s%s.%d.bak", All.OutputDir, All.RestartFile, ThisTask);
  sprintf(buf_mv, "mv %s %s", buf, buf_bak);


  if((NTask < All.NumFilesWrittenInParallel))
    {
      printf
        ("Fatal error.\nNumber of processors must be a smaller or equal than `Num
      FilesWrittenInParallel'.\n");
      endrun(2131);
    }

  nprocgroup = NTask / All.NumFilesWrittenInParallel;

  if((NTask % All.NumFilesWrittenInParallel))
    {
      nprocgroup++;
    }

  masterTask = (ThisTask / nprocgroup) * nprocgroup;

  for(groupTask = 0; groupTask < nprocgroup; groupTask++)
    {
      if(ThisTask == (masterTask + groupTask))  /* ok, it's this processor's turn
       */
        {
          if(modus)
            {
              if(!(fd = fopen(buf, "r")))
                {
                  printf("Restart file '%s' not found.\n", buf);
                  endrun(7870);
                }
            }
          else
            {
              system(buf_mv);   /* move old restart files to .bak files */

              if(!(fd = fopen(buf, "w")))
                {
                  printf("Restart file '%s' cannot be opened.\n", buf);
                  endrun(7878);
                }
            }


          save_PartAllocFactor = All.PartAllocFactor;
          save_TreeAllocFactor = All.TreeAllocFactor;

          /* common data  */
          byten(&All, sizeof(struct global_data_all_processes), modus);

          if(ThisTask == 0 && modus > 0)
            all_task0 = All;

          if(modus > 0 && groupTask == 0)       /* read */
            {
              MPI_Bcast(&all_task0, sizeof(struct global_data_all_processes), MPI
      _BYTE, 0, MPI_COMM_WORLD);
            }

          old_MaxPart = All.MaxPart;
          old_MaxNodes = All.TreeAllocFactor * All.MaxPart;

          if(modus)             /* read */
            {
              if(All.PartAllocFactor != save_PartAllocFactor)
                {
                  All.PartAllocFactor = save_PartAllocFactor;
                  All.MaxPart = All.PartAllocFactor * (All.TotNumPart / NTask);
                  All.MaxPartSph = All.PartAllocFactor * (All.TotN_gas / NTask);
                  save_PartAllocFactor = -1;
                }

              if(All.TreeAllocFactor != save_TreeAllocFactor)
                {
                  All.TreeAllocFactor = save_TreeAllocFactor;
                  save_TreeAllocFactor = -1;
                }

              if(all_task0.Time != All.Time)
                {
                  printf("The restart file on task=%d is not consistent with the 
      one on task=0\n", ThisTask);
                  fflush(stdout);
                  endrun(16);
                }

              allocate_memory();
            }

          in(&NumPart, modus);

          if(NumPart > All.MaxPart)
            {
              printf
                ("it seems you have reduced(!) 'PartAllocFactor' below the value 
      of %g needed to load the restart file.\n",
                 NumPart / (((double) All.TotNumPart) / NTask));
              printf("fatal error\n");
              endrun(22);
            }

          /* Particle data  */
          byten(&P[0], NumPart * sizeof(struct particle_data), modus);

          in(&N_gas, modus);

          if(N_gas > 0)
            {
              if(N_gas > All.MaxPartSph)
                {
                  printf
                    ("SPH: it seems you have reduced(!) 'PartAllocFactor' below t
      he value of %g needed to load the restart file.\n",
                     N_gas / (((double) All.TotN_gas) / NTask));
                  printf("fatal error\n");
                  endrun(222);
                }
              /* Sph-Particle data  */
              byten(&SphP[0], N_gas * sizeof(struct sph_particle_data), modus);
            }

          /* write state of random number generator */
          byten(gsl_rng_state(random_generator), gsl_rng_size(random_generator), 
      modus);


          /* now store relevant data for tree */

          if(modus)             /* read */
            {
              ngb_treeallocate(MAX_NGB);

              force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);
      
            }


          in(&Numnodestree, modus);

          if(Numnodestree > MaxNodes)
            {
              printf
                ("Tree storage: it seems you have reduced(!) 'PartAllocFactor' be
      low the value needed to load the restart file (task=%d). "
                 "Numnodestree=%d  MaxNodes=%d\n", ThisTask, Numnodestree, 
      MaxNodes);
              endrun(221);
            }

          byten(Nodes_base, Numnodestree * sizeof(struct NODE), modus);
          byten(Extnodes_base, Numnodestree * sizeof(struct extNODE), modus);

          byten(Father, NumPart * sizeof(int), modus);

          byten(Nextnode, NumPart * sizeof(int), modus);
          byten(Nextnode + All.MaxPart, MAXTOPNODES * sizeof(int), modus);

          byten(DomainStartList, NTask * sizeof(int), modus);
          byten(DomainEndList, NTask * sizeof(int), modus);
          byten(DomainTask, MAXTOPNODES * sizeof(int), modus);
          byten(DomainNodeIndex, MAXTOPNODES * sizeof(int), modus);
          byten(DomainTreeNodeLen, MAXTOPNODES * sizeof(FLOAT), modus);
          byten(DomainHmax, MAXTOPNODES * sizeof(FLOAT), modus);
          byten(DomainMoment, MAXTOPNODES * sizeof(struct DomainNODE), modus);

          byten(DomainCorner, 3 * sizeof(double), modus);
          byten(DomainCenter, 3 * sizeof(double), modus);
          byten(&DomainLen, sizeof(double), modus);
          byten(&DomainFac, sizeof(double), modus);
          byten(&DomainMyStart, sizeof(int), modus);
          byten(&DomainMyLast, sizeof(int), modus);

          if(modus)             /* read */
            if(All.PartAllocFactor != save_PartAllocFactor || All.
      TreeAllocFactor != save_TreeAllocFactor)
              {
                for(i = 0; i < NumPart; i++)
                  Father[i] += (All.MaxPart - old_MaxPart);

                for(i = 0; i < NumPart; i++)
                  if(Nextnode[i] >= old_MaxPart)
                    {
                      if(Nextnode[i] >= old_MaxPart + old_MaxNodes)
                        Nextnode[i] += (All.MaxPart - old_MaxPart) + (MaxNodes - 
      old_MaxPart);
                      else
                        Nextnode[i] += (All.MaxPart - old_MaxPart);
                    }

                for(i = 0; i < Numnodestree; i++)
                  {
                    if(Nodes_base[i].u.d.sibling >= old_MaxPart)
                      {
                        if(Nodes_base[i].u.d.sibling >= old_MaxPart + old_MaxNode
      s)
                          Nodes_base[i].u.d.sibling +=
                            (All.MaxPart - old_MaxPart) + (MaxNodes - old_MaxNode
      s);
                        else
                          Nodes_base[i].u.d.sibling += (All.MaxPart - old_MaxPart
      );
                      }

                    if(Nodes_base[i].u.d.father >= old_MaxPart)
                      {
                        if(Nodes_base[i].u.d.father >= old_MaxPart + old_MaxNodes
      )
                          Nodes_base[i].u.d.father += (All.MaxPart - old_MaxPart)
       + (MaxNodes - old_MaxNodes);
                        else
                          Nodes_base[i].u.d.father += (All.MaxPart - old_MaxPart)
      ;
                      }

                    if(Nodes_base[i].u.d.nextnode >= old_MaxPart)
                      {
                        if(Nodes_base[i].u.d.nextnode >= old_MaxPart + old_MaxNod
      es)
                          Nodes_base[i].u.d.nextnode +=
                            (All.MaxPart - old_MaxPart) + (MaxNodes - old_MaxNode
      s);
                        else
                          Nodes_base[i].u.d.nextnode += (All.MaxPart - old_MaxPar
      t);
                      }
                  }

                for(i = 0; i < MAXTOPNODES; i++)
                  if(Nextnode[i + All.MaxPart] >= old_MaxPart)
                    {
                      if(Nextnode[i + All.MaxPart] >= old_MaxPart + old_MaxNodes)
      
                        Nextnode[i + All.MaxPart] += (All.MaxPart - old_MaxPart) 
      + (MaxNodes - old_MaxNodes);
                      else
                        Nextnode[i + All.MaxPart] += (All.MaxPart - old_MaxPart);
      
                    }

                for(i = 0; i < MAXTOPNODES; i++)
                  if(DomainNodeIndex[i] >= old_MaxPart)
                    {
                      if(DomainNodeIndex[i] >= old_MaxPart + old_MaxNodes)
                        DomainNodeIndex[i] += (All.MaxPart - old_MaxPart) + (
      MaxNodes - old_MaxNodes);
                      else
                        DomainNodeIndex[i] += (All.MaxPart - old_MaxPart);
                    }
              }

          fclose(fd);
        }
      else                      /* wait inside the group */
        {
          if(modus > 0 && groupTask == 0)       /* read */
            {
              MPI_Bcast(&all_task0, sizeof(struct global_data_all_processes), MPI
      _BYTE, 0, MPI_COMM_WORLD);
            }
        }

      MPI_Barrier(MPI_COMM_WORLD);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=294pt]{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2}{
\index{proto.h@{proto.h}!run@{run}}
\index{run@{run}!proto.h@{proto.h}}
\subsubsection[{run}]{\setlength{\rightskip}{0pt plus 5cm}void run (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2}
This routine contains the main simulation loop that iterates over single timesteps. The loop terminates when the cpu-\/time limit is reached, when a `stop' file is found in the output directory, or when the simulation ends because we arrived at TimeMax. 

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 



Definition at line 20 of file run.c.



References advance\_\-and\_\-find\_\-timesteps(), All, close\_\-outputfiles(), compute\_\-accelerations(), compute\_\-potential(), global\_\-data\_\-all\_\-processes::CPU\_\-Total, CPUThisRun, global\_\-data\_\-all\_\-processes::CpuTimeBetRestartFile, domain\_\-Decomposition(), energy\_\-statistics(), every\_\-timestep\_\-stuff(), fd, find\_\-next\_\-sync\_\-point\_\-and\_\-drift(), global\_\-data\_\-all\_\-processes::NumCurrentTiStep, global\_\-data\_\-all\_\-processes::OutputDir, restart(), global\_\-data\_\-all\_\-processes::ResubmitCommand, global\_\-data\_\-all\_\-processes::ResubmitOn, savepositions(), second(), global\_\-data\_\-all\_\-processes::SnapshotFileCount, ThisTask, global\_\-data\_\-all\_\-processes::Ti\_\-Current, global\_\-data\_\-all\_\-processes::Time, TIMEBASE, global\_\-data\_\-all\_\-processes::TimeBetStatistics, timediff(), global\_\-data\_\-all\_\-processes::TimeLastRestartFile, global\_\-data\_\-all\_\-processes::TimeLastStatistics, global\_\-data\_\-all\_\-processes::TimeLimitCPU, and global\_\-data\_\-all\_\-processes::TimeMax.



Referenced by main().




\begin{DoxyCode}
{
  FILE *fd;
  int stopflag = 0;
  char stopfname[200], contfname[200];
  double t0, t1;


  sprintf(stopfname, "%sstop", All.OutputDir);
  sprintf(contfname, "%scont", All.OutputDir);
  unlink(contfname);

  do                            /* main loop */
    {
      t0 = second();

      find_next_sync_point_and_drift(); /* find next synchronization point and dr
      ift particles to this time.
                                         * If needed, this function will also wri
      te an output file
                                         * at the desired time.
                                         */

      every_timestep_stuff();   /* write some info to log-files */


      domain_Decomposition();   /* do domain decomposition if needed */


      compute_accelerations(0); /* compute accelerations for 
                                 * the particles that are to be advanced  
                                 */

      /* check whether we want a full energy statistics */
      if((All.Time - All.TimeLastStatistics) >= All.TimeBetStatistics)
        {
#ifdef COMPUTE_POTENTIAL_ENERGY
          compute_potential();
#endif
          energy_statistics();  /* compute and output energy statistics */
          All.TimeLastStatistics += All.TimeBetStatistics;
        }

      advance_and_find_timesteps();     /* 'kick' active particles in
                                         * momentum space and compute new
                                         * timesteps for them
                                         */
      All.NumCurrentTiStep++;

      /* Check whether we need to interrupt the run */
      if(ThisTask == 0)
        {
          /* Is the stop-file present? If yes, interrupt the run. */
          if((fd = fopen(stopfname, "r")))
            {
              fclose(fd);
              stopflag = 1;
              unlink(stopfname);
            }

          /* are we running out of CPU-time ? If yes, interrupt run. */
          if(CPUThisRun > 0.85 * All.TimeLimitCPU)
            {
              printf("reaching time-limit. stopping.\n");
              stopflag = 2;
            }
        }

      MPI_Bcast(&stopflag, 1, MPI_INT, 0, MPI_COMM_WORLD);

      if(stopflag)
        {
          restart(0);           /* write restart file */
          MPI_Barrier(MPI_COMM_WORLD);

          if(stopflag == 2 && ThisTask == 0)
            {
              if((fd = fopen(contfname, "w")))
                fclose(fd);
            }

          if(stopflag == 2 && All.ResubmitOn && ThisTask == 0)
            {
              close_outputfiles();
              system(All.ResubmitCommand);
            }
          return;
        }

      /* is it time to write a regular restart-file? (for security) */
      if(ThisTask == 0)
        {
          if((CPUThisRun - All.TimeLastRestartFile) >= All.CpuTimeBetRestartFile)
      
            {
              All.TimeLastRestartFile = CPUThisRun;
              stopflag = 3;
            }
          else
            stopflag = 0;
        }

      MPI_Bcast(&stopflag, 1, MPI_INT, 0, MPI_COMM_WORLD);

      if(stopflag == 3)
        {
          restart(0);           /* write an occasional restart file */
          stopflag = 0;
        }

      t1 = second();

      All.CPU_Total += timediff(t0, t1);
      CPUThisRun += timediff(t0, t1);
    }
  while(All.Ti_Current < TIMEBASE && All.Time <= All.TimeMax);

  restart(0);

  savepositions(All.SnapshotFileCount++);       /* write a last snapshot
                                                 * file at final time (will
                                                 * be overwritten if
                                                 * All.TimeMax is increased
                                                 * and the run is continued)
                                                 */
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=190pt]{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a523730833804b6d92aa7f4dd474805c5}{
\index{proto.h@{proto.h}!savepositions@{savepositions}}
\index{savepositions@{savepositions}!proto.h@{proto.h}}
\subsubsection[{savepositions}]{\setlength{\rightskip}{0pt plus 5cm}void savepositions (
\begin{DoxyParamCaption}
\item[{int}]{ num}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a523730833804b6d92aa7f4dd474805c5}
This function writes a snapshot of the particle distribution to one or several files using the selected file format. If NumFilesPerSnapshot$>$1, the snapshot is distributed onto several files, several of them can be written simultaneously (up to NumFilesWrittenInParallel). Each file contains data from a group of processors. 

Definition at line 33 of file io.c.



References All, global\_\-data\_\-all\_\-processes::CPU\_\-Snapshot, distribute\_\-file(), endrun(), fill\_\-Tab\_\-IO\_\-Labels(), n\_\-type, NTask, ntot\_\-type\_\-all, global\_\-data\_\-all\_\-processes::NumFilesPerSnapshot, global\_\-data\_\-all\_\-processes::NumFilesWrittenInParallel, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, global\_\-data\_\-all\_\-processes::OutputDir, P, second(), global\_\-data\_\-all\_\-processes::SnapFormat, global\_\-data\_\-all\_\-processes::SnapshotFileBase, ThisTask, timediff(), global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, and write\_\-file().



Referenced by find\_\-next\_\-sync\_\-point\_\-and\_\-drift(), and run().




\begin{DoxyCode}
{
  double t0, t1;
  char buf[500];
  int i, j, *temp, n, filenr, gr, ngroups, masterTask, lastTask;

  t0 = second();

  if(ThisTask == 0)
    printf("\nwriting snapshot file... \n");

#if defined(SFR) || defined(BLACK_HOLES)
  rearrange_particle_sequence();
  /* ensures that new tree will be constructed */
  All.NumForcesSinceLastDomainDecomp = 1 + All.TreeDomainUpdateFrequency * All.
      TotNumPart;
#endif

  if(NTask < All.NumFilesPerSnapshot)
    {
      if(ThisTask == 0)
        printf("Fatal error.\nNumber of processors must be larger or equal than A
      ll.NumFilesPerSnapshot.\n");
      endrun(0);
    }
  if(All.SnapFormat < 1 || All.SnapFormat > 3)
    {
      if(ThisTask == 0)
        printf("Unsupported File-Format\n");
      endrun(0);
    }
#ifndef  HAVE_HDF5
  if(All.SnapFormat == 3)
    {
      if(ThisTask == 0)
        printf("Code wasn't compiled with HDF5 support enabled!\n");
      endrun(0);
    }
#endif


  /* determine global and local particle numbers */
  for(n = 0; n < 6; n++)
    n_type[n] = 0;

  for(n = 0; n < NumPart; n++)
    n_type[P[n].Type]++;

  /* because ntot_type_all[] is of type `long long', we cannot do a simple
   * MPI_Allreduce() to sum the total particle numbers 
   */
  temp = malloc(NTask * 6 * sizeof(int));
  MPI_Allgather(n_type, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
  for(i = 0; i < 6; i++)
    {
      ntot_type_all[i] = 0;
      for(j = 0; j < NTask; j++)
        ntot_type_all[i] += temp[j * 6 + i];
    }
  free(temp);


  /* assign processors to output files */
  distribute_file(All.NumFilesPerSnapshot, 0, 0, NTask - 1, &filenr, &masterTask,
       &lastTask);

  fill_Tab_IO_Labels();

  if(All.NumFilesPerSnapshot > 1)
    sprintf(buf, "%s%s_%03d.%d", All.OutputDir, All.SnapshotFileBase, num, filenr
      );
  else
    sprintf(buf, "%s%s_%03d", All.OutputDir, All.SnapshotFileBase, num);

  ngroups = All.NumFilesPerSnapshot / All.NumFilesWrittenInParallel;
  if((All.NumFilesPerSnapshot % All.NumFilesWrittenInParallel))
    ngroups++;

  for(gr = 0; gr < ngroups; gr++)
    {
      if((filenr / All.NumFilesWrittenInParallel) == gr)        /* ok, it's this 
      processor's turn */
        write_file(buf, masterTask, lastTask);
      MPI_Barrier(MPI_COMM_WORLD);
    }


  if(ThisTask == 0)
    printf("done with snapshot.\n");

  t1 = second();

  All.CPU_Snapshot += timediff(t0, t1);

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a523730833804b6d92aa7f4dd474805c5_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a523730833804b6d92aa7f4dd474805c5_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad24c35a2016ce428248988795c1d3174}{
\index{proto.h@{proto.h}!second@{second}}
\index{second@{second}!proto.h@{proto.h}}
\subsubsection[{second}]{\setlength{\rightskip}{0pt plus 5cm}double second (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad24c35a2016ce428248988795c1d3174}
returns the number of cpu-\/ticks in seconds that have elapsed, or the wall-\/clock time obtained with MPI\_\-Wtime(). 

Definition at line 49 of file system.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), compute\_\-accelerations(), compute\_\-potential(), density(), domain\_\-Decomposition(), find\_\-next\_\-sync\_\-point\_\-and\_\-drift(), gravity\_\-forcetest(), gravity\_\-tree(), hydro\_\-force(), main(), move\_\-particles(), run(), and savepositions().




\begin{DoxyCode}
{
#ifdef WALLCLOCK
  return MPI_Wtime();
#else
  return ((double) clock()) / CLOCKS_PER_SEC;
#endif
  
  /* note: on AIX and presumably many other 32bit systems, 
   * clock() has only a resolution of 10ms=0.01sec 
   */
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad24c35a2016ce428248988795c1d3174_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135}{
\index{proto.h@{proto.h}!seed\_\-glass@{seed\_\-glass}}
\index{seed\_\-glass@{seed\_\-glass}!proto.h@{proto.h}}
\subsubsection[{seed\_\-glass}]{\setlength{\rightskip}{0pt plus 5cm}void seed\_\-glass (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135}


Referenced by init().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=382pt]{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9cb45ef22cae101906f021fb7a23afbe}{
\index{proto.h@{proto.h}!set\_\-random\_\-numbers@{set\_\-random\_\-numbers}}
\index{set\_\-random\_\-numbers@{set\_\-random\_\-numbers}!proto.h@{proto.h}}
\subsubsection[{set\_\-random\_\-numbers}]{\setlength{\rightskip}{0pt plus 5cm}void set\_\-random\_\-numbers (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a9cb45ef22cae101906f021fb7a23afbe}
This routine fills the random number table. 

$<$ gives the length of a table with random numbers, refreshed at every timestep. This is used to allow application of random numbers to a specific particle in a way that is independent of the number of processors used. 



Definition at line 37 of file system.c.



References random\_\-generator, and RndTable.



Referenced by begrun(), and every\_\-timestep\_\-stuff().




\begin{DoxyCode}
{
  int i;

  for(i = 0; i < RNDTABLE; i++)
    RndTable[i] = gsl_rng_uniform(random_generator);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a9cb45ef22cae101906f021fb7a23afbe_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91}{
\index{proto.h@{proto.h}!set\_\-softenings@{set\_\-softenings}}
\index{set\_\-softenings@{set\_\-softenings}!proto.h@{proto.h}}
\subsubsection[{set\_\-softenings}]{\setlength{\rightskip}{0pt plus 5cm}void set\_\-softenings (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91}
This function sets the (comoving) softening length of all particle types in the table All.SofteningTable\mbox{[}...\mbox{]}. We check that the physical softening length is bounded by the Softening-\/MaxPhys values. 

Definition at line 465 of file gravtree.c.



References All, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::ForceSoftening, global\_\-data\_\-all\_\-processes::MinGasHsml, global\_\-data\_\-all\_\-processes::MinGasHsmlFractional, global\_\-data\_\-all\_\-processes::SofteningBndry, global\_\-data\_\-all\_\-processes::SofteningBndryMaxPhys, global\_\-data\_\-all\_\-processes::SofteningBulge, global\_\-data\_\-all\_\-processes::SofteningBulgeMaxPhys, global\_\-data\_\-all\_\-processes::SofteningDisk, global\_\-data\_\-all\_\-processes::SofteningDiskMaxPhys, global\_\-data\_\-all\_\-processes::SofteningGas, global\_\-data\_\-all\_\-processes::SofteningGasMaxPhys, global\_\-data\_\-all\_\-processes::SofteningHalo, global\_\-data\_\-all\_\-processes::SofteningHaloMaxPhys, global\_\-data\_\-all\_\-processes::SofteningStars, global\_\-data\_\-all\_\-processes::SofteningStarsMaxPhys, global\_\-data\_\-all\_\-processes::SofteningTable, and global\_\-data\_\-all\_\-processes::Time.



Referenced by compute\_\-potential(), gravity\_\-forcetest(), gravity\_\-tree(), and init().




\begin{DoxyCode}
{
  int i;

  if(All.ComovingIntegrationOn)
    {
      if(All.SofteningGas * All.Time > All.SofteningGasMaxPhys)
        All.SofteningTable[0] = All.SofteningGasMaxPhys / All.Time;
      else
        All.SofteningTable[0] = All.SofteningGas;
      
      if(All.SofteningHalo * All.Time > All.SofteningHaloMaxPhys)
        All.SofteningTable[1] = All.SofteningHaloMaxPhys / All.Time;
      else
        All.SofteningTable[1] = All.SofteningHalo;
      
      if(All.SofteningDisk * All.Time > All.SofteningDiskMaxPhys)
        All.SofteningTable[2] = All.SofteningDiskMaxPhys / All.Time;
      else
        All.SofteningTable[2] = All.SofteningDisk;
      
      if(All.SofteningBulge * All.Time > All.SofteningBulgeMaxPhys)
        All.SofteningTable[3] = All.SofteningBulgeMaxPhys / All.Time;
      else
        All.SofteningTable[3] = All.SofteningBulge;
      
      if(All.SofteningStars * All.Time > All.SofteningStarsMaxPhys)
        All.SofteningTable[4] = All.SofteningStarsMaxPhys / All.Time;
      else
        All.SofteningTable[4] = All.SofteningStars;
      
      if(All.SofteningBndry * All.Time > All.SofteningBndryMaxPhys)
        All.SofteningTable[5] = All.SofteningBndryMaxPhys / All.Time;
      else
        All.SofteningTable[5] = All.SofteningBndry;
    }
  else
    {
      All.SofteningTable[0] = All.SofteningGas;
      All.SofteningTable[1] = All.SofteningHalo;
      All.SofteningTable[2] = All.SofteningDisk;
      All.SofteningTable[3] = All.SofteningBulge;
      All.SofteningTable[4] = All.SofteningStars;
      All.SofteningTable[5] = All.SofteningBndry;
    }

  for(i = 0; i < 6; i++)
    All.ForceSoftening[i] = 2.8 * All.SofteningTable[i];

  All.MinGasHsml = All.MinGasHsmlFractional * All.ForceSoftening[0];
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aba986f6be1d66945199c7ea43e5c9610}{
\index{proto.h@{proto.h}!set\_\-units@{set\_\-units}}
\index{set\_\-units@{set\_\-units}!proto.h@{proto.h}}
\subsubsection[{set\_\-units}]{\setlength{\rightskip}{0pt plus 5cm}void set\_\-units (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_aba986f6be1d66945199c7ea43e5c9610}
Computes conversion factors between internal code units and the cgs-\/system. 

$<$ Gravitational constant (in cgs units)

$<$ mass fraction of hydrogen, relevant only for radiative cooling

$<$ adiabatic index of simulated gas 



Definition at line 153 of file begrun.c.



References All, BOLTZMANN, global\_\-data\_\-all\_\-processes::G, GRAVITY, global\_\-data\_\-all\_\-processes::GravityConstantInternal, HUBBLE, global\_\-data\_\-all\_\-processes::Hubble, global\_\-data\_\-all\_\-processes::MinEgySpec, global\_\-data\_\-all\_\-processes::MinGasTemp, pow(), PROTONMASS, ThisTask, global\_\-data\_\-all\_\-processes::UnitCoolingRate\_\-in\_\-cgs, global\_\-data\_\-all\_\-processes::UnitDensity\_\-in\_\-cgs, global\_\-data\_\-all\_\-processes::UnitEnergy\_\-in\_\-cgs, global\_\-data\_\-all\_\-processes::UnitLength\_\-in\_\-cm, global\_\-data\_\-all\_\-processes::UnitMass\_\-in\_\-g, global\_\-data\_\-all\_\-processes::UnitPressure\_\-in\_\-cgs, global\_\-data\_\-all\_\-processes::UnitTime\_\-in\_\-Megayears, global\_\-data\_\-all\_\-processes::UnitTime\_\-in\_\-s, and global\_\-data\_\-all\_\-processes::UnitVelocity\_\-in\_\-cm\_\-per\_\-s.



Referenced by begrun().




\begin{DoxyCode}
{
  double meanweight;

  All.UnitTime_in_s = All.UnitLength_in_cm / All.UnitVelocity_in_cm_per_s;
  All.UnitTime_in_Megayears = All.UnitTime_in_s / SEC_PER_MEGAYEAR;

  if(All.GravityConstantInternal == 0)
    All.G = GRAVITY / pow(All.UnitLength_in_cm, 3) * All.UnitMass_in_g * pow(All.
      UnitTime_in_s, 2);
  else
    All.G = All.GravityConstantInternal;

  All.UnitDensity_in_cgs = All.UnitMass_in_g / pow(All.UnitLength_in_cm, 3);
  All.UnitPressure_in_cgs = All.UnitMass_in_g / All.UnitLength_in_cm / pow(All.
      UnitTime_in_s, 2);
  All.UnitCoolingRate_in_cgs = All.UnitPressure_in_cgs / All.UnitTime_in_s;
  All.UnitEnergy_in_cgs = All.UnitMass_in_g * pow(All.UnitLength_in_cm, 2) / pow(
      All.UnitTime_in_s, 2);

  /* convert some physical input parameters to internal units */

  All.Hubble = HUBBLE * All.UnitTime_in_s;

  if(ThisTask == 0)
    {
      printf("\nHubble (internal units) = %g\n", All.Hubble);
      printf("G (internal units) = %g\n", All.G);
      printf("UnitMass_in_g = %g \n", All.UnitMass_in_g);
      printf("UnitTime_in_s = %g \n", All.UnitTime_in_s);
      printf("UnitVelocity_in_cm_per_s = %g \n", All.UnitVelocity_in_cm_per_s);
      printf("UnitDensity_in_cgs = %g \n", All.UnitDensity_in_cgs);
      printf("UnitEnergy_in_cgs = %g \n", All.UnitEnergy_in_cgs);
      printf("\n");
    }

  meanweight = 4.0 / (1 + 3 * HYDROGEN_MASSFRAC);       /* note: we assume neutra
      l gas here */

#ifdef ISOTHERM_EQS
  All.MinEgySpec = 0;
#else
  All.MinEgySpec = 1 / meanweight * (1.0 / GAMMA_MINUS1) * (BOLTZMANN / 
      PROTONMASS) * All.MinGasTemp;
  All.MinEgySpec *= All.UnitMass_in_g / All.UnitEnergy_in_cgs;
#endif

}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{proto_8h_aba986f6be1d66945199c7ea43e5c9610_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=304pt]{proto_8h_aba986f6be1d66945199c7ea43e5c9610_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_abca44f066552d38c44a1cd6020d349d5}{
\index{proto.h@{proto.h}!setup\_\-smoothinglengths@{setup\_\-smoothinglengths}}
\index{setup\_\-smoothinglengths@{setup\_\-smoothinglengths}!proto.h@{proto.h}}
\subsubsection[{setup\_\-smoothinglengths}]{\setlength{\rightskip}{0pt plus 5cm}void setup\_\-smoothinglengths (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_abca44f066552d38c44a1cd6020d349d5}
This function is used to find an initial smoothing length for each SPH particle. It guarantees that the number of neighbours will be between desired\_\-ngb-\/MAXDEV and desired\_\-ngb+MAXDEV. For simplicity, a first guess of the smoothing length is provided to the function \hyperlink{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density()}, which will then iterate if needed to find the right smoothing length. 

Definition at line 206 of file init.c.



References All, NODE::d, density(), global\_\-data\_\-all\_\-processes::DesNumNgb, Father, sph\_\-particle\_\-data::Hsml, NODE::len, particle\_\-data::Mass, N\_\-gas, Nodes, P, pow(), RestartFlag, SphP, and NODE::u.



Referenced by init().




\begin{DoxyCode}
{
  int i, no, p;

  if(RestartFlag == 0)
    {

      for(i = 0; i < N_gas; i++)
        {
          no = Father[i];

          while(10 * All.DesNumNgb * P[i].Mass > Nodes[no].u.d.mass)
            {
              p = Nodes[no].u.d.father;

              if(p < 0)
                break;

              no = p;
            }
#ifndef TWODIMS
          SphP[i].Hsml =
            pow(3.0 / (4 * M_PI) * All.DesNumNgb * P[i].Mass / Nodes[no].u.d.mass
      , 1.0 / 3) * Nodes[no].len;
#else
          SphP[i].Hsml =
            pow(1.0 / (M_PI) * All.DesNumNgb * P[i].Mass / Nodes[no].u.d.mass, 1.
      0 / 2) * Nodes[no].len;
#endif
        }
    }

  density();
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_abca44f066552d38c44a1cd6020d349d5_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_abca44f066552d38c44a1cd6020d349d5_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad47ac005519641e0cfc423c3802d3ef2}{
\index{proto.h@{proto.h}!statistics@{statistics}}
\index{statistics@{statistics}!proto.h@{proto.h}}
\subsubsection[{statistics}]{\setlength{\rightskip}{0pt plus 5cm}void statistics (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad47ac005519641e0cfc423c3802d3ef2}
\hypertarget{proto_8h_a869daac8b2af5667db265026f09fb9d8}{
\index{proto.h@{proto.h}!terminate\_\-processes@{terminate\_\-processes}}
\index{terminate\_\-processes@{terminate\_\-processes}!proto.h@{proto.h}}
\subsubsection[{terminate\_\-processes}]{\setlength{\rightskip}{0pt plus 5cm}void terminate\_\-processes (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a869daac8b2af5667db265026f09fb9d8}


Referenced by endrun().



Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a869daac8b2af5667db265026f09fb9d8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a890645bdc4536bd797ca53028072e30d}{
\index{proto.h@{proto.h}!timediff@{timediff}}
\index{timediff@{timediff}!proto.h@{proto.h}}
\subsubsection[{timediff}]{\setlength{\rightskip}{0pt plus 5cm}double timediff (
\begin{DoxyParamCaption}
\item[{double}]{ t0, }
\item[{double}]{ t1}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a890645bdc4536bd797ca53028072e30d}
returns the time difference between two measurements obtained with \hyperlink{proto_8h_ad24c35a2016ce428248988795c1d3174}{second()}. The routine takes care of the possible overflow of the tick counter on 32bit systems, but depending on the system, this may not always work properly. Similarly, in some MPI implementations, the MPI\_\-Wtime() function may also overflow, in which case a negative time difference would be returned. The routine returns instead a time difference equal to 0. 

Definition at line 70 of file system.c.



References pow().



Referenced by advance\_\-and\_\-find\_\-timesteps(), compute\_\-accelerations(), compute\_\-potential(), density(), domain\_\-Decomposition(), find\_\-next\_\-sync\_\-point\_\-and\_\-drift(), gravity\_\-forcetest(), gravity\_\-tree(), hydro\_\-force(), main(), move\_\-particles(), run(), and savepositions().




\begin{DoxyCode}
{
  double dt;

  dt = t1 - t0;

  if(dt < 0)    /* overflow has occured (for systems with 32bit tick counter) */
    {
#ifdef WALLCLOCK
      dt = 0;
#else
      dt = t1 + pow(2, 32) / CLOCKS_PER_SEC - t0;
#endif
    }

  return dt;
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{proto_8h_a890645bdc4536bd797ca53028072e30d_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a890645bdc4536bd797ca53028072e30d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a48b0ed3a843924501df8ed871e08e77c}{
\index{proto.h@{proto.h}!write\_\-file@{write\_\-file}}
\index{write\_\-file@{write\_\-file}!proto.h@{proto.h}}
\subsubsection[{write\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void write\_\-file (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ fname, }
\item[{int}]{ writeTask, }
\item[{int}]{ lastTask}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a48b0ed3a843924501df8ed871e08e77c}
This function writes an actual snapshot file containing the data from processors 'writeTask' to 'lastTask'. 'writeTask' is the one that actually writes. Each snapshot file contains a header first, then particle positions, velocities and ID's. Particle masses are written only for those particle types with zero entry in MassTable. After that, first the internal energies u, and then the density is written for the SPH particles. If cooling is enabled, mean molecular weight and neutral hydrogen abundance are written for the gas particles. This is followed by the SPH smoothing length and further blocks of information, depending on included physics and compile-\/time flags. If HDF5 is used, the header is stored in a group called \char`\"{}/Header\char`\"{}, and the particle data is stored separately for each particle type in groups calles \char`\"{}/PartType0\char`\"{}, \char`\"{}/PartType1\char`\"{}, etc. The sequence of the blocks is unimportant in this case. 

$<$ Various tags used for labelling MPI messages

$<$ Various tags used for labelling MPI messages

$<$ total number of defined 0 0 for snapshot files. Must be equal to the number of entries in \char`\"{}enum iofields\char`\"{} 



Definition at line 672 of file io.c.



References All, blockpresent(), global\_\-data\_\-all\_\-processes::BoxSize, io\_\-header::BoxSize, global\_\-data\_\-all\_\-processes::BufferSize, CommBuffer, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, endrun(), fd, fill\_\-write\_\-buffer(), io\_\-header::flag\_\-cooling, io\_\-header::flag\_\-feedback, io\_\-header::flag\_\-metals, io\_\-header::flag\_\-sfr, io\_\-header::flag\_\-stellarage, get\_\-bytes\_\-per\_\-blockelement(), get\_\-dataset\_\-name(), get\_\-datatype\_\-in\_\-block(), get\_\-particles\_\-in\_\-block(), get\_\-values\_\-per\_\-blockelement(), header, global\_\-data\_\-all\_\-processes::HubbleParam, io\_\-header::HubbleParam, io\_\-header::mass, global\_\-data\_\-all\_\-processes::MassTable, my\_\-fwrite(), n\_\-type, io\_\-header::npart, io\_\-header::npartTotal, io\_\-header::npartTotalHighWord, ntot\_\-type\_\-all, io\_\-header::num\_\-files, global\_\-data\_\-all\_\-processes::NumFilesPerSnapshot, global\_\-data\_\-all\_\-processes::Omega0, io\_\-header::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, io\_\-header::OmegaLambda, io\_\-header::redshift, global\_\-data\_\-all\_\-processes::SnapFormat, Tab\_\-IO\_\-Labels, TAG\_\-LOCALN, TAG\_\-N, TAG\_\-NFORTHISTASK, TAG\_\-PDATA, ThisTask, global\_\-data\_\-all\_\-processes::Time, io\_\-header::time, and write\_\-header\_\-attributes\_\-in\_\-hdf5().



Referenced by savepositions().




\begin{DoxyCode}
{
  int type, bytes_per_blockelement, npart, nextblock, typelist[6];
  int n_for_this_task, ntask, n, p, pc, offset = 0, task;
  int blockmaxlen, ntot_type[6], nn[6];
  enum iofields blocknr;
  int blksize;
  MPI_Status status;
  FILE *fd = 0;

#ifdef HAVE_HDF5
  hid_t hdf5_file = 0, hdf5_grp[6], hdf5_headergrp = 0, hdf5_dataspace_memory;
  hid_t hdf5_datatype = 0, hdf5_dataspace_in_file = 0, hdf5_dataset = 0;
  herr_t hdf5_status;
  hsize_t dims[2], count[2], start[2];
  int rank, pcsum = 0;
  char buf[500];
#endif

#define SKIP  {my_fwrite(&blksize,sizeof(int),1,fd);}

  /* determine particle numbers of each type in file */

  if(ThisTask == writeTask)
    {
      for(n = 0; n < 6; n++)
        ntot_type[n] = n_type[n];

      for(task = writeTask + 1; task <= lastTask; task++)
        {
          MPI_Recv(&nn[0], 6, MPI_INT, task, TAG_LOCALN, MPI_COMM_WORLD, &status)
      ;
          for(n = 0; n < 6; n++)
            ntot_type[n] += nn[n];
        }

      for(task = writeTask + 1; task <= lastTask; task++)
        MPI_Send(&ntot_type[0], 6, MPI_INT, task, TAG_N, MPI_COMM_WORLD);
    }
  else
    {
      MPI_Send(&n_type[0], 6, MPI_INT, writeTask, TAG_LOCALN, MPI_COMM_WORLD);
      MPI_Recv(&ntot_type[0], 6, MPI_INT, writeTask, TAG_N, MPI_COMM_WORLD, &stat
      us);
    }



  /* fill file header */

  for(n = 0; n < 6; n++)
    {
      header.npart[n] = ntot_type[n];
      header.npartTotal[n] = (unsigned int) ntot_type_all[n];
      header.npartTotalHighWord[n] = (unsigned int) (ntot_type_all[n] >> 32);
    }

  for(n = 0; n < 6; n++)
    header.mass[n] = All.MassTable[n];

  header.time = All.Time;

  if(All.ComovingIntegrationOn)
    header.redshift = 1.0 / All.Time - 1;
  else
    header.redshift = 0;

  header.flag_sfr = 0;
  header.flag_feedback = 0;
  header.flag_cooling = 0;
  header.flag_stellarage = 0;
  header.flag_metals = 0;

#ifdef COOLING
  header.flag_cooling = 1;
#endif
#ifdef SFR
  header.flag_sfr = 1;
  header.flag_feedback = 1;
#ifdef STELLARAGE
  header.flag_stellarage = 1;
#endif
#ifdef METALS
  header.flag_metals = 1;
#endif
#endif

  header.num_files = All.NumFilesPerSnapshot;
  header.BoxSize = All.BoxSize;
  header.Omega0 = All.Omega0;
  header.OmegaLambda = All.OmegaLambda;
  header.HubbleParam = All.HubbleParam;


  /* open file and write header */

  if(ThisTask == writeTask)
    {
      if(All.SnapFormat == 3)
        {
#ifdef HAVE_HDF5
          sprintf(buf, "%s.hdf5", fname);
          hdf5_file = H5Fcreate(buf, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);

          hdf5_headergrp = H5Gcreate(hdf5_file, "/Header", 0);

          for(type = 0; type < 6; type++)
            {
              if(header.npart[type] > 0)
                {
                  sprintf(buf, "/PartType%d", type);
                  hdf5_grp[type] = H5Gcreate(hdf5_file, buf, 0);
                }
            }

          write_header_attributes_in_hdf5(hdf5_headergrp);
#endif
        }
      else
        {
          if(!(fd = fopen(fname, "w")))
            {
              printf("can't open file `%s' for writing snapshot.\n", fname);
              endrun(123);
            }

          if(All.SnapFormat == 2)
            {
              blksize = sizeof(int) + 4 * sizeof(char);
              SKIP;
              my_fwrite("HEAD", sizeof(char), 4, fd);
              nextblock = sizeof(header) + 2 * sizeof(int);
              my_fwrite(&nextblock, sizeof(int), 1, fd);
              SKIP;
            }

          blksize = sizeof(header);
          SKIP;
          my_fwrite(&header, sizeof(header), 1, fd);
          SKIP;
        }
    }

  ntask = lastTask - writeTask + 1;

  for(blocknr = 0; blocknr < IO_NBLOCKS; blocknr++)
    {
      if(blockpresent(blocknr))
        {
          bytes_per_blockelement = get_bytes_per_blockelement(blocknr);

          blockmaxlen = ((int) (All.BufferSize * 1024 * 1024)) / bytes_per_blocke
      lement;

          npart = get_particles_in_block(blocknr, &typelist[0]);

          if(npart > 0)
            {
              if(ThisTask == writeTask)
                {

                  if(All.SnapFormat == 1 || All.SnapFormat == 2)
                    {
                      if(All.SnapFormat == 2)
                        {
                          blksize = sizeof(int) + 4 * sizeof(char);
                          SKIP;
                          my_fwrite(Tab_IO_Labels[blocknr], sizeof(char), 4, fd);
      
                          nextblock = npart * bytes_per_blockelement + 2 * sizeof
      (int);
                          my_fwrite(&nextblock, sizeof(int), 1, fd);
                          SKIP;
                        }

                      blksize = npart * bytes_per_blockelement;
                      SKIP;

                    }
                }

              for(type = 0; type < 6; type++)
                {
                  if(typelist[type])
                    {
#ifdef HAVE_HDF5
                      if(ThisTask == writeTask && All.SnapFormat == 3 && header.
      npart[type] > 0)
                        {
                          switch (get_datatype_in_block(blocknr))
                            {
                            case 0:
                              hdf5_datatype = H5Tcopy(H5T_NATIVE_UINT);
                              break;
                            case 1:
                              hdf5_datatype = H5Tcopy(H5T_NATIVE_FLOAT);
                              break;
                            case 2:
                              hdf5_datatype = H5Tcopy(H5T_NATIVE_UINT64);
                              break;
                            }

                          dims[0] = header.npart[type];
                          dims[1] = get_values_per_blockelement(blocknr);
                          if(dims[1] == 1)
                            rank = 1;
                          else
                            rank = 2;

                          get_dataset_name(blocknr, buf);

                          hdf5_dataspace_in_file = H5Screate_simple(rank, dims, N
      ULL);
                          hdf5_dataset =
                            H5Dcreate(hdf5_grp[type], buf, hdf5_datatype, hdf5_da
      taspace_in_file,
                                      H5P_DEFAULT);
                          pcsum = 0;
                        }
#endif

                      for(task = writeTask, offset = 0; task <= lastTask; task++)
      
                        {
                          if(task == ThisTask)
                            {
                              n_for_this_task = n_type[type];

                              for(p = writeTask; p <= lastTask; p++)
                                if(p != ThisTask)
                                  MPI_Send(&n_for_this_task, 1, MPI_INT, p, 
      TAG_NFORTHISTASK, MPI_COMM_WORLD);
                            }
                          else
                            MPI_Recv(&n_for_this_task, 1, MPI_INT, task, 
      TAG_NFORTHISTASK, MPI_COMM_WORLD,
                                     &status);

                          while(n_for_this_task > 0)
                            {
                              pc = n_for_this_task;

                              if(pc > blockmaxlen)
                                pc = blockmaxlen;

                              if(ThisTask == task)
                                fill_write_buffer(blocknr, &offset, pc, type);

                              if(ThisTask == writeTask && task != writeTask)
                                MPI_Recv(CommBuffer, bytes_per_blockelement * pc,
       MPI_BYTE, task,
                                         TAG_PDATA, MPI_COMM_WORLD, &status);

                              if(ThisTask != writeTask && task == ThisTask)
                                MPI_Ssend(CommBuffer, bytes_per_blockelement * pc
      , MPI_BYTE, writeTask,
                                          TAG_PDATA, MPI_COMM_WORLD);

                              if(ThisTask == writeTask)
                                {
                                  if(All.SnapFormat == 3)
                                    {
#ifdef HAVE_HDF5
                                      start[0] = pcsum;
                                      start[1] = 0;

                                      count[0] = pc;
                                      count[1] = get_values_per_blockelement(bloc
      knr);
                                      pcsum += pc;

                                      H5Sselect_hyperslab(hdf5_dataspace_in_file,
       H5S_SELECT_SET,
                                                          start, NULL, count, NUL
      L);

                                      dims[0] = pc;
                                      dims[1] = get_values_per_blockelement(block
      nr);
                                      hdf5_dataspace_memory = H5Screate_simple(ra
      nk, dims, NULL);

                                      hdf5_status =
                                        H5Dwrite(hdf5_dataset, hdf5_datatype, hdf
      5_dataspace_memory,
                                                 hdf5_dataspace_in_file, H5P_DEFA
      ULT, CommBuffer);

                                      H5Sclose(hdf5_dataspace_memory);
#endif
                                    }
                                  else
                                    my_fwrite(CommBuffer, bytes_per_blockelement,
       pc, fd);
                                }

                              n_for_this_task -= pc;
                            }
                        }

#ifdef HAVE_HDF5
                      if(ThisTask == writeTask && All.SnapFormat == 3 && header.
      npart[type] > 0)
                        {
                          if(All.SnapFormat == 3)
                            {
                              H5Dclose(hdf5_dataset);
                              H5Sclose(hdf5_dataspace_in_file);
                              H5Tclose(hdf5_datatype);
                            }
                        }
#endif
                    }
                }

              if(ThisTask == writeTask)
                {
                  if(All.SnapFormat == 1 || All.SnapFormat == 2)
                    SKIP;
                }
            }
        }
    }

  if(ThisTask == writeTask)
    {
      if(All.SnapFormat == 3)
        {
#ifdef HAVE_HDF5
          for(type = 5; type >= 0; type--)
            if(header.npart[type] > 0)
              H5Gclose(hdf5_grp[type]);
          H5Gclose(hdf5_headergrp);
          H5Fclose(hdf5_file);
#endif
        }
      else
        fclose(fd);
    }
}
\end{DoxyCode}




Here is the call graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a48b0ed3a843924501df8ed871e08e77c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_a48b0ed3a843924501df8ed871e08e77c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf}{
\index{proto.h@{proto.h}!write\_\-header\_\-attributes\_\-in\_\-hdf5@{write\_\-header\_\-attributes\_\-in\_\-hdf5}}
\index{write\_\-header\_\-attributes\_\-in\_\-hdf5@{write\_\-header\_\-attributes\_\-in\_\-hdf5}!proto.h@{proto.h}}
\subsubsection[{write\_\-header\_\-attributes\_\-in\_\-hdf5}]{\setlength{\rightskip}{0pt plus 5cm}void write\_\-header\_\-attributes\_\-in\_\-hdf5 (
\begin{DoxyParamCaption}
\item[{hid\_\-t}]{ handle}
\end{DoxyParamCaption}
)}}
\label{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf}
This function writes the header information in case HDF5 is selected as file format. 

Definition at line 998 of file io.c.



References io\_\-header::BoxSize, io\_\-header::flag\_\-cooling, io\_\-header::flag\_\-entropy\_\-instead\_\-u, io\_\-header::flag\_\-feedback, io\_\-header::flag\_\-metals, io\_\-header::flag\_\-sfr, io\_\-header::flag\_\-stellarage, header, io\_\-header::HubbleParam, io\_\-header::mass, io\_\-header::npart, io\_\-header::npartTotal, io\_\-header::npartTotalHighWord, io\_\-header::num\_\-files, io\_\-header::Omega0, io\_\-header::OmegaLambda, io\_\-header::redshift, and io\_\-header::time.



Referenced by write\_\-file().




\begin{DoxyCode}
{
  hsize_t adim[1] = { 6 };
  hid_t hdf5_dataspace, hdf5_attribute;

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "NumPart_ThisFile", H5T_NATIVE_INT, hdf5_dat
      aspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, header.npart);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "NumPart_Total", H5T_NATIVE_UINT, hdf5_datas
      pace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotal);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "NumPart_Total_HW", H5T_NATIVE_UINT, hdf5_da
      taspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotalHighWord);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);


  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "MassTable", H5T_NATIVE_DOUBLE, hdf5_dataspa
      ce, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, header.mass);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Time", H5T_NATIVE_DOUBLE, hdf5_dataspace, H
      5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.time);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Redshift", H5T_NATIVE_DOUBLE, hdf5_dataspac
      e, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.redshift);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "BoxSize", H5T_NATIVE_DOUBLE, hdf5_dataspace
      , H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.BoxSize);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "NumFilesPerSnapshot", H5T_NATIVE_INT, hdf5_
      dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.num_files);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Omega0", H5T_NATIVE_DOUBLE, hdf5_dataspace,
       H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.Omega0);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "OmegaLambda", H5T_NATIVE_DOUBLE, hdf5_datas
      pace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.OmegaLambda);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "HubbleParam", H5T_NATIVE_DOUBLE, hdf5_datas
      pace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.HubbleParam);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Sfr", H5T_NATIVE_INT, hdf5_dataspace, 
      H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_sfr);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Cooling", H5T_NATIVE_INT, hdf5_dataspa
      ce, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_cooling);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_StellarAge", H5T_NATIVE_INT, hdf5_data
      space, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_stellarage);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Metals", H5T_NATIVE_INT, hdf5_dataspac
      e, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_metals);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Feedback", H5T_NATIVE_INT, hdf5_datasp
      ace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_feedback);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  header.flag_entropy_instead_u = 0;

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "Flag_Entropy_ICs", H5T_NATIVE_UINT, hdf5_da
      taspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, &header.flag_entropy_instead_u);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);
}
\end{DoxyCode}




Here is the caller graph for this function:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a38a8b7521229c82f0f4146f60b88d9c5}{
\index{proto.h@{proto.h}!write\_\-pid\_\-file@{write\_\-pid\_\-file}}
\index{write\_\-pid\_\-file@{write\_\-pid\_\-file}!proto.h@{proto.h}}
\subsubsection[{write\_\-pid\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void write\_\-pid\_\-file (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{proto_8h_a38a8b7521229c82f0f4146f60b88d9c5}
