\hypertarget{proto_8h}{\section{proto.\-h \-File \-Reference}
\label{proto_8h}\index{proto.\-h@{proto.\-h}}
}


this file contains all function prototypes of the code  


{\ttfamily \#include $<$hdf5.\-h$>$}\*
{\ttfamily \#include \char`\"{}allvars.\-h\char`\"{}}\*
\-Include dependency graph for proto.\-h\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=286pt]{proto_8h__incl}
\end{center}
\end{figure}
\-This graph shows which files directly or indirectly include this file\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{proto_8h_a05e5a546d63684b55d2457aa56efdd06}{advance\-\_\-and\-\_\-find\-\_\-timesteps} (void)
\item 
void \hyperlink{proto_8h_a9e761db39213af33ba28aeed461f1a5a}{allocate\-\_\-commbuffers} (void)
\item 
void \hyperlink{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7}{allocate\-\_\-memory} (void)
\item 
void \hyperlink{proto_8h_aceeb5c8909331b90ea8345e0fc853f82}{begrun} (void)
\item 
int \hyperlink{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e}{blockpresent} (enum iofields blocknr)
\item 
void \hyperlink{proto_8h_adf560a3f7c53865f7edbf9ff3b16c8fd}{catch\-\_\-abort} (int sig)
\item 
void \hyperlink{proto_8h_a690d62711b56d77e574ae4dd38fb72f0}{catch\-\_\-fatal} (int sig)
\item 
void \hyperlink{proto_8h_a1b96c5b41f1209ee91cd369f01a52352}{check\-\_\-omega} (void)
\item 
void \hyperlink{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}{close\-\_\-outputfiles} (void)
\item 
int \hyperlink{proto_8h_af3ffb253e14a79419d1effeee1b7261d}{compare\-\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a147f9422f4bca4666608da992486b417}{compute\-\_\-accelerations} (int mode)
\item 
void \hyperlink{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1}{compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system} (void)
\item 
void \hyperlink{proto_8h_a04474459731219f9601aaefedb37ab27}{compute\-\_\-potential} (void)
\item 
int \hyperlink{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1}{dens\-\_\-compare\-\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density} (void)
\item 
void \hyperlink{proto_8h_aaeec847fb319935d1a6e765ffbb9c6d9}{density\-\_\-decouple} (void)
\item 
void \hyperlink{proto_8h_a19f7a07621c698ae894f53836e9ff03c}{density\-\_\-evaluate} (int i, int mode)
\item 
void \hyperlink{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab}{distribute\-\_\-file} (int nfiles, int firstfile, int firsttask, int lasttask, int $\ast$filenr, int $\ast$master, int $\ast$\hyperlink{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}{last})
\item 
double \hyperlink{proto_8h_ac5e72d197cde6d71017e89db9b986b85}{dmax} (double, double)
\item 
double \hyperlink{proto_8h_a128779c23a7c6e9cca2374c5e7c91483}{dmin} (double, double)
\item 
void \hyperlink{proto_8h_adda9e167a16a53d1aa40180406950446}{do\-\_\-box\-\_\-wrapping} (void)
\item 
void \hyperlink{proto_8h_ae8e3aa408eaab9544cb7f93e69185492}{domain\-\_\-\-Decomposition} (void)
\item 
int \hyperlink{proto_8h_a5b596de46669fab5e125f163d44edc37}{domain\-\_\-compare\-\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
int \hyperlink{proto_8h_a381621bc90438c5a50826bfdac8e4700}{domain\-\_\-compare\-\_\-toplist} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a77c115c3aa2069d0eb8521329be0483c}{domain\-\_\-count\-To\-Go} (void)
\item 
void \hyperlink{proto_8h_a647e0c1a76b7f064ed5d201662f364bf}{domain\-\_\-decompose} (void)
\item 
void \hyperlink{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729}{domain\-\_\-determine\-Top\-Tree} (void)
\item 
void \hyperlink{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca}{domain\-\_\-exchange\-Particles} (int partner, int sphflag, int send\-\_\-count, int recv\-\_\-count)
\item 
void \hyperlink{proto_8h_a0e758ec7eef32fc7180092547f5a11b9}{domain\-\_\-find\-Exchange\-Numbers} (int task, int partner, int sphflag, int $\ast$send, int $\ast$recv)
\item 
void \hyperlink{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e}{domain\-\_\-find\-Extent} (void)
\item 
int \hyperlink{proto_8h_a412d5d8810751249cc8dcd9e219e4e57}{domain\-\_\-find\-Split} (int cpustart, int ncpu, int first, int \hyperlink{forcetree_8c_a72e27dee31b1c4c6a504fbed29542d97}{last})
\item 
void \hyperlink{proto_8h_a89c54187117b91d4270a4f0c406ce2ba}{domain\-\_\-shift\-Split} (void)
\item 
void \hyperlink{proto_8h_a25aada0d3751c2afd2a376151d1d917e}{domain\-\_\-sum\-Cost} (void)
\item 
void \hyperlink{proto_8h_a606de536756a67ad8f79f1135009195e}{domain\-\_\-topsplit} (int node, peanokey startkey)
\item 
void \hyperlink{proto_8h_aa5001f9be833c4673392b40e7be3a421}{domain\-\_\-topsplit\-\_\-local} (int node, peanokey startkey)
\item 
double \hyperlink{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e}{drift\-\_\-integ} (double a, void $\ast$param)
\item 
void \hyperlink{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0}{dump\-\_\-particles} (void)
\item 
void \hyperlink{proto_8h_a3757efb7e470353080a128388ccebec9}{empty\-\_\-read\-\_\-buffer} (enum iofields blocknr, int offset, int pc, int type)
\item 
void \hyperlink{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d}{endrun} (int)
\item 
void \hyperlink{proto_8h_ae903322da17c6875ab606b032b918099}{energy\-\_\-statistics} (void)
\item 
void \hyperlink{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d}{every\-\_\-timestep\-\_\-stuff} (void)
\item 
void \hyperlink{proto_8h_ad8b8e212e593e1795f6ba522239086fc}{ewald\-\_\-corr} (double dx, double dy, double dz, double $\ast$fper)
\item 
void \hyperlink{proto_8h_a0c4d2bd0695737095313d7dc47ce120c}{ewald\-\_\-force} (int ii, int jj, int kk, double x\mbox{[}3\mbox{]}, double force\mbox{[}3\mbox{]})
\item 
void \hyperlink{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6}{ewald\-\_\-init} (void)
\item 
double \hyperlink{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58}{ewald\-\_\-pot\-\_\-corr} (double dx, double dy, double dz)
\item 
double \hyperlink{proto_8h_a4a219224b239f0c20497e54ae421f134}{ewald\-\_\-psi} (double x\mbox{[}3\mbox{]})
\item 
void \hyperlink{proto_8h_a10281a87abe1e07d6ca603de6a533345}{fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels} (void)
\item 
void \hyperlink{proto_8h_aea8fa222a10c4796687c6ff25550cd74}{fill\-\_\-write\-\_\-buffer} (enum iofields blocknr, int $\ast$pindex, int pc, int type)
\item 
void \hyperlink{proto_8h_a78ed439b8a1cb93647a2b9de998d9269}{find\-\_\-dt\-\_\-displacement\-\_\-constraint} (double hfac)
\item 
int \hyperlink{proto_8h_ac028b474d53a40e79377b7ae5dde636a}{find\-\_\-files} (char $\ast$fname)
\item 
int \hyperlink{proto_8h_a532b4637166ab194c1b1d0dee9f003f2}{find\-\_\-next\-\_\-outputtime} (int time)
\item 
void \hyperlink{proto_8h_ad52604af910b3e1677718d863ab09391}{find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift} (void)
\item 
void \hyperlink{proto_8h_a8eaedfa5c6d72bca79b465003679ed89}{force\-\_\-create\-\_\-empty\-\_\-nodes} (int no, int topnode, int bits, int x, int y, int z, int $\ast$nodecount, int $\ast$nextfree)
\item 
void \hyperlink{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb}{force\-\_\-exchange\-\_\-pseudodata} (void)
\item 
void \hyperlink{proto_8h_a947a734f3bbba14d4092c7480880d3c7}{force\-\_\-flag\-\_\-localnodes} (void)
\item 
void \hyperlink{proto_8h_ad9e0a57b7577d64a315c142e197d292d}{force\-\_\-insert\-\_\-pseudo\-\_\-particles} (void)
\item 
void \hyperlink{proto_8h_ae809fba68f599de9874f593b77d0bbfd}{force\-\_\-setupnonrecursive} (int no)
\item 
void \hyperlink{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2}{force\-\_\-treeallocate} (int maxnodes, int maxpart)
\item 
int \hyperlink{proto_8h_a10f92098e86f82baec9f84a283f4c9e5}{force\-\_\-treebuild} (int npart)
\item 
int \hyperlink{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6}{force\-\_\-treebuild\-\_\-single} (int npart)
\item 
int \hyperlink{proto_8h_a59ae74ef51d6a7065605638422489391}{force\-\_\-treeevaluate} (int target, int mode, double $\ast$ewaldcountsum)
\item 
int \hyperlink{proto_8h_a0ec221b2517893874b12dc366bfe0da8}{force\-\_\-treeevaluate\-\_\-direct} (int target, int mode)
\item 
int \hyperlink{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f}{force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction} (int target, int mode, double pos\-\_\-x, double pos\-\_\-y, double pos\-\_\-z, double aold)
\item 
void \hyperlink{proto_8h_a804166b1847da509d8fe57072b40d5f9}{force\-\_\-treeevaluate\-\_\-potential} (int target, int type)
\item 
void \hyperlink{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7}{force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange} (int target, int mode)
\item 
int \hyperlink{proto_8h_ae01e179b7686a7fe62970160b7bbdb46}{force\-\_\-treeevaluate\-\_\-shortrange} (int target, int mode)
\item 
void \hyperlink{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888}{force\-\_\-treefree} (void)
\item 
void \hyperlink{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19}{force\-\_\-treeupdate\-\_\-pseudos} (void)
\item 
void \hyperlink{proto_8h_a4764c1fb83a956c1712345538630854c}{force\-\_\-update\-\_\-hmax} (void)
\item 
void \hyperlink{proto_8h_a04fb647ef783d5baeb9275d806c08365}{force\-\_\-update\-\_\-len} (void)
\item 
void \hyperlink{proto_8h_a0292cb282788bf4e4f06636096c5abdf}{force\-\_\-update\-\_\-node} (int no, int flag)
\item 
void \hyperlink{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074}{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local} (void)
\item 
void \hyperlink{proto_8h_ac3f5945bb7c73936ef49af1507265afe}{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree} (void)
\item 
void \hyperlink{proto_8h_a4592b750f8555f580691103acf1e5366}{force\-\_\-update\-\_\-node\-\_\-len\-\_\-local} (void)
\item 
void \hyperlink{proto_8h_a5f85438d619d63c812c8e05faf1f0074}{force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree} (void)
\item 
void \hyperlink{proto_8h_ab745c54c805d07ad255a3f86ff77e18d}{force\-\_\-update\-\_\-node\-\_\-recursive} (int no, int sib, int father)
\item 
void \hyperlink{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0}{force\-\_\-update\-\_\-pseudoparticles} (void)
\item 
void \hyperlink{proto_8h_a207b80df2a123bc29295a0d496186d70}{force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node} (int no)
\item 
void \hyperlink{proto_8h_a99877ff0dc6228eabf8f959569f2771e}{free\-\_\-memory} (void)
\item 
int \hyperlink{proto_8h_a49492470fcccf9d05bf51993f281f16c}{get\-\_\-bytes\-\_\-per\-\_\-blockelement} (enum iofields blocknr)
\item 
void \hyperlink{proto_8h_a4d30ce1aad9c69d5af676a6a13173686}{get\-\_\-dataset\-\_\-name} (enum iofields blocknr, char $\ast$buf)
\item 
int \hyperlink{proto_8h_acdf59daa02f065452a596cf88b4de1a1}{get\-\_\-datatype\-\_\-in\-\_\-block} (enum iofields blocknr)
\item 
double \hyperlink{proto_8h_adadb384299eb936596574417d4b6b28c}{get\-\_\-drift\-\_\-factor} (int time0, int time1)
\item 
double \hyperlink{proto_8h_a29057b821b850ab54b318d7339633059}{get\-\_\-gravkick\-\_\-factor} (int time0, int time1)
\item 
double \hyperlink{proto_8h_ace65dca1556185b12c7f22427724c90c}{get\-\_\-hydrokick\-\_\-factor} (int time0, int time1)
\item 
int \hyperlink{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9}{get\-\_\-particles\-\_\-in\-\_\-block} (enum iofields blocknr, int $\ast$typelist)
\item 
double \hyperlink{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05}{get\-\_\-random\-\_\-number} (int id)
\item 
int \hyperlink{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8}{get\-\_\-timestep} (int p, double $\ast$a, int flag)
\item 
int \hyperlink{proto_8h_a3892776d6528c51f720d2a48deb2486f}{get\-\_\-values\-\_\-per\-\_\-blockelement} (enum iofields blocknr)
\item 
int \hyperlink{proto_8h_ae9c157451dcc4cdbe02813141df2be42}{grav\-\_\-tree\-\_\-compare\-\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79}{gravity\-\_\-forcetest} (void)
\item 
void \hyperlink{proto_8h_ac559dc2aeb21d5a379a3751bea7736af}{gravity\-\_\-tree} (void)
\item 
void \hyperlink{proto_8h_a483c8f5e73b8445bbb44e3bab59f2f1d}{gravity\-\_\-tree\-\_\-shortrange} (void)
\item 
double \hyperlink{proto_8h_a2eafe05fb12d7f9d954d5b501e186051}{gravkick\-\_\-integ} (double a, void $\ast$param)
\item 
int \hyperlink{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a}{hydro\-\_\-compare\-\_\-key} (const void $\ast$a, const void $\ast$b)
\item 
void \hyperlink{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e}{hydro\-\_\-evaluate} (int target, int mode)
\item 
void \hyperlink{proto_8h_a6789381bce7d1c316df8ecf04b47a607}{hydro\-\_\-force} (void)
\item 
double \hyperlink{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d}{hydrokick\-\_\-integ} (double a, void $\ast$param)
\item 
int \hyperlink{proto_8h_a05ba897ffe0dfe737254a09c91c50d10}{imax} (int, int)
\item 
int \hyperlink{proto_8h_af52841aeeb1b5bf6787e1e2036088644}{imin} (int, int)
\item 
void \hyperlink{proto_8h_a2858154e2009b0e6e616f313177762bc}{init} (void)
\item 
void \hyperlink{proto_8h_aea1f81063199abb9d89802b444098018}{init\-\_\-drift\-\_\-table} (void)
\item 
void \hyperlink{proto_8h_a5052a0489feb425d7d910e57d7ad8102}{init\-\_\-peano\-\_\-map} (void)
\item 
void \hyperlink{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25}{long\-\_\-range\-\_\-force} (void)
\item 
void \hyperlink{proto_8h_af52079f2c63002aca9463ba0b13727df}{long\-\_\-range\-\_\-init} (void)
\item 
void \hyperlink{proto_8h_ad295b3023b3d8fad337637a640362262}{long\-\_\-range\-\_\-init\-\_\-regionsize} (void)
\item 
void \hyperlink{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31}{move\-\_\-particles} (int time0, int time1)
\item 
size\-\_\-t \hyperlink{proto_8h_a1609620c03f6b0068601735c42e3c660}{my\-\_\-fread} (void $\ast$ptr, size\-\_\-t size, size\-\_\-t nmemb, \-F\-I\-L\-E $\ast$stream)
\item 
size\-\_\-t \hyperlink{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21}{my\-\_\-fwrite} (void $\ast$ptr, size\-\_\-t size, size\-\_\-t nmemb, \-F\-I\-L\-E $\ast$stream)
\item 
int \hyperlink{proto_8h_a72ee1196e73c7c6e8683d35e4692d840}{ngb\-\_\-clear\-\_\-buf} (float searchcenter\mbox{[}3\mbox{]}, float hguess, int numngb)
\item 
void \hyperlink{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55}{ngb\-\_\-treeallocate} (int npart)
\item 
void \hyperlink{proto_8h_ac56af97a1dbbbbb07db8207246852f79}{ngb\-\_\-treebuild} (void)
\item 
int \hyperlink{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd}{ngb\-\_\-treefind\-\_\-pairs} (float searchcenter\mbox{[}3\mbox{]}, float hsml, int $\ast$startnode)
\item 
int \hyperlink{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8}{ngb\-\_\-treefind\-\_\-variable} (float searchcenter\mbox{[}3\mbox{]}, float hguess, int $\ast$startnode)
\item 
void \hyperlink{proto_8h_aab22cf240079ef5846d83729e4565f97}{ngb\-\_\-treefree} (void)
\item 
void \hyperlink{proto_8h_ab68e970cf33f44c3ff421fc2ea6e9290}{ngb\-\_\-treesearch} (int)
\item 
void \hyperlink{proto_8h_ad387916b04773b495483e10f3d24e9d6}{ngb\-\_\-treesearch\-\_\-pairs} (int)
\item 
void \hyperlink{proto_8h_a6895b316b66ff5f9f78910d65823bf00}{ngb\-\_\-update\-\_\-nodes} (void)
\item 
void \hyperlink{proto_8h_a6f629274f7b036874c743fb81d58ce68}{open\-\_\-outputfiles} (void)
\item 
peanokey \hyperlink{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df}{peano\-\_\-hilbert\-\_\-key} (int x, int y, int z, int bits)
\item 
void \hyperlink{proto_8h_af3e45a4293584b3fe28e83af75c6ed71}{peano\-\_\-hilbert\-\_\-order} (void)
\item 
void \hyperlink{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0}{pm\-\_\-init\-\_\-nonperiodic} (void)
\item 
void \hyperlink{proto_8h_ac8030592010e755c61e6ee358ee0895d}{pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate} (int dimprod)
\item 
void \hyperlink{proto_8h_afd73e48ecc5be43d057dd718f78d187d}{pm\-\_\-init\-\_\-nonperiodic\-\_\-free} (void)
\item 
void \hyperlink{proto_8h_a13e381f05efdb739cf5026384e908409}{pm\-\_\-init\-\_\-periodic} (void)
\item 
void \hyperlink{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e}{pm\-\_\-init\-\_\-periodic\-\_\-allocate} (int dimprod)
\item 
void \hyperlink{proto_8h_a259e6f8400ee889c64bc667334060742}{pm\-\_\-init\-\_\-periodic\-\_\-free} (void)
\item 
void \hyperlink{proto_8h_a57f2f415791cd83ace42bff59b2feb97}{pm\-\_\-init\-\_\-regionsize} (void)
\item 
void \hyperlink{proto_8h_ae3950c19708f6a2886dd32897efa10c4}{pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel} (void)
\item 
int \hyperlink{proto_8h_a8821224474d8690f0db99b8cfab3a8fc}{pmforce\-\_\-nonperiodic} (int grnr)
\item 
void \hyperlink{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b}{pmforce\-\_\-periodic} (void)
\item 
int \hyperlink{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9}{pmpotential\-\_\-nonperiodic} (int grnr)
\item 
void \hyperlink{proto_8h_a7938f2181f23d56ac46f3625d1a855a0}{pmpotential\-\_\-periodic} (void)
\item 
double \hyperlink{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e}{pow} (double, double)
\item 
void \hyperlink{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1}{read\-\_\-file} (char $\ast$fname, int read\-Task, int last\-Task)
\item 
void \hyperlink{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9}{read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5} (char $\ast$fname)
\item 
void \hyperlink{proto_8h_a150344fdc0c6e132aecdb6c646529df1}{read\-\_\-ic} (char $\ast$fname)
\item 
int \hyperlink{proto_8h_a849a294ac908c933ffb82dc4319af513}{read\-\_\-outputlist} (char $\ast$fname)
\item 
void \hyperlink{proto_8h_a952eae1977b498c4fdfabed1742a3ba2}{read\-\_\-parameter\-\_\-file} (char $\ast$fname)
\item 
void \hyperlink{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98}{readjust\-\_\-timebase} (double \-Time\-Max\-\_\-old, double \-Time\-Max\-\_\-new)
\item 
void \hyperlink{proto_8h_af744cef873e3093ba2924da8265d1711}{reorder\-\_\-gas} (void)
\item 
void \hyperlink{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba}{reorder\-\_\-particles} (void)
\item 
void \hyperlink{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}{restart} (int mod)
\item 
void \hyperlink{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2}{run} (void)
\item 
void \hyperlink{proto_8h_a523730833804b6d92aa7f4dd474805c5}{savepositions} (int num)
\item 
double \hyperlink{proto_8h_ad24c35a2016ce428248988795c1d3174}{second} (void)
\item 
void \hyperlink{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135}{seed\-\_\-glass} (void)
\item 
void \hyperlink{proto_8h_a9cb45ef22cae101906f021fb7a23afbe}{set\-\_\-random\-\_\-numbers} (void)
\item 
void \hyperlink{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91}{set\-\_\-softenings} (void)
\item 
void \hyperlink{proto_8h_aba986f6be1d66945199c7ea43e5c9610}{set\-\_\-units} (void)
\item 
void \hyperlink{proto_8h_abca44f066552d38c44a1cd6020d349d5}{setup\-\_\-smoothinglengths} (void)
\item 
void \hyperlink{proto_8h_ad47ac005519641e0cfc423c3802d3ef2}{statistics} (void)
\item 
void \hyperlink{proto_8h_a869daac8b2af5667db265026f09fb9d8}{terminate\-\_\-processes} (void)
\item 
double \hyperlink{proto_8h_a890645bdc4536bd797ca53028072e30d}{timediff} (double t0, double t1)
\item 
void \hyperlink{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf}{write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5} (hid\-\_\-t handle)
\item 
void \hyperlink{proto_8h_a48b0ed3a843924501df8ed871e08e77c}{write\-\_\-file} (char $\ast$fname, int read\-Task, int last\-Task)
\item 
void \hyperlink{proto_8h_a38a8b7521229c82f0f4146f60b88d9c5}{write\-\_\-pid\-\_\-file} (void)
\end{DoxyCompactItemize}


\subsection{\-Detailed \-Description}
this file contains all function prototypes of the code 

\-Definition in file \hyperlink{proto_8h_source}{proto.\-h}.



\subsection{\-Function \-Documentation}
\hypertarget{proto_8h_a05e5a546d63684b55d2457aa56efdd06}{\index{proto.\-h@{proto.\-h}!advance\-\_\-and\-\_\-find\-\_\-timesteps@{advance\-\_\-and\-\_\-find\-\_\-timesteps}}
\index{advance\-\_\-and\-\_\-find\-\_\-timesteps@{advance\-\_\-and\-\_\-find\-\_\-timesteps}!proto.h@{proto.\-h}}
\subsubsection[{advance\-\_\-and\-\_\-find\-\_\-timesteps}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf advance\-\_\-and\-\_\-find\-\_\-timesteps} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a05e5a546d63684b55d2457aa56efdd06}
\-This function advances the system in momentum space, i.\-e. it does apply the 'kick' operation after the forces have been computed. \-Additionally, it assigns new timesteps to particles. \-At start-\/up, a half-\/timestep is carried out, as well as at the end of the simulation. \-In between, the half-\/step kick that ends the previous timestep and the half-\/step kick for the new timestep are combined into one operation. $<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29 

\-Definition at line 24 of file timestep.\-c.



\-References a3inv, \-All, atime, dt\-\_\-displacement, \-Extnodes, fac1, fac2, fac3, \-Father, find\-\_\-dt\-\_\-displacement\-\_\-constraint(), \-Flag\-\_\-\-Full\-Step, get\-\_\-gravkick\-\_\-factor(), get\-\_\-hydrokick\-\_\-factor(), get\-\_\-random\-\_\-number(), get\-\_\-timestep(), hubble\-\_\-a, \-Nodes, \-Num\-Part, \-P, pow(), second(), \-Sph\-P, \-This\-Task, and timediff().



\-Referenced by run().


\begin{DoxyCode}
{
  int i, j, no, ti_step, ti_min, tend, tstart;
  double dt_entr, dt_entr2, dt_gravkick, dt_hydrokick, dt_gravkick2, 
      dt_hydrokick2, t0, t1;
  double minentropy, aphys;
  FLOAT dv[3];

#ifdef FLEXSTEPS
  int ti_grp;
#endif
#if defined(PSEUDOSYMMETRIC) && !defined(FLEXSTEPS)
  double apred, prob;
  int ti_step2;
#endif
#ifdef PMGRID
  double dt_gravkickA, dt_gravkickB;
#endif
#ifdef MAKEGLASS
  double disp, dispmax, globmax, dmean, fac, disp2sum, globdisp2sum;
#endif

  t0 = second();

  if(All.ComovingIntegrationOn)
    {
      fac1 = 1 / (All.Time * All.Time);
      fac2 = 1 / pow(All.Time, 3 * GAMMA - 2);
      fac3 = pow(All.Time, 3 * (1 - GAMMA) / 2.0);
      hubble_a = All.Omega0 / (All.Time * All.Time * All.Time)
        + (1 - All.Omega0 - All.OmegaLambda) / (All.Time * All.Time) + All.
      OmegaLambda;

      hubble_a = All.Hubble * sqrt(hubble_a);
      a3inv = 1 / (All.Time * All.Time * All.Time);
      atime = All.Time;
    }
  else
    fac1 = fac2 = fac3 = hubble_a = a3inv = atime = 1;

#ifdef NOPMSTEPADJUSTMENT
  dt_displacement = All.MaxSizeTimestep;
#else
  if(Flag_FullStep || dt_displacement == 0)
    find_dt_displacement_constraint(hubble_a * atime * atime);
#endif

#ifdef PMGRID
  if(All.ComovingIntegrationOn)
    dt_gravkickB = get_gravkick_factor(All.PM_Ti_begstep, All.Ti_Current) -
      get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
  else
    dt_gravkickB = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep) / 
      2) * All.Timebase_interval;

  if(All.PM_Ti_endstep == All.Ti_Current)       /* need to do long-range kick 
      */
    {
      /* make sure that we reconstruct the domain/tree next time because we
       don't kick the tree nodes in this case */
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
    }
#endif


#ifdef MAKEGLASS
  for(i = 0, dispmax = 0, disp2sum = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          P[i].GravPM[j] *= -1;
          P[i].GravAccel[j] *= -1;
          P[i].GravAccel[j] += P[i].GravPM[j];
          P[i].GravPM[j] = 0;
        }

      disp = sqrt(P[i].GravAccel[0] * P[i].GravAccel[0] +
                  P[i].GravAccel[1] * P[i].GravAccel[1] + P[i].GravAccel[2] * P
      [i].GravAccel[2]);

      disp *= 2.0 / (3 * All.Hubble * All.Hubble);

      disp2sum += disp * disp;

      if(disp > dispmax)
        dispmax = disp;
    }

  MPI_Allreduce(&dispmax, &globmax, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
  MPI_Allreduce(&disp2sum, &globdisp2sum, 1, MPI_DOUBLE, MPI_SUM, 
      MPI_COMM_WORLD);

  dmean = pow(P[0].Mass / (All.Omega0 * 3 * All.Hubble * All.Hubble / (8 * M_PI
       * All.G)), 1.0 / 3);

  if(globmax > dmean)
    fac = dmean / globmax;
  else
    fac = 1.0;

  if(ThisTask == 0)
    {
      printf("\nglass-making:  dmean= %g  global disp-maximum= %g  rms= %g\n\n"
      ,
             dmean, globmax, sqrt(globdisp2sum / All.TotNumPart));
      fflush(stdout);
    }

  for(i = 0, dispmax = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          P[i].Vel[j] = 0;
          P[i].Pos[j] += fac * P[i].GravAccel[j] * 2.0 / (3 * All.Hubble * All.
      Hubble);
          P[i].GravAccel[j] = 0;
        }
    }
#endif




  /* Now assign new timesteps and kick */

#ifdef FLEXSTEPS
  if((All.Ti_Current % (4 * All.PresentMinStep)) == 0)
    if(All.PresentMinStep < TIMEBASE)
      All.PresentMinStep *= 2;

  for(i = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          ti_step = get_timestep(i, &aphys, 0);

          /* make it a power 2 subdivision */
          ti_min = TIMEBASE;
          while(ti_min > ti_step)
            ti_min >>= 1;
          ti_step = ti_min;

          if(ti_step < All.PresentMinStep)
            All.PresentMinStep = ti_step;
        }
    }

  ti_step = All.PresentMinStep;
  MPI_Allreduce(&ti_step, &All.PresentMinStep, 1, MPI_INT, MPI_MIN, 
      MPI_COMM_WORLD);

  if(dt_displacement < All.MaxSizeTimestep)
    ti_step = (int) (dt_displacement / All.Timebase_interval);
  else
    ti_step = (int) (All.MaxSizeTimestep / All.Timebase_interval);

  /* make it a power 2 subdivision */
  ti_min = TIMEBASE;
  while(ti_min > ti_step)
    ti_min >>= 1;
  All.PresentMaxStep = ti_min;


  if(ThisTask == 0)
    printf("Syn Range = %g  PresentMinStep = %d  PresentMaxStep = %d \n",
           (double) All.PresentMaxStep / All.PresentMinStep, All.PresentMinStep
      , All.PresentMaxStep);

#endif


  for(i = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          ti_step = get_timestep(i, &aphys, 0);

          /* make it a power 2 subdivision */
          ti_min = TIMEBASE;
          while(ti_min > ti_step)
            ti_min >>= 1;
          ti_step = ti_min;

#ifdef FLEXSTEPS
          ti_grp = P[i].FlexStepGrp % All.PresentMaxStep;
          ti_grp = (ti_grp / All.PresentMinStep) * All.PresentMinStep;
          ti_step = ((P[i].Ti_endstep + ti_grp + ti_step) / ti_step) * ti_step 
      - (P[i].Ti_endstep + ti_grp);
#else

#ifdef PSEUDOSYMMETRIC
          if(P[i].Type != 0)
            {
              if(P[i].Ti_endstep > P[i].Ti_begstep)
                {
                  apred = aphys + ((aphys - P[i].AphysOld) / (P[i].Ti_endstep -
       P[i].Ti_begstep)) * ti_step;
                  if(fabs(apred - aphys) < 0.5 * aphys)
                    {
                      ti_step2 = get_timestep(i, &apred, -1);
                      ti_min = TIMEBASE;
                      while(ti_min > ti_step2)
                        ti_min >>= 1;
                      ti_step2 = ti_min;

                      if(ti_step2 < ti_step)
                        {
                          get_timestep(i, &apred, ti_step);
                          prob =
                            ((apred - aphys) / (aphys - P[i].AphysOld) * (P[i].
      Ti_endstep -
                                                                          P[i].
      Ti_begstep)) / ti_step;
                          if(prob < get_random_number(P[i].ID))
                            ti_step /= 2;
                        }
                      else if(ti_step2 > ti_step)
                        {
                          get_timestep(i, &apred, 2 * ti_step);
                          prob =
                            ((apred - aphys) / (aphys - P[i].AphysOld) * (P[i].
      Ti_endstep -
                                                                          P[i].
      Ti_begstep)) / ti_step;
                          if(prob < get_random_number(P[i].ID + 1))
                            ti_step *= 2;
                        }
                    }
                }
              P[i].AphysOld = aphys;
            }
#endif

#ifdef SYNCHRONIZATION
          if(ti_step > (P[i].Ti_endstep - P[i].Ti_begstep))     /* timestep
       wants to increase */
            {
              if(((TIMEBASE - P[i].Ti_endstep) % ti_step) > 0)
                ti_step = P[i].Ti_endstep - P[i].Ti_begstep;    /* leave at old
       step */
            }
#endif
#endif /* end of FLEXSTEPS */

          if(All.Ti_Current == TIMEBASE)        /* we here finish the last
       timestep. */
            ti_step = 0;

          if((TIMEBASE - All.Ti_Current) < ti_step)     /* check that we don't
       run beyond the end */
            ti_step = TIMEBASE - All.Ti_Current;

          tstart = (P[i].Ti_begstep + P[i].Ti_endstep) / 2;     /* midpoint of
       old step */
          tend = P[i].Ti_endstep + ti_step / 2; /* midpoint of new step */

          if(All.ComovingIntegrationOn)
            {
              dt_entr = (tend - tstart) * All.Timebase_interval;
              dt_entr2 = (tend - P[i].Ti_endstep) * All.Timebase_interval;
              dt_gravkick = get_gravkick_factor(tstart, tend);
              dt_hydrokick = get_hydrokick_factor(tstart, tend);
              dt_gravkick2 = get_gravkick_factor(P[i].Ti_endstep, tend);
              dt_hydrokick2 = get_hydrokick_factor(P[i].Ti_endstep, tend);
            }
          else
            {
              dt_entr = dt_gravkick = dt_hydrokick = (tend - tstart) * All.
      Timebase_interval;
              dt_gravkick2 = dt_hydrokick2 = dt_entr2 = (tend - P[i].Ti_endstep
      ) * All.Timebase_interval;
            }

          P[i].Ti_begstep = P[i].Ti_endstep;
          P[i].Ti_endstep = P[i].Ti_begstep + ti_step;


          /* do the kick */

          for(j = 0; j < 3; j++)
            {
              dv[j] = P[i].GravAccel[j] * dt_gravkick;
              P[i].Vel[j] += dv[j];
            }

          if(P[i].Type == 0)    /* SPH stuff */
            {
              for(j = 0; j < 3; j++)
                {
                  dv[j] += SphP[i].HydroAccel[j] * dt_hydrokick;
                  P[i].Vel[j] += SphP[i].HydroAccel[j] * dt_hydrokick;

                  SphP[i].VelPred[j] =
                    P[i].Vel[j] - dt_gravkick2 * P[i].GravAccel[j] - 
      dt_hydrokick2 * SphP[i].HydroAccel[j];
#ifdef PMGRID
                  SphP[i].VelPred[j] += P[i].GravPM[j] * dt_gravkickB;
#endif
                }

              /* In case of cooling, we prevent that the entropy (and
                 hence temperature decreases by more than a factor 0.5 */

              if(SphP[i].DtEntropy * dt_entr > -0.5 * SphP[i].Entropy)
                SphP[i].Entropy += SphP[i].DtEntropy * dt_entr;
              else
                SphP[i].Entropy *= 0.5;

              if(All.MinEgySpec)
                {
                  minentropy = All.MinEgySpec * GAMMA_MINUS1 / pow(SphP[i].
      Density * a3inv, GAMMA_MINUS1);
                  if(SphP[i].Entropy < minentropy)
                    {
                      SphP[i].Entropy = minentropy;
                      SphP[i].DtEntropy = 0;
                    }
                }

              /* In case the timestep increases in the new step, we
                 make sure that we do not 'overcool' when deriving
                 predicted temperatures. The maximum timespan over
                 which prediction can occur is ti_step/2, i.e. from
                 the middle to the end of the current step */

              dt_entr = ti_step / 2 * All.Timebase_interval;
              if(SphP[i].Entropy + SphP[i].DtEntropy * dt_entr < 0.5 * SphP[i].
      Entropy)
                SphP[i].DtEntropy = -0.5 * SphP[i].Entropy / dt_entr;
            }


          /* if tree is not going to be reconstructed, kick parent nodes
       dynamically.
           */
          if(All.NumForcesSinceLastDomainDecomp < All.TotNumPart * All.
      TreeDomainUpdateFrequency)
            {
              no = Father[i];
              while(no >= 0)
                {
                  for(j = 0; j < 3; j++)
                    Extnodes[no].vs[j] += dv[j] * P[i].Mass / Nodes[no].u.d.
      mass;

                  no = Nodes[no].u.d.father;
                }
            }
        }
    }



#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)       /* need to do long-range kick 
      */
    {
      ti_step = TIMEBASE;
      while(ti_step > (dt_displacement / All.Timebase_interval))
        ti_step >>= 1;

      if(ti_step > (All.PM_Ti_endstep - All.PM_Ti_begstep))     /* PM-timestep
       wants to increase */
        {
          /* we only increase if an integer number of steps will bring us to
       the end */
          if(((TIMEBASE - All.PM_Ti_endstep) % ti_step) > 0)
            ti_step = All.PM_Ti_endstep - All.PM_Ti_begstep;    /* leave at old
       step */
        }

      if(All.Ti_Current == TIMEBASE)    /* we here finish the last timestep. */
        ti_step = 0;

      tstart = (All.PM_Ti_begstep + All.PM_Ti_endstep) / 2;
      tend = All.PM_Ti_endstep + ti_step / 2;

      if(All.ComovingIntegrationOn)
        dt_gravkick = get_gravkick_factor(tstart, tend);
      else
        dt_gravkick = (tend - tstart) * All.Timebase_interval;

      All.PM_Ti_begstep = All.PM_Ti_endstep;
      All.PM_Ti_endstep = All.PM_Ti_begstep + ti_step;

      if(All.ComovingIntegrationOn)
        dt_gravkickB = -get_gravkick_factor(All.PM_Ti_begstep, (All.
      PM_Ti_begstep + All.PM_Ti_endstep) / 2);
      else
        dt_gravkickB =
          -((All.PM_Ti_begstep + All.PM_Ti_endstep) / 2 - All.PM_Ti_begstep) * 
      All.Timebase_interval;

      for(i = 0; i < NumPart; i++)
        {
          for(j = 0; j < 3; j++)        /* do the kick */
            P[i].Vel[j] += P[i].GravPM[j] * dt_gravkick;

          if(P[i].Type == 0)
            {
              if(All.ComovingIntegrationOn)
                {
                  dt_gravkickA = get_gravkick_factor(P[i].Ti_begstep, All.
      Ti_Current) -
                    get_gravkick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i
      ].Ti_endstep) / 2);
                  dt_hydrokick = get_hydrokick_factor(P[i].Ti_begstep, All.
      Ti_Current) -
                    get_hydrokick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[
      i].Ti_endstep) / 2);
                }
              else
                dt_gravkickA = dt_hydrokick =
                  (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * 
      All.Timebase_interval;

              for(j = 0; j < 3; j++)
                SphP[i].VelPred[j] = P[i].Vel[j]
                  + P[i].GravAccel[j] * dt_gravkickA
                  + SphP[i].HydroAccel[j] * dt_hydrokick + P[i].GravPM[j] * 
      dt_gravkickB;
            }
        }
    }
#endif

  t1 = second();
  All.CPU_TimeLine += timediff(t0, t1);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a05e5a546d63684b55d2457aa56efdd06_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a05e5a546d63684b55d2457aa56efdd06_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9e761db39213af33ba28aeed461f1a5a}{\index{proto.\-h@{proto.\-h}!allocate\-\_\-commbuffers@{allocate\-\_\-commbuffers}}
\index{allocate\-\_\-commbuffers@{allocate\-\_\-commbuffers}!proto.h@{proto.\-h}}
\subsubsection[{allocate\-\_\-commbuffers}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf allocate\-\_\-commbuffers} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a9e761db39213af33ba28aeed461f1a5a}
\-Allocates a number of small buffers and arrays, the largest one being the communication buffer. \-The communication buffer itself is mapped onto various tables used in the different parts of the force algorithms. \-We further allocate space for the top-\/level tree nodes, and auxiliary arrays for the domain decomposition algorithm. $<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition 

\-Definition at line 19 of file allocate.\-c.



\-References \-All, \-Comm\-Buffer, \-Dens\-Data\-Get, \-Dens\-Data\-In, \-Dens\-Data\-Partial\-Result, \-Dens\-Data\-Result, \-Domain\-Count, \-Domain\-Count\-Sph, \-Domain\-End\-List, \-Domain\-Hmax, \-Domain\-Key\-Buf, \-Domain\-Moment, \-Domain\-Node\-Index, \-Domain\-Part\-Buf, \-Domain\-Sph\-Buf, \-Domain\-Start\-List, \-Domain\-Task, \-Domain\-Tree\-Node\-Len, \-Domain\-Work, endrun(), \-Exportflag, \-Grav\-Data\-Get, \-Grav\-Data\-In, \-Grav\-Data\-Index\-Table, \-Grav\-Data\-Out, \-Grav\-Data\-Result, \-Hydro\-Data\-Get, \-Hydro\-Data\-In, \-Hydro\-Data\-Partial\-Result, \-Hydro\-Data\-Result, \-N\-Task, \-This\-Task, and \-Top\-Nodes.



\-Referenced by begrun().


\begin{DoxyCode}
{
  size_t bytes;

  Exportflag = malloc(NTask * sizeof(char));
  DomainStartList = malloc(NTask * sizeof(int));
  DomainEndList = malloc(NTask * sizeof(int));

  TopNodes = malloc(MAXTOPNODES * sizeof(struct topnode_data));

  DomainWork = malloc(MAXTOPNODES * sizeof(double));
  DomainCount = malloc(MAXTOPNODES * sizeof(int));
  DomainCountSph = malloc(MAXTOPNODES * sizeof(int));
  DomainTask = malloc(MAXTOPNODES * sizeof(int));
  DomainNodeIndex = malloc(MAXTOPNODES * sizeof(int));
  DomainTreeNodeLen = malloc(MAXTOPNODES * sizeof(FLOAT));
  DomainHmax = malloc(MAXTOPNODES * sizeof(FLOAT));
  DomainMoment = malloc(MAXTOPNODES * sizeof(struct DomainNODE));

  if(!(CommBuffer = malloc(bytes = All.BufferSize * 1024 * 1024)))
    {
      printf("failed to allocate memory for `CommBuffer' (%g MB).\n", bytes / (
      1024.0 * 1024.0));
      endrun(2);
    }

  All.BunchSizeForce =
    (All.BufferSize * 1024 * 1024) / (sizeof(struct gravdata_index) + 2 * 
      sizeof(struct gravdata_in));

  if(All.BunchSizeForce & 1)
    All.BunchSizeForce -= 1;    /* make sure that All.BunchSizeForce is an even
       number 
                                   --> 8-byte alignment for 64bit processors */

  GravDataIndexTable = (struct gravdata_index *) CommBuffer;
  GravDataIn = (struct gravdata_in *) (GravDataIndexTable + All.BunchSizeForce)
      ;
  GravDataGet = GravDataIn + All.BunchSizeForce;
  GravDataOut = GravDataIn;     /* this will overwrite the GravDataIn-Table */
  GravDataResult = GravDataGet; /* this will overwrite the GravDataGet-Table */


  All.BunchSizeDensity =
    (All.BufferSize * 1024 * 1024) / (2 * sizeof(struct densdata_in) + 2 * 
      sizeof(struct densdata_out));

  DensDataIn = (struct densdata_in *) CommBuffer;
  DensDataGet = DensDataIn + All.BunchSizeDensity;
  DensDataResult = (struct densdata_out *) (DensDataGet + All.BunchSizeDensity)
      ;
  DensDataPartialResult = DensDataResult + All.BunchSizeDensity;

  All.BunchSizeHydro =
    (All.BufferSize * 1024 * 1024) / (2 * sizeof(struct hydrodata_in) + 2 * 
      sizeof(struct hydrodata_out));

  HydroDataIn = (struct hydrodata_in *) CommBuffer;
  HydroDataGet = HydroDataIn + All.BunchSizeHydro;
  HydroDataResult = (struct hydrodata_out *) (HydroDataGet + All.BunchSizeHydro
      );
  HydroDataPartialResult = HydroDataResult + All.BunchSizeHydro;

  All.BunchSizeDomain =
    (All.BufferSize * 1024 * 1024) / (sizeof(struct particle_data) + sizeof(
      struct sph_particle_data) +
                                      sizeof(peanokey));

  if(All.BunchSizeDomain & 1)
    All.BunchSizeDomain -= 1;   /* make sure that All.BunchSizeDomain is even 
                                   --> 8-byte alignment of DomainKeyBuf for
       64bit processors */

  DomainPartBuf = (struct particle_data *) CommBuffer;
  DomainSphBuf = (struct sph_particle_data *) (DomainPartBuf + All.
      BunchSizeDomain);
  DomainKeyBuf = (peanokey *) (DomainSphBuf + All.BunchSizeDomain);


  if(ThisTask == 0)
    {
      printf("\nAllocated %d MByte communication buffer per processor.\n\n", All
      .BufferSize);
      printf("Communication buffer has room for %d particles in gravity
       computation\n", All.BunchSizeForce);
      printf("Communication buffer has room for %d particles in density
       computation\n", All.BunchSizeDensity);
      printf("Communication buffer has room for %d particles in hydro
       computation\n", All.BunchSizeHydro);
      printf("Communication buffer has room for %d particles in domain
       decomposition\n", All.BunchSizeDomain);
      printf("\n");
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a9e761db39213af33ba28aeed461f1a5a_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a9e761db39213af33ba28aeed461f1a5a_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7}{\index{proto.\-h@{proto.\-h}!allocate\-\_\-memory@{allocate\-\_\-memory}}
\index{allocate\-\_\-memory@{allocate\-\_\-memory}!proto.h@{proto.\-h}}
\subsubsection[{allocate\-\_\-memory}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf allocate\-\_\-memory} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7}
\-This routine allocates memory for particle storage, both the collisionless and the \-S\-P\-H particles. 

\-Definition at line 103 of file allocate.\-c.



\-References \-All, endrun(), \-P, \-Sph\-P, and \-This\-Task.



\-Referenced by read\-\_\-file(), and restart().


\begin{DoxyCode}
{
  size_t bytes;
  double bytes_tot = 0;

  if(All.MaxPart > 0)
    {
      if(!(P = malloc(bytes = All.MaxPart * sizeof(struct particle_data))))
        {
          printf("failed to allocate memory for `P' (%g MB).\n", bytes / (1024.
      0 * 1024.0));
          endrun(1);
        }
      bytes_tot += bytes;

      if(ThisTask == 0)
        printf("\nAllocated %g MByte for particle storage. %lu\n\n", bytes_tot 
      / (1024.0 * 1024.0), sizeof(struct particle_data));
    }

  if(All.MaxPartSph > 0)
    {
      bytes_tot = 0;

      if(!(SphP = malloc(bytes = All.MaxPartSph * sizeof(struct 
      sph_particle_data))))
        {
          printf("failed to allocate memory for `SphP' (%g MB) %lu.\n", bytes /
       (1024.0 * 1024.0), sizeof(struct sph_particle_data));
          endrun(1);
        }
      bytes_tot += bytes;

      if(ThisTask == 0)
        printf("Allocated %g MByte for storage of SPH data. %lu\n\n", bytes_tot
       / (1024.0 * 1024.0), sizeof(struct sph_particle_data));
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a7fe5e304baaf5f418a22fef9a9cc02c7_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aceeb5c8909331b90ea8345e0fc853f82}{\index{proto.\-h@{proto.\-h}!begrun@{begrun}}
\index{begrun@{begrun}!proto.h@{proto.\-h}}
\subsubsection[{begrun}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf begrun} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aceeb5c8909331b90ea8345e0fc853f82}
\-This function performs the initial set-\/up of the simulation. \-First, the parameterfile is set, then routines for setting units, reading \-I\-Cs/restart-\/files are called, auxialiary memory is allocated, etc. $<$ code version string 

\-Definition at line 28 of file begrun.\-c.



\-References \-All, allocate\-\_\-commbuffers(), \-Allocate\-Interaction\-Table(), \-C\-P\-U\-This\-Run, ewald\-\_\-init(), find\-\_\-next\-\_\-outputtime(), init(), init\-\_\-drift\-\_\-table(), init\-\_\-geofactor\-\_\-table(), long\-\_\-range\-\_\-init(), long\-\_\-range\-\_\-init\-\_\-regionsize(), \-N\-Task, \-Num\-Part, open\-\_\-outputfiles(), \-P, \-Parameter\-File, random\-\_\-generator, read\-\_\-parameter\-\_\-file(), readjust\-\_\-timebase(), restart(), \-Restart\-Flag, set\-\_\-random\-\_\-numbers(), set\-\_\-units(), and \-This\-Task.



\-Referenced by main().


\begin{DoxyCode}
{
  struct global_data_all_processes all;

  if(ThisTask == 0)
    {
      printf("\nThis is Gadget, version `%s'.\n", GADGETVERSION);
      printf("\nRunning on %d processors.\n", NTask);
    }

  read_parameter_file(ParameterFile);   /* ... read in parameters for this run 
      */

  allocate_commbuffers();       /* ... allocate buffer-memory for particle 
                                   exchange during force computation */
  set_units();

#if defined(PERIODIC) && (!defined(PMGRID) || defined(FORCETEST))
  ewald_init();
#endif

  open_outputfiles();

  random_generator = gsl_rng_alloc(gsl_rng_ranlxd1);
  gsl_rng_set(random_generator, 42);    /* start-up seed */

#ifdef PMGRID
  long_range_init();
#endif

  All.TimeLastRestartFile = CPUThisRun;

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  int i;
  for(i = 0; i < NumPart; i++)
    P[i].dTi_selfInt = 0;
  AllocateInteractionTable(INTERACTION_TABLE_LENGTH, PARTICLE_MAX_INTERACTIONS 
      + 1);
  init_geofactor_table();
#endif

  if(RestartFlag == 0 || RestartFlag == 2)
    {
      set_random_numbers();

      init();                   /* ... read in initial model */
    }
  else
    {
      all = All;                /* save global variables. (will be read from
       restart file) */

      restart(RestartFlag);     /* ... read restart file. Note: This also
       resets 
                                   all variables in the struct `All'. 
                                   However, during the run, some variables in
       the parameter
                                   file are allowed to be changed, if desired.
       These need to 
                                   copied in the way below.
                                   Note:  All.PartAllocFactor is treated in
       restart() separately.  
                                 */

      All.MinSizeTimestep = all.MinSizeTimestep;
      All.MaxSizeTimestep = all.MaxSizeTimestep;
      All.BufferSize = all.BufferSize;
      All.BunchSizeForce = all.BunchSizeForce;
      All.BunchSizeDensity = all.BunchSizeDensity;
      All.BunchSizeHydro = all.BunchSizeHydro;
      All.BunchSizeDomain = all.BunchSizeDomain;

      All.TimeLimitCPU = all.TimeLimitCPU;
      All.ResubmitOn = all.ResubmitOn;
      All.TimeBetSnapshot = all.TimeBetSnapshot;
      All.TimeBetStatistics = all.TimeBetStatistics;
      All.CpuTimeBetRestartFile = all.CpuTimeBetRestartFile;
      All.ErrTolIntAccuracy = all.ErrTolIntAccuracy;
      All.MaxRMSDisplacementFac = all.MaxRMSDisplacementFac;

      All.ErrTolForceAcc = all.ErrTolForceAcc;

      All.TypeOfTimestepCriterion = all.TypeOfTimestepCriterion;
      All.TypeOfOpeningCriterion = all.TypeOfOpeningCriterion;
      All.NumFilesWrittenInParallel = all.NumFilesWrittenInParallel;
      All.TreeDomainUpdateFrequency = all.TreeDomainUpdateFrequency;

      All.SnapFormat = all.SnapFormat;
      All.NumFilesPerSnapshot = all.NumFilesPerSnapshot;
      All.MaxNumNgbDeviation = all.MaxNumNgbDeviation;
      All.ArtBulkViscConst = all.ArtBulkViscConst;


      All.OutputListOn = all.OutputListOn;
      All.CourantFac = all.CourantFac;

      All.OutputListLength = all.OutputListLength;
      memcpy(All.OutputListTimes, all.OutputListTimes, sizeof(double) * All.
      OutputListLength);


      strcpy(All.ResubmitCommand, all.ResubmitCommand);
      strcpy(All.OutputListFilename, all.OutputListFilename);
      strcpy(All.OutputDir, all.OutputDir);
      strcpy(All.RestartFile, all.RestartFile);
      strcpy(All.EnergyFile, all.EnergyFile);
      strcpy(All.InfoFile, all.InfoFile);
      strcpy(All.CpuFile, all.CpuFile);
      strcpy(All.TimingsFile, all.TimingsFile);
      strcpy(All.SnapshotFileBase, all.SnapshotFileBase);

      if(All.TimeMax != all.TimeMax)
        readjust_timebase(All.TimeMax, all.TimeMax);
    }

#ifdef PMGRID
  long_range_init_regionsize();
#endif
 
  if(All.ComovingIntegrationOn)
    init_drift_table();

  if(RestartFlag == 2)
    All.Ti_nextoutput = find_next_outputtime(All.Ti_Current + 1);
  else
    All.Ti_nextoutput = find_next_outputtime(All.Ti_Current);


  All.TimeLastRestartFile = CPUThisRun;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aceeb5c8909331b90ea8345e0fc853f82_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=208pt]{proto_8h_aceeb5c8909331b90ea8345e0fc853f82_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e}{\index{proto.\-h@{proto.\-h}!blockpresent@{blockpresent}}
\index{blockpresent@{blockpresent}!proto.h@{proto.\-h}}
\subsubsection[{blockpresent}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf blockpresent} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e}
\-This function tells whether or not a given block in the output file is present, depending on the type of simulation run and the compile-\/time options. \-If one wants to add a new output-\/block, this function should be augmented accordingly. 

\-Definition at line 532 of file io.\-c.



\-Referenced by read\-\_\-file(), and write\-\_\-file().


\begin{DoxyCode}
{

#ifndef OUTPUTPOTENTIAL
  if(blocknr == IO_POT)
    return 0;
#endif

#ifndef OUTPUTACCELERATION
  if(blocknr == IO_ACCEL)
    return 0;
#endif

#ifndef OUTPUTCHANGEOFENTROPY
  if(blocknr == IO_DTENTR)
    return 0;
#endif

#ifndef OUTPUTTIMESTEP
  if(blocknr == IO_TSTP)
    return 0;
#endif

  return 1;                     /* default: present */
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad9c685a2d6d48224bfec61680ce82b1e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_adf560a3f7c53865f7edbf9ff3b16c8fd}{\index{proto.\-h@{proto.\-h}!catch\-\_\-abort@{catch\-\_\-abort}}
\index{catch\-\_\-abort@{catch\-\_\-abort}!proto.h@{proto.\-h}}
\subsubsection[{catch\-\_\-abort}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf catch\-\_\-abort} (
\begin{DoxyParamCaption}
\item[{int}]{sig}
\end{DoxyParamCaption}
)}}\label{proto_8h_adf560a3f7c53865f7edbf9ff3b16c8fd}
\hypertarget{proto_8h_a690d62711b56d77e574ae4dd38fb72f0}{\index{proto.\-h@{proto.\-h}!catch\-\_\-fatal@{catch\-\_\-fatal}}
\index{catch\-\_\-fatal@{catch\-\_\-fatal}!proto.h@{proto.\-h}}
\subsubsection[{catch\-\_\-fatal}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf catch\-\_\-fatal} (
\begin{DoxyParamCaption}
\item[{int}]{sig}
\end{DoxyParamCaption}
)}}\label{proto_8h_a690d62711b56d77e574ae4dd38fb72f0}
\hypertarget{proto_8h_a1b96c5b41f1209ee91cd369f01a52352}{\index{proto.\-h@{proto.\-h}!check\-\_\-omega@{check\-\_\-omega}}
\index{check\-\_\-omega@{check\-\_\-omega}!proto.h@{proto.\-h}}
\subsubsection[{check\-\_\-omega}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf check\-\_\-omega} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a1b96c5b41f1209ee91cd369f01a52352}
\-This routine computes the mass content of the box and compares it to the specified value of \-Omega-\/matter. \-If discrepant, the run is terminated. 

\-Definition at line 162 of file init.\-c.



\-References \-All, endrun(), \-Num\-Part, \-P, and \-This\-Task.



\-Referenced by init().


\begin{DoxyCode}
{
  double mass = 0, masstot, omega;
  int i;

  for(i = 0; i < NumPart; i++)
    mass += P[i].Mass;

  MPI_Allreduce(&mass, &masstot, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);

  omega =
    masstot / (All.BoxSize * All.BoxSize * All.BoxSize) / (3 * All.Hubble * All
      .Hubble / (8 * M_PI * All.G));

  if(fabs(omega - All.Omega0) > 1.0e-3)
    {
      if(ThisTask == 0)
        {
          printf("\n\nI've found something odd!\n");
          printf
            ("The mass content accounts only for Omega=%g,\nbut you specified
       Omega=%g in the parameterfile.\n",
             omega, All.Omega0);
          printf("\nI better stop.\n");

          fflush(stdout);
        }
      endrun(1);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a1b96c5b41f1209ee91cd369f01a52352_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a1b96c5b41f1209ee91cd369f01a52352_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}{\index{proto.\-h@{proto.\-h}!close\-\_\-outputfiles@{close\-\_\-outputfiles}}
\index{close\-\_\-outputfiles@{close\-\_\-outputfiles}!proto.h@{proto.\-h}}
\subsubsection[{close\-\_\-outputfiles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf close\-\_\-outputfiles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}
\-This function closes the global log-\/files. 

\-Definition at line 265 of file begrun.\-c.



\-References \-Fd\-C\-P\-U, \-Fd\-Energy, \-Fd\-Force\-Test, \-Fd\-Info, \-Fd\-Timings, and \-This\-Task.



\-Referenced by run().


\begin{DoxyCode}
{
  if(ThisTask != 0)             /* only the root processor writes to the log
       files */
    return;

  fclose(FdCPU);
  fclose(FdInfo);
  fclose(FdEnergy);
  fclose(FdTimings);
#ifdef FORCETEST
  fclose(FdForceTest);
#endif
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_aa1abb9ee0e0a43ec19cdaa55c8ecd43c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af3ffb253e14a79419d1effeee1b7261d}{\index{proto.\-h@{proto.\-h}!compare\-\_\-key@{compare\-\_\-key}}
\index{compare\-\_\-key@{compare\-\_\-key}!proto.h@{proto.\-h}}
\subsubsection[{compare\-\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf compare\-\_\-key} (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{proto_8h_af3ffb253e14a79419d1effeee1b7261d}
\-This function is a comparison kernel for sorting the \-Peano-\/\-Hilbert keys. 

\-Definition at line 98 of file peano.\-c.



\-Referenced by peano\-\_\-hilbert\-\_\-order().


\begin{DoxyCode}
{
  if(((struct peano_hilbert_data *) a)->key < (((struct peano_hilbert_data *) b
      )->key))
    return -1;

  if(((struct peano_hilbert_data *) a)->key > (((struct peano_hilbert_data *) b
      )->key))
    return +1;

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af3ffb253e14a79419d1effeee1b7261d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a147f9422f4bca4666608da992486b417}{\index{proto.\-h@{proto.\-h}!compute\-\_\-accelerations@{compute\-\_\-accelerations}}
\index{compute\-\_\-accelerations@{compute\-\_\-accelerations}!proto.h@{proto.\-h}}
\subsubsection[{compute\-\_\-accelerations}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf compute\-\_\-accelerations} (
\begin{DoxyParamCaption}
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a147f9422f4bca4666608da992486b417}
\-This routine computes the accelerations for all active particles. \-First, the long-\/range \-P\-M force is computed if the \-Tree\-P\-M algorithm is used and a \char`\"{}big\char`\"{} \-P\-M step is done. \-Next, the gravitational tree forces are computed. \-This also constructs the tree, if needed.

\-If gas particles are present, the density-\/loop for active \-S\-P\-H particles is carried out. \-This includes an iteration on the correct number of neighbours. \-Finally, the hydrodynamical forces are added. 

\-Definition at line 24 of file accel.\-c.



\-References \-All, density(), force\-\_\-update\-\_\-hmax(), gravity\-\_\-forcetest(), gravity\-\_\-tree(), hydro\-\_\-force(), long\-\_\-range\-\_\-force(), second(), \-This\-Task, and timediff().



\-Referenced by run().


\begin{DoxyCode}
{
  double tstart, tend;

  if(ThisTask == 0)
    {
      printf("Start force computation...\n");
      fflush(stdout);
    }

#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)
    {
      tstart = second();
      long_range_force();
      tend = second();
      All.CPU_PM += timediff(tstart, tend);
    }
#endif

  tstart = second();            /* measure the time for the full force
       computation */

  gravity_tree();               /* computes gravity accel. */

  if(All.TypeOfOpeningCriterion == 1 && All.Ti_Current == 0)
    gravity_tree();             /* For the first timestep, we redo it
                                 * to allow usage of relative opening
                                 * criterion for consistent accuracy.
                                 */
  tend = second();
  All.CPU_Gravity += timediff(tstart, tend);

#ifdef FORCETEST
  gravity_forcetest();
#endif

  if(All.TotN_gas > 0)
    {
      if(ThisTask == 0)
        {
          printf("Start density computation...\n");
          fflush(stdout);
        }

      tstart = second();
      density();                /* computes density, and pressure */
      tend = second();
      All.CPU_Hydro += timediff(tstart, tend);

      tstart = second();
      force_update_hmax();      /* tell the tree nodes the new SPH smoothing
       length such that they are guaranteed to hold the correct max(Hsml) */
      tend = second();
      All.CPU_Predict += timediff(tstart, tend);


      if(ThisTask == 0)
        {
          printf("Start hydro-force computation...\n");
          fflush(stdout);
        }

      tstart = second();
      hydro_force();            /* adds hydrodynamical accelerations and
       computes viscous entropy injection  */
      tend = second();
      All.CPU_Hydro += timediff(tstart, tend);
    }

  if(ThisTask == 0)
    {
      printf("force computation done.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a147f9422f4bca4666608da992486b417_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a147f9422f4bca4666608da992486b417_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1}{\index{proto.\-h@{proto.\-h}!compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system@{compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system}}
\index{compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system@{compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system}!proto.h@{proto.\-h}}
\subsubsection[{compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1}
\-This routine computes various global properties of the particle distribution and stores the result in the struct `\-Sys\-State'. \-Currently, not all the information that's computed here is actually used (e.\-g. momentum is not really used anywhere), just the energies are written to a log-\/file every once in a while. $<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 

\-Definition at line 22 of file global.\-c.



\-References \-All, get\-\_\-gravkick\-\_\-factor(), get\-\_\-hydrokick\-\_\-factor(), \-Num\-Part, \-P, pow(), \-Sph\-P, \-Sys\-State, and \-This\-Task.



\-Referenced by energy\-\_\-statistics().


\begin{DoxyCode}
{
  int i, j, n;
  struct state_of_system sys;
  double a1, a2, a3;
  double entr = 0, egyspec, vel[3];
  double dt_entr, dt_gravkick, dt_hydrokick;



  if(All.ComovingIntegrationOn)
    {
      a1 = All.Time;
      a2 = All.Time * All.Time;
      a3 = All.Time * All.Time * All.Time;
    }
  else
    {
      a1 = a2 = a3 = 1;
    }


  for(n = 0; n < 6; n++)
    {
      sys.MassComp[n] = sys.EnergyKinComp[n] = sys.EnergyPotComp[n] = sys.
      EnergyIntComp[n] = 0;

      for(j = 0; j < 4; j++)
        sys.CenterOfMassComp[n][j] = sys.MomentumComp[n][j] = sys.
      AngMomentumComp[n][j] = 0;
    }

  for(i = 0; i < NumPart; i++)
    {
      sys.MassComp[P[i].Type] += P[i].Mass;

      sys.EnergyPotComp[P[i].Type] += 0.5 * P[i].Mass * P[i].Potential / a1;

      if(All.ComovingIntegrationOn)
        {
          dt_entr = (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) 
      * All.Timebase_interval;
          dt_gravkick = get_gravkick_factor(P[i].Ti_begstep, All.Ti_Current) -
            get_gravkick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i].
      Ti_endstep) / 2);
          dt_hydrokick = get_hydrokick_factor(P[i].Ti_begstep, All.Ti_Current) 
      -
            get_hydrokick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i].
      Ti_endstep) / 2);
        }
      else
        dt_entr = dt_gravkick = dt_hydrokick =
          (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * All.
      Timebase_interval;

      for(j = 0; j < 3; j++)
        {
          vel[j] = P[i].Vel[j] + P[i].GravAccel[j] * dt_gravkick;
          if(P[i].Type == 0)
            vel[j] += SphP[i].HydroAccel[j] * dt_hydrokick;
        }
      if(P[i].Type == 0)
        entr = SphP[i].Entropy + SphP[i].DtEntropy * dt_entr;

#ifdef PMGRID
      if(All.ComovingIntegrationOn)
        dt_gravkick = get_gravkick_factor(All.PM_Ti_begstep, All.Ti_Current) -
          get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
      else
        dt_gravkick = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep)
       / 2) * All.Timebase_interval;

      for(j = 0; j < 3; j++)
        vel[j] += P[i].GravPM[j] * dt_gravkick;
#endif

      sys.EnergyKinComp[P[i].Type] +=
        0.5 * P[i].Mass * (vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2])
       / a2;

      if(P[i].Type == 0)
        {
#ifdef ISOTHERM_EQS
          egyspec = entr;
#else
          egyspec = entr / (GAMMA_MINUS1) * pow(SphP[i].Density / a3, 
      GAMMA_MINUS1);
#endif
          sys.EnergyIntComp[0] += P[i].Mass * egyspec;
        }



      for(j = 0; j < 3; j++)
        {
          sys.MomentumComp[P[i].Type][j] += P[i].Mass * vel[j];
          sys.CenterOfMassComp[P[i].Type][j] += P[i].Mass * P[i].Pos[j];
        }

      sys.AngMomentumComp[P[i].Type][0] += P[i].Mass * (P[i].Pos[1] * vel[2] - P
      [i].Pos[2] * vel[1]);
      sys.AngMomentumComp[P[i].Type][1] += P[i].Mass * (P[i].Pos[2] * vel[0] - P
      [i].Pos[0] * vel[2]);
      sys.AngMomentumComp[P[i].Type][2] += P[i].Mass * (P[i].Pos[0] * vel[1] - P
      [i].Pos[1] * vel[0]);
    }


  /* some the stuff over all processors */
  MPI_Reduce(&sys.MassComp[0], &SysState.MassComp[0], 6, MPI_DOUBLE, MPI_SUM, 0
      , MPI_COMM_WORLD);
  MPI_Reduce(&sys.EnergyPotComp[0], &SysState.EnergyPotComp[0], 6, MPI_DOUBLE, 
      MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&sys.EnergyIntComp[0], &SysState.EnergyIntComp[0], 6, MPI_DOUBLE, 
      MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&sys.EnergyKinComp[0], &SysState.EnergyKinComp[0], 6, MPI_DOUBLE, 
      MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&sys.MomentumComp[0][0], &SysState.MomentumComp[0][0], 6 * 4, 
      MPI_DOUBLE, MPI_SUM, 0,
             MPI_COMM_WORLD);
  MPI_Reduce(&sys.AngMomentumComp[0][0], &SysState.AngMomentumComp[0][0], 6 * 4
      , MPI_DOUBLE, MPI_SUM, 0,
             MPI_COMM_WORLD);
  MPI_Reduce(&sys.CenterOfMassComp[0][0], &SysState.CenterOfMassComp[0][0], 6 *
       4, MPI_DOUBLE, MPI_SUM, 0,
             MPI_COMM_WORLD);


  if(ThisTask == 0)
    {
      for(i = 0; i < 6; i++)
        SysState.EnergyTotComp[i] = SysState.EnergyKinComp[i] +
          SysState.EnergyPotComp[i] + SysState.EnergyIntComp[i];

      SysState.Mass = SysState.EnergyKin = SysState.EnergyPot = SysState.
      EnergyInt = SysState.EnergyTot = 0;

      for(j = 0; j < 3; j++)
        SysState.Momentum[j] = SysState.AngMomentum[j] = SysState.CenterOfMass[
      j] = 0;

      for(i = 0; i < 6; i++)
        {
          SysState.Mass += SysState.MassComp[i];
          SysState.EnergyKin += SysState.EnergyKinComp[i];
          SysState.EnergyPot += SysState.EnergyPotComp[i];
          SysState.EnergyInt += SysState.EnergyIntComp[i];
          SysState.EnergyTot += SysState.EnergyTotComp[i];

          for(j = 0; j < 3; j++)
            {
              SysState.Momentum[j] += SysState.MomentumComp[i][j];
              SysState.AngMomentum[j] += SysState.AngMomentumComp[i][j];
              SysState.CenterOfMass[j] += SysState.CenterOfMassComp[i][j];
            }
        }

      for(i = 0; i < 6; i++)
        for(j = 0; j < 3; j++)
          if(SysState.MassComp[i] > 0)
            SysState.CenterOfMassComp[i][j] /= SysState.MassComp[i];

      for(j = 0; j < 3; j++)
        if(SysState.Mass > 0)
          SysState.CenterOfMass[j] /= SysState.Mass;

      for(i = 0; i < 6; i++)
        {
          SysState.CenterOfMassComp[i][3] = SysState.MomentumComp[i][3] = 
      SysState.AngMomentumComp[i][3] = 0;
          for(j = 0; j < 3; j++)
            {
              SysState.CenterOfMassComp[i][3] +=
                SysState.CenterOfMassComp[i][j] * SysState.CenterOfMassComp[i][
      j];
              SysState.MomentumComp[i][3] += SysState.MomentumComp[i][j] * 
      SysState.MomentumComp[i][j];
              SysState.AngMomentumComp[i][3] +=
                SysState.AngMomentumComp[i][j] * SysState.AngMomentumComp[i][j]
      ;
            }
          SysState.CenterOfMassComp[i][3] = sqrt(SysState.CenterOfMassComp[i][3
      ]);
          SysState.MomentumComp[i][3] = sqrt(SysState.MomentumComp[i][3]);
          SysState.AngMomentumComp[i][3] = sqrt(SysState.AngMomentumComp[i][3])
      ;
        }

      SysState.CenterOfMass[3] = SysState.Momentum[3] = SysState.AngMomentum[3]
       = 0;

      for(j = 0; j < 3; j++)
        {
          SysState.CenterOfMass[3] += SysState.CenterOfMass[j] * SysState.
      CenterOfMass[j];
          SysState.Momentum[3] += SysState.Momentum[j] * SysState.Momentum[j];
          SysState.AngMomentum[3] += SysState.AngMomentum[j] * SysState.
      AngMomentum[j];
        }

      SysState.CenterOfMass[3] = sqrt(SysState.CenterOfMass[3]);
      SysState.Momentum[3] = sqrt(SysState.Momentum[3]);
      SysState.AngMomentum[3] = sqrt(SysState.AngMomentum[3]);
    }

  /* give everyone the result, maybe the want to do something with it */
  MPI_Bcast(&SysState, sizeof(struct state_of_system), MPI_BYTE, 0, 
      MPI_COMM_WORLD);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ada58109949c2431ca9b0cdaa01cfb5b1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a04474459731219f9601aaefedb37ab27}{\index{proto.\-h@{proto.\-h}!compute\-\_\-potential@{compute\-\_\-potential}}
\index{compute\-\_\-potential@{compute\-\_\-potential}!proto.h@{proto.\-h}}
\subsubsection[{compute\-\_\-potential}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf compute\-\_\-potential} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a04474459731219f9601aaefedb37ab27}
\-This function computes the gravitational potential for \-A\-L\-L the particles. \-First, the (short-\/range) tree potential is computed, and then, if needed, the long range \-P\-M potential is added. 

\-Definition at line 22 of file potential.\-c.



\-References \-All, endrun(), \-Exportflag, force\-\_\-treebuild(), force\-\_\-treeevaluate\-\_\-potential(), force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange(), grav\-\_\-tree\-\_\-compare\-\_\-key(), \-Grav\-Data\-Get, \-Grav\-Data\-In, \-Grav\-Data\-Index\-Table, \-Grav\-Data\-Out, \-Grav\-Data\-Result, \-N\-Task, \-Num\-Part, \-P, pm\-\_\-init\-\_\-regionsize(), pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel(), pmpotential\-\_\-nonperiodic(), pmpotential\-\_\-periodic(), pow(), \-P\-Task, second(), set\-\_\-softenings(), \-Sph\-P, \-T\-A\-G\-\_\-\-P\-O\-T\-E\-N\-T\-I\-A\-L\-\_\-\-A, \-T\-A\-G\-\_\-\-P\-O\-T\-E\-N\-T\-I\-A\-L\-\_\-\-B, \-This\-Task, timediff(), and \-Tree\-Reconstruct\-Flag.



\-Referenced by find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift(), and run().


\begin{DoxyCode}
{
  int i;

#ifndef NOGRAVITY
  long long ntot, ntotleft;
  int j, k, level, sendTask, recvTask;
  int ndone;
  int maxfill, ngrp, place, nexport;
  int *nsend, *noffset, *nsend_local, *nbuffer, *ndonelist, *numlist;
  double fac;
  double t0, t1, tstart, tend;
  MPI_Status status;
  double r2;

  t0 = second();

  if(All.ComovingIntegrationOn)
    set_softenings();

  if(ThisTask == 0)
    {
      printf("Start computation of potential for all particles...\n");
      fflush(stdout);
    }


  tstart = second();
  if(TreeReconstructFlag)
    {
      if(ThisTask == 0)
        printf("Tree construction.\n");

      force_treebuild(NumPart);

      TreeReconstructFlag = 0;

      if(ThisTask == 0)
        printf("Tree construction done.\n");
    }
  tend = second();
  All.CPU_TreeConstruction += timediff(tstart, tend);

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumPart, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);

  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common
       list */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  i = 0;                        /* beginn with this index */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      for(nexport = 0, ndone = 0; i < NumPart && nexport < All.BunchSizeForce -
       NTask; i++)
        {
          ndone++;

          for(j = 0; j < NTask; j++)
            Exportflag[j] = 0;

#ifndef PMGRID
          force_treeevaluate_potential(i, 0);
#else
          force_treeevaluate_potential_shortrange(i, 0);
#endif

          for(j = 0; j < NTask; j++)
            {
              if(Exportflag[j])
                {
                  for(k = 0; k < 3; k++)
                    GravDataGet[nexport].u.Pos[k] = P[i].Pos[k];
#ifdef UNEQUALSOFTENINGS
                  GravDataGet[nexport].Type = P[i].Type;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
                  if(P[i].Type == 0)
                    GravDataGet[nexport].Soft = SphP[i].Hsml;
#endif
#endif
                  GravDataGet[nexport].w.OldAcc = P[i].OldAcc;

                  GravDataIndexTable[nexport].Task = j;
                  GravDataIndexTable[nexport].Index = i;
                  GravDataIndexTable[nexport].SortIndex = nexport;

                  nexport++;
                  nsend_local[j]++;
                }
            }
        }

      qsort(GravDataIndexTable, nexport, sizeof(struct gravdata_index), 
      grav_tree_compare_key);

      for(j = 0; j < nexport; j++)
        GravDataIn[j] = GravDataGet[GravDataIndexTable[j].SortIndex];

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, 
      MPI_COMM_WORLD);

      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&GravDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in), MPI_BYTE,
                                   recvTask, TAG_POTENTIAL_A,
                                   &GravDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct gravdata_in), MPI_BYTE,
                                   recvTask, TAG_POTENTIAL_A, MPI_COMM_WORLD, &
      status);
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          for(j = 0; j < nbuffer[ThisTask]; j++)
            {
#ifndef PMGRID
              force_treeevaluate_potential(j, 1);
#else
              force_treeevaluate_potential_shortrange(j, 1);
#endif
            }


          /* get the result */
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&GravDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct gravdata_in),
                                   MPI_BYTE, recvTask, TAG_POTENTIAL_B,
                                   &GravDataOut[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in),
                                   MPI_BYTE, recvTask, TAG_POTENTIAL_B, 
      MPI_COMM_WORLD, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          place = GravDataIndexTable[noffset[recvTask] + j].
      Index;

                          P[place].Potential += GravDataOut[j + noffset[
      recvTask]].u.Potential;
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          level = ngrp - 1;
        }

      MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD);
      for(j = 0; j < NTask; j++)
        ntotleft -= ndonelist[j];
    }

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* add correction to exclude self-potential */

  for(i = 0; i < NumPart; i++)
    {
      /* remove self-potential */
      P[i].Potential += P[i].Mass / All.SofteningTable[P[i].Type];

      if(All.ComovingIntegrationOn)
        if(All.PeriodicBoundariesOn)
          P[i].Potential -= 2.8372975 * pow(P[i].Mass, 2.0 / 3) *
            pow(All.Omega0 * 3 * All.Hubble * All.Hubble / (8 * M_PI * All.G), 
      1.0 / 3);
    }


  /* multiply with the gravitational constant */

  for(i = 0; i < NumPart; i++)
    P[i].Potential *= All.G;


#ifdef PMGRID

#ifdef PERIODIC
  pmpotential_periodic();
#ifdef PLACEHIGHRESREGION
  i = pmpotential_nonperiodic(1);
  if(i == 1)  /* this is returned if a particle lied outside allowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmpotential_nonperiodic(1);   /* try again */
    }
  if(i == 1)
    endrun(88686);
#endif
#else
  i = pmpotential_nonperiodic(0);
  if(i == 1)                    /* this is returned if a particle lied outside
       allowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmpotential_nonperiodic(0);   /* try again */
    }
  if(i == 1)
    endrun(88687);
#ifdef PLACEHIGHRESREGION
  i = pmpotential_nonperiodic(1);
  if(i == 1)                    /* this is returned if a particle lied outside
       allowed range */
    {
      pm_init_regionsize();

      i = pmpotential_nonperiodic(1);
    }
  if(i != 0)
    endrun(88688);
#endif
#endif

#endif



  if(All.ComovingIntegrationOn)
    {
#ifndef PERIODIC
      fac = -0.5 * All.Omega0 * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        {
          for(k = 0, r2 = 0; k < 3; k++)
            r2 += P[i].Pos[k] * P[i].Pos[k];

          P[i].Potential += fac * r2;
        }
#endif
    }
  else
    {
      fac = -0.5 * All.OmegaLambda * All.Hubble * All.Hubble;
      if(fac != 0)
        {
          for(i = 0; i < NumPart; i++)
            {
              for(k = 0, r2 = 0; k < 3; k++)
                r2 += P[i].Pos[k] * P[i].Pos[k];

              P[i].Potential += fac * r2;
            }
        }
    }


  if(ThisTask == 0)
    {
      printf("potential done.\n");
      fflush(stdout);
    }

  t1 = second();

  All.CPU_Potential += timediff(t0, t1);

#else
  for(i = 0; i < NumPart; i++)
    P[i].Potential = 0;
#endif
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a04474459731219f9601aaefedb37ab27_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a04474459731219f9601aaefedb37ab27_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1}{\index{proto.\-h@{proto.\-h}!dens\-\_\-compare\-\_\-key@{dens\-\_\-compare\-\_\-key}}
\index{dens\-\_\-compare\-\_\-key@{dens\-\_\-compare\-\_\-key}!proto.h@{proto.\-h}}
\subsubsection[{dens\-\_\-compare\-\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf dens\-\_\-compare\-\_\-key} (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1}
\-This routine is a comparison kernel used in a sort routine to group particles that are exported to the same processor. 

\-Definition at line 607 of file density.\-c.



\-Referenced by density().


\begin{DoxyCode}
{
  if(((struct densdata_in *) a)->Task < (((struct densdata_in *) b)->Task))
    return -1;

  if(((struct densdata_in *) a)->Task > (((struct densdata_in *) b)->Task))
    return +1;

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab6453dd0ac2ecf2478b1208374e68ae1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c}{\index{proto.\-h@{proto.\-h}!density@{density}}
\index{density@{density}!proto.h@{proto.\-h}}
\subsubsection[{density}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf density} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c}
\-This function computes the local density for each active \-S\-P\-H particle, the number of neighbours in the current smoothing radius, and the divergence and curl of the velocity field. \-The pressure is updated as well. \-If a particle with its smoothing region is fully inside the local domain, it is not exported to the other processors. \-The function also detects particles that have a number of neighbours outside the allowed tolerance range. \-For these particles, the smoothing length is adjusted accordingly, and the density computation is executed again. \-Note that the smoothing length is not allowed to fall below the lower bound set by \-Min\-Gas\-Hsml. $<$ \-For 3\-D-\/normalized kernel

$<$ adiabatic index of simulated gas

$<$ maxmimum number of steps for \-S\-P\-H neighbour iteration

$<$ \-For 3\-D-\/normalized kernel

$<$ \-For 3\-D-\/normalized kernel

$<$ maxmimum number of steps for \-S\-P\-H neighbour iteration 

\-Definition at line 56 of file density.\-c.



\-References \-All, box\-Half, box\-Half\-\_\-\-X, box\-Half\-\_\-\-Y, box\-Half\-\_\-\-Z, box\-Size, box\-Size\-\_\-\-X, box\-Size\-\_\-\-Y, box\-Size\-\_\-\-Z, dens\-\_\-compare\-\_\-key(), \-Dens\-Data\-Get, \-Dens\-Data\-In, \-Dens\-Data\-Partial\-Result, \-Dens\-Data\-Result, density\-\_\-evaluate(), dmax(), endrun(), \-Exportflag, \-N\-\_\-gas, \-N\-Task, \-Num\-Part, \-Num\-Sph\-Update, \-P, pow(), \-P\-Task, second(), \-Sph\-P, \-T\-A\-G\-\_\-\-D\-E\-N\-S\-\_\-\-A, \-T\-A\-G\-\_\-\-D\-E\-N\-S\-\_\-\-B, \-This\-Task, and timediff().



\-Referenced by compute\-\_\-accelerations(), and setup\-\_\-smoothinglengths().


\begin{DoxyCode}
{
  long long ntot, ntotleft;
  int *noffset, *nbuffer, *nsend, *nsend_local, *numlist, *ndonelist;
  int i, j, n, ndone, npleft, maxfill, source, iter = 0;
  int level, ngrp, sendTask, recvTask, place, nexport;
  double dt_entr, tstart, tend, tstart_ngb = 0, tend_ngb = 0;
  double sumt, sumcomm, timengb, sumtimengb;
  double timecomp = 0, timeimbalance = 0, timecommsumm = 0, sumimbalance;
  MPI_Status status;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif


  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common
       list */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  for(n = 0, NumSphUpdate = 0; n < N_gas; n++)
    {
      SphP[n].Left = SphP[n].Right = 0;

      if(P[n].Ti_endstep == All.Ti_Current)
        NumSphUpdate++;
    }

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumSphUpdate, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD)
      ;
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);



  /* we will repeat the whole thing for those particles where we didn't
   * find enough neighbours
   */
  do
    {
      i = 0;                    /* beginn with this index */
      ntotleft = ntot;          /* particles left for all tasks together */

      while(ntotleft > 0)
        {
          for(j = 0; j < NTask; j++)
            nsend_local[j] = 0;

          /* do local particles and prepare export list */
          tstart = second();
          for(nexport = 0, ndone = 0; i < N_gas && nexport < All.
      BunchSizeDensity - NTask; i++)
            if(P[i].Ti_endstep == All.Ti_Current)
              {
                ndone++;

                for(j = 0; j < NTask; j++)
                  Exportflag[j] = 0;

                density_evaluate(i, 0);

                for(j = 0; j < NTask; j++)
                  {
                    if(Exportflag[j])
                      {
                        DensDataIn[nexport].Pos[0] = P[i].Pos[0];
                        DensDataIn[nexport].Pos[1] = P[i].Pos[1];
                        DensDataIn[nexport].Pos[2] = P[i].Pos[2];
                        DensDataIn[nexport].Vel[0] = SphP[i].VelPred[0];
                        DensDataIn[nexport].Vel[1] = SphP[i].VelPred[1];
                        DensDataIn[nexport].Vel[2] = SphP[i].VelPred[2];
                        DensDataIn[nexport].Hsml = SphP[i].Hsml;
                        DensDataIn[nexport].Index = i;
                        DensDataIn[nexport].Task = j;
                        nexport++;
                        nsend_local[j]++;
                      }
                  }
              }
          tend = second();
          timecomp += timediff(tstart, tend);

          qsort(DensDataIn, nexport, sizeof(struct densdata_in), 
      dens_compare_key);

          for(j = 1, noffset[0] = 0; j < NTask; j++)
            noffset[j] = noffset[j - 1] + nsend_local[j - 1];

          tstart = second();

          MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, 
      MPI_COMM_WORLD);

          tend = second();
          timeimbalance += timediff(tstart, tend);


          /* now do the particles that need to be exported */

          for(level = 1; level < (1 << PTask); level++)
            {
              tstart = second();
              for(j = 0; j < NTask; j++)
                nbuffer[j] = 0;
              for(ngrp = level; ngrp < (1 << PTask); ngrp++)
                {
                  maxfill = 0;
                  for(j = 0; j < NTask; j++)
                    {
                      if((j ^ ngrp) < NTask)
                        if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j]
      )
                          maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                    }
                  if(maxfill >= All.BunchSizeDensity)
                    break;

                  sendTask = ThisTask;
                  recvTask = ThisTask ^ ngrp;

                  if(recvTask < NTask)
                    {
                      if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[
      recvTask * NTask + ThisTask] > 0)
                        {
                          /* get the particles */
                          MPI_Sendrecv(&DensDataIn[noffset[recvTask]],
                                       nsend_local[recvTask] * sizeof(struct 
      densdata_in), MPI_BYTE,
                                       recvTask, TAG_DENS_A,
                                       &DensDataGet[nbuffer[ThisTask]],
                                       nsend[recvTask * NTask + ThisTask] * 
      sizeof(struct densdata_in),
                                       MPI_BYTE, recvTask, TAG_DENS_A, 
      MPI_COMM_WORLD, &status);
                        }
                    }

                  for(j = 0; j < NTask; j++)
                    if((j ^ ngrp) < NTask)
                      nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
                }
              tend = second();
              timecommsumm += timediff(tstart, tend);


              tstart = second();
              for(j = 0; j < nbuffer[ThisTask]; j++)
                density_evaluate(j, 1);
              tend = second();
              timecomp += timediff(tstart, tend);

              /* do a block to explicitly measure imbalance */
              tstart = second();
              MPI_Barrier(MPI_COMM_WORLD);
              tend = second();
              timeimbalance += timediff(tstart, tend);

              /* get the result */
              tstart = second();
              for(j = 0; j < NTask; j++)
                nbuffer[j] = 0;
              for(ngrp = level; ngrp < (1 << PTask); ngrp++)
                {
                  maxfill = 0;
                  for(j = 0; j < NTask; j++)
                    {
                      if((j ^ ngrp) < NTask)
                        if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j]
      )
                          maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                    }
                  if(maxfill >= All.BunchSizeDensity)
                    break;

                  sendTask = ThisTask;
                  recvTask = ThisTask ^ ngrp;

                  if(recvTask < NTask)
                    {
                      if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[
      recvTask * NTask + ThisTask] > 0)
                        {
                          /* send the results */
                          MPI_Sendrecv(&DensDataResult[nbuffer[ThisTask]],
                                       nsend[recvTask * NTask + ThisTask] * 
      sizeof(struct densdata_out),
                                       MPI_BYTE, recvTask, TAG_DENS_B,
                                       &DensDataPartialResult[noffset[recvTask]
      ],
                                       nsend_local[recvTask] * sizeof(struct 
      densdata_out),
                                       MPI_BYTE, recvTask, TAG_DENS_B, 
      MPI_COMM_WORLD, &status);

                          /* add the result to the particles */
                          for(j = 0; j < nsend_local[recvTask]; j++)
                            {
                              source = j + noffset[recvTask];
                              place = DensDataIn[source].Index;

                              SphP[place].NumNgb += DensDataPartialResult[
      source].Ngb;
                              SphP[place].Density += DensDataPartialResult[
      source].Rho;
                              SphP[place].DivVel += DensDataPartialResult[
      source].Div;

                              SphP[place].DhsmlDensityFactor += 
      DensDataPartialResult[source].DhsmlDensity;

                              SphP[place].Rot[0] += DensDataPartialResult[
      source].Rot[0];
                              SphP[place].Rot[1] += DensDataPartialResult[
      source].Rot[1];
                              SphP[place].Rot[2] += DensDataPartialResult[
      source].Rot[2];
                            }
                        }
                    }

                  for(j = 0; j < NTask; j++)
                    if((j ^ ngrp) < NTask)
                      nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
                }
              tend = second();
              timecommsumm += timediff(tstart, tend);

              level = ngrp - 1;
            }

          MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, 
      MPI_COMM_WORLD);
          for(j = 0; j < NTask; j++)
            ntotleft -= ndonelist[j];
        }



      /* do final operations on results */
      tstart = second();
      for(i = 0, npleft = 0; i < N_gas; i++)
        {
          if(P[i].Ti_endstep == All.Ti_Current)
            {
              {
                SphP[i].DhsmlDensityFactor =
                  1 / (1 + SphP[i].Hsml * SphP[i].DhsmlDensityFactor / (NUMDIMS
       * SphP[i].Density));

                SphP[i].CurlVel = sqrt(SphP[i].Rot[0] * SphP[i].Rot[0] +
                                       SphP[i].Rot[1] * SphP[i].Rot[1] +
                                       SphP[i].Rot[2] * SphP[i].Rot[2]) / SphP[
      i].Density;

                SphP[i].DivVel /= SphP[i].Density;

                dt_entr = (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep)
       / 2) * All.Timebase_interval;

                SphP[i].Pressure =
                  (SphP[i].Entropy + SphP[i].DtEntropy * dt_entr) * pow(SphP[i]
      .Density, GAMMA);
              }


              /* now check whether we had enough neighbours */

              if(SphP[i].NumNgb < (All.DesNumNgb - All.MaxNumNgbDeviation) ||
                 (SphP[i].NumNgb > (All.DesNumNgb + All.MaxNumNgbDeviation)
                  && SphP[i].Hsml > (1.01 * All.MinGasHsml)))
                {
                  /* need to redo this particle */
                  npleft++;

                  if(SphP[i].Left > 0 && SphP[i].Right > 0)
                    if((SphP[i].Right - SphP[i].Left) < 1.0e-3 * SphP[i].Left)
                      {
                        /* this one should be ok */
                        npleft--;
                        P[i].Ti_endstep = -P[i].Ti_endstep - 1; /* Mark as
       inactive */
                        continue;
                      }

                  if(SphP[i].NumNgb < (All.DesNumNgb - All.MaxNumNgbDeviation))
                    SphP[i].Left = dmax(SphP[i].Hsml, SphP[i].Left);
                  else
                    {
                      if(SphP[i].Right != 0)
                        {
                          if(SphP[i].Hsml < SphP[i].Right)
                            SphP[i].Right = SphP[i].Hsml;
                        }
                      else
                        SphP[i].Right = SphP[i].Hsml;
                    }

                  if(iter >= MAXITER - 10)
                    {
                      printf
                        ("i=%d task=%d ID=%d Hsml=%g Left=%g Right=%g Ngbs=%g
       Right-Left=%g\n   pos=(%g|%g|%g)\n",
                         i, ThisTask, (int) P[i].ID, SphP[i].Hsml, SphP[i].Left
      , SphP[i].Right,
                         (float) SphP[i].NumNgb, SphP[i].Right - SphP[i].Left, P
      [i].Pos[0], P[i].Pos[1],
                         P[i].Pos[2]);
                      fflush(stdout);
                    }

                  if(SphP[i].Right > 0 && SphP[i].Left > 0)
                    SphP[i].Hsml = pow(0.5 * (pow(SphP[i].Left, 3) + pow(SphP[i
      ].Right, 3)), 1.0 / 3);
                  else
                    {
                      if(SphP[i].Right == 0 && SphP[i].Left == 0)
                        endrun(8188);   /* can't occur */

                      if(SphP[i].Right == 0 && SphP[i].Left > 0)
                        {
                          if(P[i].Type == 0 && fabs(SphP[i].NumNgb - All.
      DesNumNgb) < 0.5 * All.DesNumNgb)
                            {
                              SphP[i].Hsml *=
                                1 - (SphP[i].NumNgb -
                                     All.DesNumNgb) / (NUMDIMS * SphP[i].NumNgb
      ) * SphP[i].DhsmlDensityFactor;
                            }
                          else
                            SphP[i].Hsml *= 1.26;
                        }

                      if(SphP[i].Right > 0 && SphP[i].Left == 0)
                        {
                          if(P[i].Type == 0 && fabs(SphP[i].NumNgb - All.
      DesNumNgb) < 0.5 * All.DesNumNgb)
                            {
                              SphP[i].Hsml *=
                                1 - (SphP[i].NumNgb -
                                     All.DesNumNgb) / (NUMDIMS * SphP[i].NumNgb
      ) * SphP[i].DhsmlDensityFactor;
                            }
                          else
                            SphP[i].Hsml /= 1.26;
                        }
                    }

                  if(SphP[i].Hsml < All.MinGasHsml)
                    SphP[i].Hsml = All.MinGasHsml;
                }
              else
                P[i].Ti_endstep = -P[i].Ti_endstep - 1; /* Mark as inactive */
            }
        }
      tend = second();
      timecomp += timediff(tstart, tend);


      numlist = malloc(NTask * sizeof(int) * NTask);
      MPI_Allgather(&npleft, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
      for(i = 0, ntot = 0; i < NTask; i++)
        ntot += numlist[i];
      free(numlist);

      if(ntot > 0)
        {
          if(iter == 0)
            tstart_ngb = second();

          iter++;

          if(iter > 0 && ThisTask == 0)
            {
              printf("ngb iteration %d: need to repeat for %d%09d particles.\n"
      , iter,
                     (int) (ntot / 1000000000), (int) (ntot % 1000000000));
              fflush(stdout);
            }

          if(iter > MAXITER)
            {
              printf("failed to converge in neighbour iteration in density()\n"
      );
              fflush(stdout);
              endrun(1155);
            }
        }
      else
        tend_ngb = second();
    }
  while(ntot > 0);


  /* mark as active again */
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* collect some timing information */
  if(iter > 0)
    timengb = timediff(tstart_ngb, tend_ngb);
  else
    timengb = 0;

  MPI_Reduce(&timengb, &sumtimengb, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecomp, &sumt, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecommsumm, &sumcomm, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD
      );
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, 
      MPI_COMM_WORLD);

  if(ThisTask == 0)
    {
      All.CPU_HydCompWalk += sumt / NTask;
      All.CPU_HydCommSumm += sumcomm / NTask;
      All.CPU_HydImbalance += sumimbalance / NTask;
      All.CPU_EnsureNgb += sumtimengb / NTask;
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad86cdeb9e3bfbe9af379ac9f7daf194c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aaeec847fb319935d1a6e765ffbb9c6d9}{\index{proto.\-h@{proto.\-h}!density\-\_\-decouple@{density\-\_\-decouple}}
\index{density\-\_\-decouple@{density\-\_\-decouple}!proto.h@{proto.\-h}}
\subsubsection[{density\-\_\-decouple}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf density\-\_\-decouple} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aaeec847fb319935d1a6e765ffbb9c6d9}
\hypertarget{proto_8h_a19f7a07621c698ae894f53836e9ff03c}{\index{proto.\-h@{proto.\-h}!density\-\_\-evaluate@{density\-\_\-evaluate}}
\index{density\-\_\-evaluate@{density\-\_\-evaluate}!proto.h@{proto.\-h}}
\subsubsection[{density\-\_\-evaluate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf density\-\_\-evaluate} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a19f7a07621c698ae894f53836e9ff03c}
\-This function represents the core of the \-S\-P\-H density computation. \-The target particle may either be local, or reside in the communication buffer. $<$ \-Coefficients for \-S\-P\-H spline kernel and its derivative

$<$ \-Coefficient for kernel normalization. \-Note\-: 4.\-0/3 $\ast$ \-P\-I = 4.\-188790204786

$<$ \-For 3\-D-\/normalized kernel 

\-Definition at line 467 of file density.\-c.



\-References \-All, box\-Half\-\_\-\-X, box\-Half\-\_\-\-Y, box\-Half\-\_\-\-Z, box\-Size\-\_\-\-X, box\-Size\-\_\-\-Y, box\-Size\-\_\-\-Z, \-Dens\-Data\-Get, \-Dens\-Data\-Result, ngb\-\_\-treefind\-\_\-variable(), \-Ngblist, \-P, and \-Sph\-P.



\-Referenced by density().


\begin{DoxyCode}
{
  int j, n, startnode, numngb, numngb_inbox;
  double h, h2, fac, hinv, hinv3, hinv4;
  double rho, divv, wk, dwk;
  double dx, dy, dz, r, r2, u, mass_j;
  double dvx, dvy, dvz, rotv[3];
  double weighted_numngb, dhsmlrho;
  FLOAT *pos, *vel;

  if(mode == 0)
    {
      pos = P[target].Pos;
      vel = SphP[target].VelPred;
      h = SphP[target].Hsml;
    }
  else
    {
      pos = DensDataGet[target].Pos;
      vel = DensDataGet[target].Vel;
      h = DensDataGet[target].Hsml;
    }

  h2 = h * h;
  hinv = 1.0 / h;
#ifndef  TWODIMS
  hinv3 = hinv * hinv * hinv;
#else
  hinv3 = hinv * hinv / boxSize_Z;
#endif
  hinv4 = hinv3 * hinv;

  rho = divv = rotv[0] = rotv[1] = rotv[2] = 0;
  weighted_numngb = 0;
  dhsmlrho = 0;

  startnode = All.MaxPart;
  numngb = 0;
  do
    {
      numngb_inbox = ngb_treefind_variable(&pos[0], h, &startnode);

      for(n = 0; n < numngb_inbox; n++)
        {
          j = Ngblist[n];

          dx = pos[0] - P[j].Pos[0];
          dy = pos[1] - P[j].Pos[1];
          dz = pos[2] - P[j].Pos[2];

#ifdef PERIODIC                 /*  now find the closest image in the given box
       size  */
          if(dx > boxHalf_X)
            dx -= boxSize_X;
          if(dx < -boxHalf_X)
            dx += boxSize_X;
          if(dy > boxHalf_Y)
            dy -= boxSize_Y;
          if(dy < -boxHalf_Y)
            dy += boxSize_Y;
          if(dz > boxHalf_Z)
            dz -= boxSize_Z;
          if(dz < -boxHalf_Z)
            dz += boxSize_Z;
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          if(r2 < h2)
            {
              numngb++;

              r = sqrt(r2);

              u = r * hinv;

              if(u < 0.5)
                {
                  wk = hinv3 * (KERNEL_COEFF_1 + KERNEL_COEFF_2 * (u - 1) * u *
       u);
                  dwk = hinv4 * u * (KERNEL_COEFF_3 * u - KERNEL_COEFF_4);
                }
              else
                {
                  wk = hinv3 * KERNEL_COEFF_5 * (1.0 - u) * (1.0 - u) * (1.0 - 
      u);
                  dwk = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                }

              mass_j = P[j].Mass;

              rho += mass_j * wk;

              weighted_numngb += NORM_COEFF * wk / hinv3;

              dhsmlrho += -mass_j * (NUMDIMS * hinv * wk + u * dwk);

              if(r > 0)
                {
                  fac = mass_j * dwk / r;

                  dvx = vel[0] - SphP[j].VelPred[0];
                  dvy = vel[1] - SphP[j].VelPred[1];
                  dvz = vel[2] - SphP[j].VelPred[2];

                  divv -= fac * (dx * dvx + dy * dvy + dz * dvz);

                  rotv[0] += fac * (dz * dvy - dy * dvz);
                  rotv[1] += fac * (dx * dvz - dz * dvx);
                  rotv[2] += fac * (dy * dvx - dx * dvy);
                }
            }
        }
    }
  while(startnode >= 0);

  if(mode == 0)
    {
      SphP[target].NumNgb = weighted_numngb;
      SphP[target].Density = rho;
      SphP[target].DivVel = divv;
      SphP[target].DhsmlDensityFactor = dhsmlrho;
      SphP[target].Rot[0] = rotv[0];
      SphP[target].Rot[1] = rotv[1];
      SphP[target].Rot[2] = rotv[2];
    }
  else
    {
      DensDataResult[target].Rho = rho;
      DensDataResult[target].Div = divv;
      DensDataResult[target].Ngb = weighted_numngb;
      DensDataResult[target].DhsmlDensity = dhsmlrho;
      DensDataResult[target].Rot[0] = rotv[0];
      DensDataResult[target].Rot[1] = rotv[1];
      DensDataResult[target].Rot[2] = rotv[2];
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a19f7a07621c698ae894f53836e9ff03c_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a19f7a07621c698ae894f53836e9ff03c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab}{\index{proto.\-h@{proto.\-h}!distribute\-\_\-file@{distribute\-\_\-file}}
\index{distribute\-\_\-file@{distribute\-\_\-file}!proto.h@{proto.\-h}}
\subsubsection[{distribute\-\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf distribute\-\_\-file} (
\begin{DoxyParamCaption}
\item[{int}]{nfiles, }
\item[{int}]{firstfile, }
\item[{int}]{firsttask, }
\item[{int}]{lasttask, }
\item[{int $\ast$}]{filenr, }
\item[{int $\ast$}]{master, }
\item[{int $\ast$}]{last}
\end{DoxyParamCaption}
)}}\label{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab}
\-This function assigns a certain number of files to processors, such that each processor is exactly assigned to one file, and the number of cpus per file is as homogenous as possible. \-The number of files may at most be equal to the number of processors. 

\-Definition at line 724 of file read\-\_\-ic.\-c.



\-References distribute\-\_\-file(), and \-This\-Task.



\-Referenced by distribute\-\_\-file(), read\-\_\-ic(), and savepositions().


\begin{DoxyCode}
{
  int ntask, filesleft, filesright, tasksleft, tasksright;

  if(nfiles > 1)
    {
      ntask = lasttask - firsttask + 1;

      filesleft = (((double) (ntask / 2)) / ntask) * nfiles;
      if(filesleft <= 0)
        filesleft = 1;
      if(filesleft >= nfiles)
        filesleft = nfiles - 1;

      filesright = nfiles - filesleft;

      tasksleft = ntask / 2;
      tasksright = ntask - tasksleft;

      distribute_file(filesleft, firstfile, firsttask, firsttask + tasksleft - 
      1, filenr, master, last);
      distribute_file(filesright, firstfile + filesleft, firsttask + tasksleft,
       lasttask, filenr, master,
                      last);
    }
  else
    {
      if(ThisTask >= firsttask && ThisTask <= lasttask)
        {
          *filenr = firstfile;
          *master = firsttask;
          *last = lasttask;
        }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=160pt]{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_abf75a70e8719e8ed6de565a6ae90f1ab_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac5e72d197cde6d71017e89db9b986b85}{\index{proto.\-h@{proto.\-h}!dmax@{dmax}}
\index{dmax@{dmax}!proto.h@{proto.\-h}}
\subsubsection[{dmax}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf dmax} (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{double}]{y}
\end{DoxyParamCaption}
)}}\label{proto_8h_ac5e72d197cde6d71017e89db9b986b85}
returns the maximum of two double 

\-Definition at line 91 of file system.\-c.



\-Referenced by density(), domain\-\_\-find\-Split(), domain\-\_\-shift\-Split(), fill\-\_\-write\-\_\-buffer(), force\-\_\-treeevaluate\-\_\-direct(), and read\-\_\-ic().


\begin{DoxyCode}
{
  if(x > y)
    return x;
  else
    return y;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac5e72d197cde6d71017e89db9b986b85_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a128779c23a7c6e9cca2374c5e7c91483}{\index{proto.\-h@{proto.\-h}!dmin@{dmin}}
\index{dmin@{dmin}!proto.h@{proto.\-h}}
\subsubsection[{dmin}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf dmin} (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{double}]{y}
\end{DoxyParamCaption}
)}}\label{proto_8h_a128779c23a7c6e9cca2374c5e7c91483}
returns the minimum of two double 

\-Definition at line 101 of file system.\-c.



\-Referenced by hydro\-\_\-evaluate().


\begin{DoxyCode}
{
  if(x < y)
    return x;
  else
    return y;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a128779c23a7c6e9cca2374c5e7c91483_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_adda9e167a16a53d1aa40180406950446}{\index{proto.\-h@{proto.\-h}!do\-\_\-box\-\_\-wrapping@{do\-\_\-box\-\_\-wrapping}}
\index{do\-\_\-box\-\_\-wrapping@{do\-\_\-box\-\_\-wrapping}!proto.h@{proto.\-h}}
\subsubsection[{do\-\_\-box\-\_\-wrapping}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf do\-\_\-box\-\_\-wrapping} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_adda9e167a16a53d1aa40180406950446}
\-This function makes sure that all particle coordinates (\-Pos) are periodically mapped onto the interval \mbox{[}0, \-Box\-Size\mbox{]}. \-After this function has been called, a new domain decomposition should be done, which will also force a new tree construction. 

\-Definition at line 103 of file predict.\-c.



\-References \-All, \-Num\-Part, and \-P.



\-Referenced by domain\-\_\-\-Decomposition().


\begin{DoxyCode}
{
  int i, j;
  double boxsize[3];

  for(j = 0; j < 3; j++)
    boxsize[j] = All.BoxSize;

#ifdef LONG_X
  boxsize[0] *= LONG_X;
#endif
#ifdef LONG_Y
  boxsize[1] *= LONG_Y;
#endif
#ifdef LONG_Z
  boxsize[2] *= LONG_Z;
#endif

  for(i = 0; i < NumPart; i++)
    for(j = 0; j < 3; j++)
      {
        while(P[i].Pos[j] < 0)
          P[i].Pos[j] += boxsize[j];

        while(P[i].Pos[j] >= boxsize[j])
          P[i].Pos[j] -= boxsize[j];
      }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_adda9e167a16a53d1aa40180406950446_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5b596de46669fab5e125f163d44edc37}{\index{proto.\-h@{proto.\-h}!domain\-\_\-compare\-\_\-key@{domain\-\_\-compare\-\_\-key}}
\index{domain\-\_\-compare\-\_\-key@{domain\-\_\-compare\-\_\-key}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-compare\-\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf domain\-\_\-compare\-\_\-key} (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{proto_8h_a5b596de46669fab5e125f163d44edc37}
\-This is a comparison kernel used in a sort routine. 

\-Definition at line 1119 of file domain.\-c.



\-Referenced by domain\-\_\-determine\-Top\-Tree().


\begin{DoxyCode}
{
  if(*(peanokey *) a < *(peanokey *) b)
    return -1;

  if(*(peanokey *) a > *(peanokey *) b)
    return +1;

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5b596de46669fab5e125f163d44edc37_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a381621bc90438c5a50826bfdac8e4700}{\index{proto.\-h@{proto.\-h}!domain\-\_\-compare\-\_\-toplist@{domain\-\_\-compare\-\_\-toplist}}
\index{domain\-\_\-compare\-\_\-toplist@{domain\-\_\-compare\-\_\-toplist}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-compare\-\_\-toplist}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf domain\-\_\-compare\-\_\-toplist} (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{proto_8h_a381621bc90438c5a50826bfdac8e4700}
\-This is a comparison kernel used in a sort routine. 

\-Definition at line 1106 of file domain.\-c.



\-References topnode\-\_\-exchange\-::\-Startkey.



\-Referenced by domain\-\_\-determine\-Top\-Tree().


\begin{DoxyCode}
{
  if(((struct topnode_exchange *) a)->Startkey < (((struct topnode_exchange *) 
      b)->Startkey))
    return -1;

  if(((struct topnode_exchange *) a)->Startkey > (((struct topnode_exchange *) 
      b)->Startkey))
    return +1;

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a381621bc90438c5a50826bfdac8e4700_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a77c115c3aa2069d0eb8521329be0483c}{\index{proto.\-h@{proto.\-h}!domain\-\_\-count\-To\-Go@{domain\-\_\-count\-To\-Go}}
\index{domain\-\_\-count\-To\-Go@{domain\-\_\-count\-To\-Go}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-count\-To\-Go}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-count\-To\-Go} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a77c115c3aa2069d0eb8521329be0483c}
\-This function determines how many particles that are currently stored on the local \-C\-P\-U have to be moved off according to the domain decomposition. 

\-Definition at line 729 of file domain.\-c.



\-References \-Domain\-Task, \-Key, local\-\_\-to\-Go, local\-\_\-to\-Go\-Sph, \-N\-Task, \-Num\-Part, \-P, \-This\-Task, to\-Go, to\-Go\-Sph, and \-Top\-Nodes.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int n, no;

  for(n = 0; n < NTask; n++)
    {
      local_toGo[n] = 0;
      local_toGoSph[n] = 0;
    }

  for(n = 0; n < NumPart; n++)
    {
      no = 0;

      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (Key[n] - TopNodes[no].StartKey) / (
      TopNodes[no].Size / 8);

      no = TopNodes[no].Leaf;

      if(DomainTask[no] != ThisTask)
        {
          local_toGo[DomainTask[no]] += 1;
          if(P[n].Type == 0)
            local_toGoSph[DomainTask[no]] += 1;
        }
    }

  MPI_Allgather(local_toGo, NTask, MPI_INT, toGo, NTask, MPI_INT, 
      MPI_COMM_WORLD);
  MPI_Allgather(local_toGoSph, NTask, MPI_INT, toGoSph, NTask, MPI_INT, 
      MPI_COMM_WORLD);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a77c115c3aa2069d0eb8521329be0483c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a647e0c1a76b7f064ed5d201662f364bf}{\index{proto.\-h@{proto.\-h}!domain\-\_\-decompose@{domain\-\_\-decompose}}
\index{domain\-\_\-decompose@{domain\-\_\-decompose}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-decompose}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-decompose} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a647e0c1a76b7f064ed5d201662f364bf}
\-This function carries out the actual domain decomposition for all particle types. \-It will try to balance the work-\/load for each domain, as estimated based on the \-P\mbox{[}i\mbox{]}-\/\-Grav\-Cost values. \-The decomposition will respect the maximum allowed memory-\/imbalance given by the value of \-Part\-Alloc\-Factor. 

\-Definition at line 154 of file domain.\-c.



\-References \-All, domain\-\_\-count\-To\-Go(), domain\-\_\-determine\-Top\-Tree(), domain\-\_\-exchange\-Particles(), domain\-\_\-find\-Exchange\-Numbers(), domain\-\_\-find\-Extent(), domain\-\_\-find\-Split(), domain\-\_\-shift\-Split(), domain\-\_\-sum\-Cost(), \-Domain\-End\-List, \-Domain\-My\-Last, \-Domain\-My\-Start, \-Domain\-Start\-List, endrun(), list\-\_\-load, list\-\_\-\-N\-\_\-gas, list\-\_\-\-Num\-Part, list\-\_\-work, maxload, \-N\-Task, \-N\-Topleaves, \-Ntype, \-Ntype\-Local, \-Num\-Part, \-P, \-P\-Task, \-This\-Task, to\-Go, and to\-Go\-Sph.



\-Referenced by domain\-\_\-\-Decomposition().


\begin{DoxyCode}
{
  int i, j, status;
  int ngrp, task, partner, sendcount, recvcount;
  long long sumtogo, sumload;
  int maxload, *temp;
  double sumwork, maxwork;

  for(i = 0; i < 6; i++)
    NtypeLocal[i] = 0;

  for(i = 0; i < NumPart; i++)
    NtypeLocal[P[i].Type]++;

  /* because Ntype[] is of type `long long', we cannot do a simple
   * MPI_Allreduce() to sum the total particle numbers 
   */
  temp = malloc(NTask * 6 * sizeof(int));
  MPI_Allgather(NtypeLocal, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
  for(i = 0; i < 6; i++)
    {
      Ntype[i] = 0;
      for(j = 0; j < NTask; j++)
        Ntype[i] += temp[j * 6 + i];
    }
  free(temp);

#ifndef UNEQUALSOFTENINGS
  for(i = 0; i < 6; i++)
    if(Ntype[i] > 0)
      break;

  for(ngrp = i + 1; ngrp < 6; ngrp++)
    {
      if(Ntype[ngrp] > 0)
        if(All.SofteningTable[ngrp] != All.SofteningTable[i])
          {
            if(ThisTask == 0)
              {
                fprintf(stdout, "Code was not compiled with UNEQUALSOFTENINGS,
       but some of the\n");
                fprintf(stdout, "softening lengths are unequal nevertheless.\n"
      );
                fprintf(stdout, "This is not allowed.\n");
              }
            endrun(0);
          }
    }
#endif


  /* determine global dimensions of domain grid */
  domain_findExtent();

  domain_determineTopTree();

  /* determine cost distribution in domain grid */
  domain_sumCost();

  /* find the split of the domain grid recursively */
  status = domain_findSplit(0, NTask, 0, NTopleaves - 1);
  if(status != 0)
    {
      if(ThisTask == 0)
        printf("\nNo domain decomposition that stays within memory bounds is
       possible.\n");
      endrun(0);
    }

  /* now try to improve the work-load balance of the split */
  domain_shiftSplit();

  DomainMyStart = DomainStartList[ThisTask];
  DomainMyLast = DomainEndList[ThisTask];

  if(ThisTask == 0)
    {
      sumload = maxload = 0;
      sumwork = maxwork = 0;
      for(i = 0; i < NTask; i++)
        {
          sumload += list_load[i];
          sumwork += list_work[i];

          if(list_load[i] > maxload)
            maxload = list_load[i];

          if(list_work[i] > maxwork)
            maxwork = list_work[i];
        }

      printf("work-load balance=%g   memory-balance=%g\n",
             maxwork / (sumwork / NTask), maxload / (((double) sumload) / NTask
      ));
    }


  /* determine for each cpu how many particles have to be shifted to other cpus
       */
  domain_countToGo();

  for(i = 0, sumtogo = 0; i < NTask * NTask; i++)
    sumtogo += toGo[i];

  while(sumtogo > 0)
    {
      if(ThisTask == 0)
        {
          printf("exchange of %d%09d particles\n", (int) (sumtogo / 1000000000)
      ,
                 (int) (sumtogo % 1000000000));
          fflush(stdout);
        }

      for(ngrp = 1; ngrp < (1 << PTask); ngrp++)
        {
          for(task = 0; task < NTask; task++)
            {
              partner = task ^ ngrp;

              if(partner < NTask && task < partner)
                {
                  /* treat SPH separately */
                  if(All.TotN_gas > 0)
                    {
                      domain_findExchangeNumbers(task, partner, 1, &sendcount, 
      &recvcount);

                      list_NumPart[task] += recvcount - sendcount;
                      list_NumPart[partner] -= recvcount - sendcount;
                      list_N_gas[task] += recvcount - sendcount;
                      list_N_gas[partner] -= recvcount - sendcount;

                      toGo[task * NTask + partner] -= sendcount;
                      toGo[partner * NTask + task] -= recvcount;
                      toGoSph[task * NTask + partner] -= sendcount;
                      toGoSph[partner * NTask + task] -= recvcount;

                      if(task == ThisTask)      /* actually carry out the
       exchange */
                        domain_exchangeParticles(partner, 1, sendcount, 
      recvcount);
                      if(partner == ThisTask)
                        domain_exchangeParticles(task, 1, recvcount, sendcount)
      ;
                    }

                  domain_findExchangeNumbers(task, partner, 0, &sendcount, &
      recvcount);

                  list_NumPart[task] += recvcount - sendcount;
                  list_NumPart[partner] -= recvcount - sendcount;

                  toGo[task * NTask + partner] -= sendcount;
                  toGo[partner * NTask + task] -= recvcount;

                  if(task == ThisTask)  /* actually carry out the exchange */
                    domain_exchangeParticles(partner, 0, sendcount, recvcount);
                  if(partner == ThisTask)
                    domain_exchangeParticles(task, 0, recvcount, sendcount);
                }
            }
        }

      for(i = 0, sumtogo = 0; i < NTask * NTask; i++)
        sumtogo += toGo[i];
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a647e0c1a76b7f064ed5d201662f364bf_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a647e0c1a76b7f064ed5d201662f364bf_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae8e3aa408eaab9544cb7f93e69185492}{\index{proto.\-h@{proto.\-h}!domain\-\_\-\-Decomposition@{domain\-\_\-\-Decomposition}}
\index{domain\-\_\-\-Decomposition@{domain\-\_\-\-Decomposition}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-\-Decomposition}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-\-Decomposition} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ae8e3aa408eaab9544cb7f93e69185492}
\-This is the main routine for the domain decomposition. \-It acts as a driver routine that allocates various temporary buffers, maps the particles back onto the periodic box if needed, and then does the domain decomposition, and a final \-Peano-\/\-Hilbert order of all particles as a tuning measure. 

\-Definition at line 62 of file domain.\-c.



\-References \-All, do\-\_\-box\-\_\-wrapping(), domain\-\_\-decompose(), \-Key, \-Key\-Sorted, list\-\_\-load, list\-\_\-loadsph, list\-\_\-\-N\-\_\-gas, list\-\_\-\-Num\-Part, list\-\_\-work, local\-\_\-to\-Go, local\-\_\-to\-Go\-Sph, maxload, maxloadsph, \-N\-\_\-gas, \-N\-Task, \-Num\-Part, peano\-\_\-hilbert\-\_\-order(), \-R\-E\-D\-U\-C\-\_\-\-F\-A\-C, second(), \-This\-Task, timediff(), to\-Go, to\-Go\-Sph, and \-Tree\-Reconstruct\-Flag.



\-Referenced by find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift(), init(), and run().


\begin{DoxyCode}
{
  double t0, t1;

#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)
    {
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
      /* to make sure that we do a domain decomposition before the PM-force is
       evaluated.
         this is needed to make sure that the particles are wrapped into the
       box */
    }
#endif

  /* Check whether it is really time for a new domain decomposition */
  if(All.NumForcesSinceLastDomainDecomp > All.TotNumPart * All.
      TreeDomainUpdateFrequency)
    {
      t0 = second();

#ifdef PERIODIC
      do_box_wrapping();        /* map the particles back onto the box */
#endif
      All.NumForcesSinceLastDomainDecomp = 0;
      TreeReconstructFlag = 1;  /* ensures that new tree will be constructed */

      if(ThisTask == 0)
        {
          printf("domain decomposition... \n");
          fflush(stdout);
        }

      Key = malloc(sizeof(peanokey) * All.MaxPart);
      KeySorted = malloc(sizeof(peanokey) * All.MaxPart);

      toGo = malloc(sizeof(int) * NTask * NTask);
      toGoSph = malloc(sizeof(int) * NTask * NTask);
      local_toGo = malloc(sizeof(int) * NTask);
      local_toGoSph = malloc(sizeof(int) * NTask);
      list_NumPart = malloc(sizeof(int) * NTask);
      list_N_gas = malloc(sizeof(int) * NTask);
      list_load = malloc(sizeof(int) * NTask);
      list_loadsph = malloc(sizeof(int) * NTask);
      list_work = malloc(sizeof(double) * NTask);

      MPI_Allgather(&NumPart, 1, MPI_INT, list_NumPart, 1, MPI_INT, 
      MPI_COMM_WORLD);
      MPI_Allgather(&N_gas, 1, MPI_INT, list_N_gas, 1, MPI_INT, MPI_COMM_WORLD)
      ;

      maxload = All.MaxPart * REDUC_FAC;
      maxloadsph = All.MaxPartSph * REDUC_FAC;

      domain_decompose();

      free(list_work);
      free(list_loadsph);
      free(list_load);
      free(list_N_gas);
      free(list_NumPart);
      free(local_toGoSph);
      free(local_toGo);
      free(toGoSph);
      free(toGo);


      if(ThisTask == 0)
        {
          printf("domain decomposition done. \n");
          fflush(stdout);
        }

      t1 = second();
      All.CPU_Domain += timediff(t0, t1);

#ifdef PEANOHILBERT
      t0 = second();
      peano_hilbert_order();
      t1 = second();
      All.CPU_Peano += timediff(t0, t1);
#endif

      free(KeySorted);
      free(Key);
    }

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae8e3aa408eaab9544cb7f93e69185492_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae8e3aa408eaab9544cb7f93e69185492_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729}{\index{proto.\-h@{proto.\-h}!domain\-\_\-determine\-Top\-Tree@{domain\-\_\-determine\-Top\-Tree}}
\index{domain\-\_\-determine\-Top\-Tree@{domain\-\_\-determine\-Top\-Tree}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-determine\-Top\-Tree}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-determine\-Top\-Tree} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729}
\-This function constructs the global top-\/level tree node that is used for the domain decomposition. \-This is done by considering the string of \-Peano-\/\-Hilbert keys for all particles, which is recursively chopped off in pieces of eight segments until each segment holds at most a certain number of particles. $<$ \-Bits per dimension available for \-Peano-\/\-Hilbert order. \-Note\-: \-If peanokey is defined as type int, the allowed maximum is 10. \-If 64-\/bit integers are used, the maximum is 21

$<$ \-Bits per dimension available for \-Peano-\/\-Hilbert order. \-Note\-: \-If peanokey is defined as type int, the allowed maximum is 10. \-If 64-\/bit integers are used, the maximum is 21

$<$ \-The number of different \-Peano-\/\-Hilbert cells

$<$ \-Bits per dimension available for \-Peano-\/\-Hilbert order. \-Note\-: \-If peanokey is defined as type int, the allowed maximum is 10. \-If 64-\/bit integers are used, the maximum is 21

$<$ \-The number of different \-Peano-\/\-Hilbert cells 

\-Definition at line 896 of file domain.\-c.



\-References \-All, topnode\-\_\-exchange\-::\-Count, domain\-\_\-compare\-\_\-key(), domain\-\_\-compare\-\_\-toplist(), domain\-\_\-topsplit(), domain\-\_\-topsplit\-\_\-local(), \-Domain\-Corner, \-Domain\-Fac, \-Key, \-Key\-Sorted, \-N\-Task, \-N\-Topnodes, \-Num\-Part, \-P, peano\-\_\-hilbert\-\_\-key(), topnode\-\_\-exchange\-::\-Startkey, toplist, toplist\-\_\-local, and \-Top\-Nodes.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int i, ntop_local, ntop;
  int *ntopnodelist, *ntopoffset;

  for(i = 0; i < NumPart; i++)
    {
      KeySorted[i] = Key[i] = peano_hilbert_key((P[i].Pos[0] - DomainCorner[0])
       * DomainFac,
                                                (P[i].Pos[1] - DomainCorner[1])
       * DomainFac,
                                                (P[i].Pos[2] - DomainCorner[2])
       * DomainFac,
                                                BITS_PER_DIMENSION);
    }

  qsort(KeySorted, NumPart, sizeof(peanokey), domain_compare_key);

  NTopnodes = 1;
  TopNodes[0].Daughter = -1;
  TopNodes[0].Size = PEANOCELLS;
  TopNodes[0].StartKey = 0;
  TopNodes[0].Count = NumPart;
  TopNodes[0].Pstart = 0;

  domain_topsplit_local(0, 0);

  toplist_local = malloc(NTopnodes * sizeof(struct topnode_exchange));

  for(i = 0, ntop_local = 0; i < NTopnodes; i++)
    {
      if(TopNodes[i].Daughter == -1)    /* only use leaves */
        {
          toplist_local[ntop_local].Startkey = TopNodes[i].StartKey;
          toplist_local[ntop_local].Count = TopNodes[i].Count;
          ntop_local++;
        }
    }

  ntopnodelist = malloc(sizeof(int) * NTask);
  ntopoffset = malloc(sizeof(int) * NTask);

  MPI_Allgather(&ntop_local, 1, MPI_INT, ntopnodelist, 1, MPI_INT, 
      MPI_COMM_WORLD);

  for(i = 0, ntop = 0, ntopoffset[0] = 0; i < NTask; i++)
    {
      ntop += ntopnodelist[i];
      if(i > 0)
        ntopoffset[i] = ntopoffset[i - 1] + ntopnodelist[i - 1];
    }


  toplist = malloc(ntop * sizeof(struct topnode_exchange));

  for(i = 0; i < NTask; i++)
    {
      ntopnodelist[i] *= sizeof(struct topnode_exchange);
      ntopoffset[i] *= sizeof(struct topnode_exchange);
    }

  MPI_Allgatherv(toplist_local, ntop_local * sizeof(struct topnode_exchange), 
      MPI_BYTE,
                 toplist, ntopnodelist, ntopoffset, MPI_BYTE, MPI_COMM_WORLD);

  qsort(toplist, ntop, sizeof(struct topnode_exchange), domain_compare_toplist)
      ;

  NTopnodes = 1;
  TopNodes[0].Daughter = -1;
  TopNodes[0].Size = PEANOCELLS;
  TopNodes[0].StartKey = 0;
  TopNodes[0].Count = All.TotNumPart;
  TopNodes[0].Pstart = 0;
  TopNodes[0].Blocks = ntop;

  domain_topsplit(0, 0);

  free(toplist);
  free(ntopoffset);
  free(ntopnodelist);
  free(toplist_local);

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a25b4f5eb395f918bad4b4bc1fc3dc729_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca}{\index{proto.\-h@{proto.\-h}!domain\-\_\-exchange\-Particles@{domain\-\_\-exchange\-Particles}}
\index{domain\-\_\-exchange\-Particles@{domain\-\_\-exchange\-Particles}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-exchange\-Particles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-exchange\-Particles} (
\begin{DoxyParamCaption}
\item[{int}]{partner, }
\item[{int}]{sphflag, }
\item[{int}]{send\-\_\-count, }
\item[{int}]{recv\-\_\-count}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca}
\-This function exchanges particles between two \-C\-P\-Us according to the domain split. \-In doing this, the memory boundaries which may restrict the exhange process are observed. 

\-Definition at line 595 of file domain.\-c.



\-References \-Domain\-Key\-Buf, \-Domain\-Part\-Buf, \-Domain\-Sph\-Buf, \-Domain\-Task, endrun(), \-Key, \-N\-\_\-gas, \-Num\-Part, \-P, \-Sph\-P, \-T\-A\-G\-\_\-\-K\-E\-Y, \-T\-A\-G\-\_\-\-P\-D\-A\-T\-A, \-T\-A\-G\-\_\-\-S\-P\-H\-D\-A\-T\-A, \-This\-Task, and \-Top\-Nodes.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int i, no, n, count, rep;
  MPI_Status status;

  for(n = 0, count = 0; count < send_count && n < NumPart; n++)
    {
      if(sphflag)
        {
          if(P[n].Type != 0)
            continue;
        }
      else
        {
          if(P[n].Type == 0)
            continue;
        }

      no = 0;

      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (Key[n] - TopNodes[no].StartKey) / (
      TopNodes[no].Size / 8);

      no = TopNodes[no].Leaf;

      if(DomainTask[no] == partner)
        {
          if(sphflag)           /* special reorder routine for SPH particles
       (need to stay at beginning) */
            {
              DomainPartBuf[count] = P[n];      /* copy particle and collect in
       contiguous memory */
              DomainKeyBuf[count] = Key[n];
              DomainSphBuf[count] = SphP[n];

              P[n] = P[N_gas - 1];
              P[N_gas - 1] = P[NumPart - 1];

              Key[n] = Key[N_gas - 1];
              Key[N_gas - 1] = Key[NumPart - 1];

              SphP[n] = SphP[N_gas - 1];

              N_gas--;
            }
          else
            {
              DomainPartBuf[count] = P[n];      /* copy particle and collect in
       contiguous memory */
              DomainKeyBuf[count] = Key[n];
              P[n] = P[NumPart - 1];
              Key[n] = Key[NumPart - 1];
            }

          count++;
          NumPart--;
          n--;
        }
    }

  if(count != send_count)
    {
      printf("Houston, we got a problem...\n");
      printf("ThisTask=%d count=%d send_count=%d\n", ThisTask, count, 
      send_count);
      endrun(88);
    }

  /* transmit */

  for(rep = 0; rep < 2; rep++)
    {
      if((rep == 0 && ThisTask < partner) || (rep == 1 && ThisTask > partner))
        {
          if(send_count > 0)
            {
              MPI_Ssend(&DomainPartBuf[0], send_count * sizeof(struct 
      particle_data), MPI_BYTE, partner,
                        TAG_PDATA, MPI_COMM_WORLD);

              MPI_Ssend(&DomainKeyBuf[0], send_count * sizeof(peanokey), 
      MPI_BYTE, partner, TAG_KEY,
                        MPI_COMM_WORLD);

              if(sphflag)
                MPI_Ssend(&DomainSphBuf[0], send_count * sizeof(struct 
      sph_particle_data), MPI_BYTE, partner,
                          TAG_SPHDATA, MPI_COMM_WORLD);
            }
        }

      if((rep == 1 && ThisTask < partner) || (rep == 0 && ThisTask > partner))
        {
          if(recv_count > 0)
            {
              if(sphflag)
                {
                  if((NumPart - N_gas) > recv_count)
                    {
                      for(i = 0; i < recv_count; i++)
                        {
                          P[NumPart + i] = P[N_gas + i];
                          Key[NumPart + i] = Key[N_gas + i];
                        }
                    }
                  else
                    {
                      for(i = NumPart - 1; i >= N_gas; i--)
                        {
                          P[i + recv_count] = P[i];
                          Key[i + recv_count] = Key[i];
                        }
                    }

                  MPI_Recv(&P[N_gas], recv_count * sizeof(struct particle_data)
      , MPI_BYTE, partner, TAG_PDATA,
                           MPI_COMM_WORLD, &status);
                  MPI_Recv(&Key[N_gas], recv_count * sizeof(peanokey), MPI_BYTE
      , partner, TAG_KEY,
                           MPI_COMM_WORLD, &status);
                  MPI_Recv(&SphP[N_gas], recv_count * sizeof(struct 
      sph_particle_data), MPI_BYTE, partner,
                           TAG_SPHDATA, MPI_COMM_WORLD, &status);

                  N_gas += recv_count;
                }
              else
                {
                  MPI_Recv(&P[NumPart], recv_count * sizeof(struct 
      particle_data), MPI_BYTE, partner,
                           TAG_PDATA, MPI_COMM_WORLD, &status);
                  MPI_Recv(&Key[NumPart], recv_count * sizeof(peanokey), 
      MPI_BYTE, partner,
                           TAG_KEY, MPI_COMM_WORLD, &status);
                }

              NumPart += recv_count;
            }
        }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab7d41435f73c1626208d63b2d5ba28ca_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0e758ec7eef32fc7180092547f5a11b9}{\index{proto.\-h@{proto.\-h}!domain\-\_\-find\-Exchange\-Numbers@{domain\-\_\-find\-Exchange\-Numbers}}
\index{domain\-\_\-find\-Exchange\-Numbers@{domain\-\_\-find\-Exchange\-Numbers}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-find\-Exchange\-Numbers}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-find\-Exchange\-Numbers} (
\begin{DoxyParamCaption}
\item[{int}]{task, }
\item[{int}]{partner, }
\item[{int}]{sphflag, }
\item[{int $\ast$}]{send, }
\item[{int $\ast$}]{recv}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0e758ec7eef32fc7180092547f5a11b9}
\-This function counts how many particles have to be exchanged between two \-C\-P\-Us according to the domain split. \-If the \-C\-P\-Us are already quite full and hold data from other \-C\-P\-Us as well, not all the particles may be exchanged at once. \-In this case the communication phase has to be repeated, until enough of the third-\/party particles have been moved away such that the decomposition can be completed. 

\-Definition at line 534 of file domain.\-c.



\-References \-All, imin(), list\-\_\-\-N\-\_\-gas, list\-\_\-\-Num\-Part, \-N\-Task, to\-Go, and to\-Go\-Sph.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int numpartA, numpartsphA, ntobesentA, maxsendA, maxsendA_old;
  int numpartB, numpartsphB, ntobesentB, maxsendB, maxsendB_old;

  numpartA = list_NumPart[task];
  numpartsphA = list_N_gas[task];

  numpartB = list_NumPart[partner];
  numpartsphB = list_N_gas[partner];

  if(sphflag == 1)
    {
      ntobesentA = toGoSph[task * NTask + partner];
      ntobesentB = toGoSph[partner * NTask + task];
    }
  else
    {
      ntobesentA = toGo[task * NTask + partner] - toGoSph[task * NTask + 
      partner];
      ntobesentB = toGo[partner * NTask + task] - toGoSph[partner * NTask + 
      task];
    }

  maxsendA = imin(ntobesentA, All.BunchSizeDomain);
  maxsendB = imin(ntobesentB, All.BunchSizeDomain);

  do
    {
      maxsendA_old = maxsendA;
      maxsendB_old = maxsendB;

      maxsendA = imin(All.MaxPart - numpartB + maxsendB, maxsendA);
      maxsendB = imin(All.MaxPart - numpartA + maxsendA, maxsendB);
    }
  while((maxsendA != maxsendA_old) || (maxsendB != maxsendB_old));


  /* now make also sure that there is enough space for SPH particeles */
  if(sphflag == 1)
    {
      do
        {
          maxsendA_old = maxsendA;
          maxsendB_old = maxsendB;

          maxsendA = imin(All.MaxPartSph - numpartsphB + maxsendB, maxsendA);
          maxsendB = imin(All.MaxPartSph - numpartsphA + maxsendA, maxsendB);
        }
      while((maxsendA != maxsendA_old) || (maxsendB != maxsendB_old));
    }

  *send = maxsendA;
  *recv = maxsendB;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_a0e758ec7eef32fc7180092547f5a11b9_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a0e758ec7eef32fc7180092547f5a11b9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e}{\index{proto.\-h@{proto.\-h}!domain\-\_\-find\-Extent@{domain\-\_\-find\-Extent}}
\index{domain\-\_\-find\-Extent@{domain\-\_\-find\-Extent}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-find\-Extent}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-find\-Extent} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e}
\-This routine finds the extent of the global domain grid. $<$ \-Bits per dimension available for \-Peano-\/\-Hilbert order. \-Note\-: \-If peanokey is defined as type int, the allowed maximum is 10. \-If 64-\/bit integers are used, the maximum is 21 

\-Definition at line 845 of file domain.\-c.



\-References \-Domain\-Center, \-Domain\-Corner, \-Domain\-Fac, \-Domain\-Len, \-Num\-Part, and \-P.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int i, j;
  double len, xmin[3], xmax[3], xmin_glob[3], xmax_glob[3];

  /* determine local extension */
  for(j = 0; j < 3; j++)
    {
      xmin[j] = MAX_REAL_NUMBER;
      xmax[j] = -MAX_REAL_NUMBER;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          if(xmin[j] > P[i].Pos[j])
            xmin[j] = P[i].Pos[j];

          if(xmax[j] < P[i].Pos[j])
            xmax[j] = P[i].Pos[j];
        }
    }

  MPI_Allreduce(xmin, xmin_glob, 3, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
  MPI_Allreduce(xmax, xmax_glob, 3, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);

  len = 0;
  for(j = 0; j < 3; j++)
    if(xmax_glob[j] - xmin_glob[j] > len)
      len = xmax_glob[j] - xmin_glob[j];

  len *= 1.001;

  for(j = 0; j < 3; j++)
    {
      DomainCenter[j] = 0.5 * (xmin_glob[j] + xmax_glob[j]);
      DomainCorner[j] = 0.5 * (xmin_glob[j] + xmax_glob[j]) - 0.5 * len;
    }

  DomainLen = len;
  DomainFac = 1.0 / len * (((peanokey) 1) << (BITS_PER_DIMENSION));
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_add5620cbc133c73f0ce7da3a8fe9c01e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a412d5d8810751249cc8dcd9e219e4e57}{\index{proto.\-h@{proto.\-h}!domain\-\_\-find\-Split@{domain\-\_\-find\-Split}}
\index{domain\-\_\-find\-Split@{domain\-\_\-find\-Split}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-find\-Split}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf domain\-\_\-find\-Split} (
\begin{DoxyParamCaption}
\item[{int}]{cpustart, }
\item[{int}]{ncpu, }
\item[{int}]{first, }
\item[{int}]{last}
\end{DoxyParamCaption}
)}}\label{proto_8h_a412d5d8810751249cc8dcd9e219e4e57}
\-This function tries to find a split point in a range of cells in the domain-\/grid. \-The range of cells starts at 'first', and ends at 'last' (inclusively). \-The number of cpus that holds the range is 'ncpu', with the first cpu given by 'cpustart'. \-If more than 2 cpus are to be split, the function calls itself recursively. \-The division tries to achieve a best particle-\/load balance under the constraint that 'maxload' and 'maxloadsph' may not be exceeded, and that each cpu holds at least one cell from the domaingrid. \-If such a decomposition cannot be achieved, a non-\/zero error code is returned.

\-After successful completion, \-Domain\-My\-Start\mbox{[}\mbox{]} and \-Domain\-My\-Last\mbox{[}\mbox{]} contain the first and last cell of the domaingrid assigned to the local task for the given type. \-Also, \-Domain\-Task\mbox{[}\mbox{]} contains for each cell the task it was assigned to. 

\-Definition at line 327 of file domain.\-c.



\-References dmax(), domain\-\_\-find\-Split(), \-Domain\-Count, \-Domain\-Count\-Sph, \-Domain\-End\-List, \-Domain\-Start\-List, \-Domain\-Task, last, list\-\_\-load, list\-\_\-loadsph, maxload, and maxloadsph.



\-Referenced by domain\-\_\-decompose(), and domain\-\_\-find\-Split().


\begin{DoxyCode}
{
  int i, split, ok_left, ok_right;
  long long load, sphload, load_leftOfSplit, sphload_leftOfSplit;
  int ncpu_leftOfSplit;
  double maxAvgLoad_CurrentSplit, maxAvgLoad_NewSplit;


  ncpu_leftOfSplit = ncpu / 2;

  for(i = first, load = 0, sphload = 0; i <= last; i++)
    {
      load += DomainCount[i];
      sphload += DomainCountSph[i];
    }

  split = first + ncpu_leftOfSplit;

  for(i = first, load_leftOfSplit = sphload_leftOfSplit = 0; i < split; i++)
    {
      load_leftOfSplit += DomainCount[i];
      sphload_leftOfSplit += DomainCountSph[i];
    }

  /* find the best split point in terms of work-load balance */

  while(split < last - (ncpu - ncpu_leftOfSplit - 1) && split > 0)
    {
      maxAvgLoad_CurrentSplit =
        dmax(load_leftOfSplit / ncpu_leftOfSplit, (load - load_leftOfSplit) / (
      ncpu - ncpu_leftOfSplit));

      maxAvgLoad_NewSplit =
        dmax((load_leftOfSplit + DomainCount[split]) / ncpu_leftOfSplit,
             (load - load_leftOfSplit - DomainCount[split]) / (ncpu - 
      ncpu_leftOfSplit));

      if(maxAvgLoad_NewSplit <= maxAvgLoad_CurrentSplit)
        {
          load_leftOfSplit += DomainCount[split];
          sphload_leftOfSplit += DomainCountSph[split];
          split++;
        }
      else
        break;
    }


  /* we will now have to check whether this solution is possible given the
       restrictions on the maximum load */

  for(i = first, load_leftOfSplit = 0, sphload_leftOfSplit = 0; i < split; i++)
    {
      load_leftOfSplit += DomainCount[i];
      sphload_leftOfSplit += DomainCountSph[i];
    }

  if(load_leftOfSplit > maxload * ncpu_leftOfSplit ||
     (load - load_leftOfSplit) > maxload * (ncpu - ncpu_leftOfSplit))
    {
      /* we did not find a viable split */
      return -1;
    }

  if(sphload_leftOfSplit > maxloadsph * ncpu_leftOfSplit ||
     (sphload - sphload_leftOfSplit) > maxloadsph * (ncpu - ncpu_leftOfSplit))
    {
      /* we did not find a viable split */
      return -1;
    }

  if(ncpu_leftOfSplit >= 2)
    ok_left = domain_findSplit(cpustart, ncpu_leftOfSplit, first, split - 1);
  else
    ok_left = 0;

  if((ncpu - ncpu_leftOfSplit) >= 2)
    ok_right = domain_findSplit(cpustart + ncpu_leftOfSplit, ncpu - 
      ncpu_leftOfSplit, split, last);
  else
    ok_right = 0;

  if(ok_left == 0 && ok_right == 0)
    {
      /* found a viable split */

      if(ncpu_leftOfSplit == 1)
        {
          for(i = first; i < split; i++)
            DomainTask[i] = cpustart;

          list_load[cpustart] = load_leftOfSplit;
          list_loadsph[cpustart] = sphload_leftOfSplit;
          DomainStartList[cpustart] = first;
          DomainEndList[cpustart] = split - 1;
        }

      if((ncpu - ncpu_leftOfSplit) == 1)
        {
          for(i = split; i <= last; i++)
            DomainTask[i] = cpustart + ncpu_leftOfSplit;

          list_load[cpustart + ncpu_leftOfSplit] = load - load_leftOfSplit;
          list_loadsph[cpustart + ncpu_leftOfSplit] = sphload - 
      sphload_leftOfSplit;
          DomainStartList[cpustart + ncpu_leftOfSplit] = split;
          DomainEndList[cpustart + ncpu_leftOfSplit] = last;
        }

      return 0;
    }

  /* we did not find a viable split */
  return -1;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a412d5d8810751249cc8dcd9e219e4e57_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a412d5d8810751249cc8dcd9e219e4e57_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a89c54187117b91d4270a4f0c406ce2ba}{\index{proto.\-h@{proto.\-h}!domain\-\_\-shift\-Split@{domain\-\_\-shift\-Split}}
\index{domain\-\_\-shift\-Split@{domain\-\_\-shift\-Split}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-shift\-Split}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-shift\-Split} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a89c54187117b91d4270a4f0c406ce2ba}
\-This function tries to improve the domain decomposition found by \hyperlink{domain_8c_a412d5d8810751249cc8dcd9e219e4e57}{domain\-\_\-find\-Split()} with respect to work-\/load balance. \-To this end, the boundaries in the existing domain-\/split solution (which was found by trying to balance the particle load) are shifted as long as this leads to better work-\/load while still remaining within the allowed memory-\/imbalance constraints. 

\-Definition at line 447 of file domain.\-c.



\-References dmax(), \-Domain\-Count, \-Domain\-Count\-Sph, \-Domain\-End\-List, \-Domain\-Start\-List, \-Domain\-Task, \-Domain\-Work, list\-\_\-load, list\-\_\-loadsph, list\-\_\-work, maxload, maxloadsph, \-N\-Task, and \-N\-Topleaves.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int i, task, iter = 0, moved;
  double maxw, newmaxw;

  for(task = 0; task < NTask; task++)
    list_work[task] = 0;

  for(i = 0; i < NTopleaves; i++)
    list_work[DomainTask[i]] += DomainWork[i];

  do
    {
      for(task = 0, moved = 0; task < NTask - 1; task++)
        {
          maxw = dmax(list_work[task], list_work[task + 1]);

          if(list_work[task] < list_work[task + 1])
            {
              newmaxw = dmax(list_work[task] + DomainWork[DomainStartList[task 
      + 1]],
                             list_work[task + 1] - DomainWork[DomainStartList[
      task + 1]]);
              if(newmaxw <= maxw)
                {
                  if(list_load[task] + DomainCount[DomainStartList[task + 1]] 
      <= maxload)
                    {
                      if(list_loadsph[task] + DomainCountSph[DomainStartList[
      task + 1]] > maxloadsph)
                        continue;

                      /* ok, we can move one domain cell from right to left */
                      list_work[task] += DomainWork[DomainStartList[task + 1]];
                      list_load[task] += DomainCount[DomainStartList[task + 1]]
      ;
                      list_loadsph[task] += DomainCountSph[DomainStartList[task
       + 1]];
                      list_work[task + 1] -= DomainWork[DomainStartList[task + 
      1]];
                      list_load[task + 1] -= DomainCount[DomainStartList[task +
       1]];
                      list_loadsph[task + 1] -= DomainCountSph[DomainStartList[
      task + 1]];

                      DomainTask[DomainStartList[task + 1]] = task;
                      DomainStartList[task + 1] += 1;
                      DomainEndList[task] += 1;

                      moved++;
                    }
                }
            }
          else
            {
              newmaxw = dmax(list_work[task] - DomainWork[DomainEndList[task]],
                             list_work[task + 1] + DomainWork[DomainEndList[
      task]]);
              if(newmaxw <= maxw)
                {
                  if(list_load[task + 1] + DomainCount[DomainEndList[task]] <= 
      maxload)
                    {
                      if(list_loadsph[task + 1] + DomainCountSph[DomainEndList[
      task]] > maxloadsph)
                        continue;

                      /* ok, we can move one domain cell from left to right */
                      list_work[task] -= DomainWork[DomainEndList[task]];
                      list_load[task] -= DomainCount[DomainEndList[task]];
                      list_loadsph[task] -= DomainCountSph[DomainEndList[task]]
      ;
                      list_work[task + 1] += DomainWork[DomainEndList[task]];
                      list_load[task + 1] += DomainCount[DomainEndList[task]];
                      list_loadsph[task + 1] += DomainCountSph[DomainEndList[
      task]];

                      DomainTask[DomainEndList[task]] = task + 1;
                      DomainEndList[task] -= 1;
                      DomainStartList[task + 1] -= 1;

                      moved++;
                    }
                }

            }
        }

      iter++;
    }
  while(moved > 0 && iter < 10 * NTopleaves);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=260pt]{proto_8h_a89c54187117b91d4270a4f0c406ce2ba_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a89c54187117b91d4270a4f0c406ce2ba_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a25aada0d3751c2afd2a376151d1d917e}{\index{proto.\-h@{proto.\-h}!domain\-\_\-sum\-Cost@{domain\-\_\-sum\-Cost}}
\index{domain\-\_\-sum\-Cost@{domain\-\_\-sum\-Cost}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-sum\-Cost}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-sum\-Cost} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a25aada0d3751c2afd2a376151d1d917e}
\-This routine bins the particles onto the domain-\/grid, i.\-e. it sums up the total number of particles and the total amount of work in each of the domain-\/cells. \-This information forms the basis for the actual decision on the adopted domain decomposition. 

\-Definition at line 786 of file domain.\-c.



\-References domain\-\_\-walktoptree(), \-Domain\-Count, \-Domain\-Count\-Sph, \-Domain\-Work, \-Key, \-N\-Topleaves, \-N\-Topnodes, \-Num\-Part, \-P, \-This\-Task, and \-Top\-Nodes.



\-Referenced by domain\-\_\-decompose().


\begin{DoxyCode}
{
  int i, n, no;
  double *local_DomainWork;
  int *local_DomainCount;
  int *local_DomainCountSph;

  local_DomainWork = malloc(NTopnodes * sizeof(double));
  local_DomainCount = malloc(NTopnodes * sizeof(int));
  local_DomainCountSph = malloc(NTopnodes * sizeof(int));



  NTopleaves = 0;

  domain_walktoptree(0);

  for(i = 0; i < NTopleaves; i++)
    {
      local_DomainWork[i] = 0;
      local_DomainCount[i] = 0;
      local_DomainCountSph[i] = 0;
    }

  if(ThisTask == 0)
    printf("NTopleaves= %d\n", NTopleaves);

  for(n = 0; n < NumPart; n++)
    {
      no = 0;

      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (Key[n] - TopNodes[no].StartKey) / (
      TopNodes[no].Size / 8);

      no = TopNodes[no].Leaf;

      if(P[n].Ti_endstep > P[n].Ti_begstep)
        local_DomainWork[no] += (1.0 + P[n].GravCost) / (P[n].Ti_endstep - P[n]
      .Ti_begstep);
      else
        local_DomainWork[no] += (1.0 + P[n].GravCost);

      local_DomainCount[no] += 1;
      if(P[n].Type == 0)
        local_DomainCountSph[no] += 1;
    }

  MPI_Allreduce(local_DomainWork, DomainWork, NTopleaves, MPI_DOUBLE, MPI_SUM, 
      MPI_COMM_WORLD);
  MPI_Allreduce(local_DomainCount, DomainCount, NTopleaves, MPI_INT, MPI_SUM, 
      MPI_COMM_WORLD);
  MPI_Allreduce(local_DomainCountSph, DomainCountSph, NTopleaves, MPI_INT, 
      MPI_SUM, MPI_COMM_WORLD);


  free(local_DomainCountSph);
  free(local_DomainCount);
  free(local_DomainWork);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{proto_8h_a25aada0d3751c2afd2a376151d1d917e_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a25aada0d3751c2afd2a376151d1d917e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a606de536756a67ad8f79f1135009195e}{\index{proto.\-h@{proto.\-h}!domain\-\_\-topsplit@{domain\-\_\-topsplit}}
\index{domain\-\_\-topsplit@{domain\-\_\-topsplit}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-topsplit}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-topsplit} (
\begin{DoxyParamCaption}
\item[{int}]{node, }
\item[{peanokey}]{startkey}
\end{DoxyParamCaption}
)}}\label{proto_8h_a606de536756a67ad8f79f1135009195e}
\-This function is responsible for constructing the global top-\/level tree segments. \-Starting from a joint list of all local top-\/level segments, in which mulitple occurences of the same spatial segment have been combined, a segment is subdivided into 8 pieces recursively until the number of particles in each segment has fallen below \-All.\-Tot\-Num\-Part / (\-T\-O\-P\-N\-O\-D\-E\-F\-A\-C\-T\-O\-R $\ast$ \-N\-Task). $<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition 

\-Definition at line 1049 of file domain.\-c.



\-References \-All, topnode\-\_\-exchange\-::\-Count, domain\-\_\-topsplit(), endrun(), \-N\-Task, \-N\-Topnodes, topnode\-\_\-exchange\-::\-Startkey, \-This\-Task, toplist, \-T\-O\-P\-N\-O\-D\-E\-F\-A\-C\-T\-O\-R, and \-Top\-Nodes.



\-Referenced by domain\-\_\-determine\-Top\-Tree(), and domain\-\_\-topsplit().


\begin{DoxyCode}
{
  int i, p, sub, bin;

  if(TopNodes[node].Size >= 8)
    {
      TopNodes[node].Daughter = NTopnodes;

      for(i = 0; i < 8; i++)
        {
          if(NTopnodes < MAXTOPNODES)
            {
              sub = TopNodes[node].Daughter + i;
              TopNodes[sub].Size = TopNodes[node].Size / 8;
              TopNodes[sub].Count = 0;
              TopNodes[sub].Blocks = 0;
              TopNodes[sub].Daughter = -1;
              TopNodes[sub].StartKey = startkey + i * TopNodes[sub].Size;
              TopNodes[sub].Pstart = TopNodes[node].Pstart;
              NTopnodes++;
            }
          else
            {
              printf("Task=%d: We are out of Topnodes. Increasing the constant
       MAXTOPNODES might help.\n",
                     ThisTask);
              fflush(stdout);
              endrun(137213);
            }
        }

      for(p = TopNodes[node].Pstart; p < TopNodes[node].Pstart + TopNodes[node]
      .Blocks; p++)
        {
          bin = (toplist[p].Startkey - startkey) / (TopNodes[node].Size / 8);
          sub = TopNodes[node].Daughter + bin;

          if(bin < 0 || bin > 7)
            endrun(77);

          if(TopNodes[sub].Blocks == 0)
            TopNodes[sub].Pstart = p;

          TopNodes[sub].Count += toplist[p].Count;
          TopNodes[sub].Blocks++;
        }

      for(i = 0; i < 8; i++)
        {
          sub = TopNodes[node].Daughter + i;
          if(TopNodes[sub].Count > All.TotNumPart / (TOPNODEFACTOR * NTask))
            domain_topsplit(sub, TopNodes[sub].StartKey);
        }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a606de536756a67ad8f79f1135009195e_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a606de536756a67ad8f79f1135009195e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aa5001f9be833c4673392b40e7be3a421}{\index{proto.\-h@{proto.\-h}!domain\-\_\-topsplit\-\_\-local@{domain\-\_\-topsplit\-\_\-local}}
\index{domain\-\_\-topsplit\-\_\-local@{domain\-\_\-topsplit\-\_\-local}!proto.h@{proto.\-h}}
\subsubsection[{domain\-\_\-topsplit\-\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf domain\-\_\-topsplit\-\_\-local} (
\begin{DoxyParamCaption}
\item[{int}]{node, }
\item[{peanokey}]{startkey}
\end{DoxyParamCaption}
)}}\label{proto_8h_aa5001f9be833c4673392b40e7be3a421}
\-This function is responsible for constructing the local top-\/level \-Peano-\/\-Hilbert segments. \-A segment is cut into 8 pieces recursively until the number of particles in the segment has fallen below \-All.\-Tot\-Num\-Part / (\-T\-O\-P\-N\-O\-D\-E\-F\-A\-C\-T\-O\-R $\ast$ \-N\-Task $\ast$ \-N\-Task). $<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition 

\-Definition at line 982 of file domain.\-c.



\-References \-All, topnode\-\_\-exchange\-::\-Count, domain\-\_\-topsplit\-\_\-local(), endrun(), \-Key\-Sorted, \-N\-Task, \-N\-Topnodes, \-This\-Task, \-T\-O\-P\-N\-O\-D\-E\-F\-A\-C\-T\-O\-R, and \-Top\-Nodes.



\-Referenced by domain\-\_\-determine\-Top\-Tree(), and domain\-\_\-topsplit\-\_\-local().


\begin{DoxyCode}
{
  int i, p, sub, bin;

  if(TopNodes[node].Size >= 8)
    {
      TopNodes[node].Daughter = NTopnodes;

      for(i = 0; i < 8; i++)
        {
          if(NTopnodes < MAXTOPNODES)
            {
              sub = TopNodes[node].Daughter + i;
              TopNodes[sub].Size = TopNodes[node].Size / 8;
              TopNodes[sub].Count = 0;
              TopNodes[sub].Daughter = -1;
              TopNodes[sub].StartKey = startkey + i * TopNodes[sub].Size;
              TopNodes[sub].Pstart = TopNodes[node].Pstart;

              NTopnodes++;
            }
          else
            {
              printf("task=%d: We are out of Topnodes. Increasing the constant
       MAXTOPNODES might help.\n",
                     ThisTask);
              fflush(stdout);
              endrun(13213);
            }
        }

      for(p = TopNodes[node].Pstart; p < TopNodes[node].Pstart + TopNodes[node]
      .Count; p++)
        {
          bin = (KeySorted[p] - startkey) / (TopNodes[node].Size / 8);

          if(bin < 0 || bin > 7)
            {
              printf("task=%d: something odd has happened here. bin=%d\n", 
      ThisTask, bin);
              fflush(stdout);
              endrun(13123123);
            }

          sub = TopNodes[node].Daughter + bin;

          if(TopNodes[sub].Count == 0)
            TopNodes[sub].Pstart = p;

          TopNodes[sub].Count++;
        }

      for(i = 0; i < 8; i++)
        {
          sub = TopNodes[node].Daughter + i;
          if(TopNodes[sub].Count > All.TotNumPart / (TOPNODEFACTOR * NTask * 
      NTask))
            domain_topsplit_local(sub, TopNodes[sub].StartKey);
        }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aa5001f9be833c4673392b40e7be3a421_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aa5001f9be833c4673392b40e7be3a421_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e}{\index{proto.\-h@{proto.\-h}!drift\-\_\-integ@{drift\-\_\-integ}}
\index{drift\-\_\-integ@{drift\-\_\-integ}!proto.h@{proto.\-h}}
\subsubsection[{drift\-\_\-integ}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf drift\-\_\-integ} (
\begin{DoxyParamCaption}
\item[{double}]{a, }
\item[{void $\ast$}]{param}
\end{DoxyParamCaption}
)}}\label{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e}
\-Integration kernel for drift factor computation. 

\-Definition at line 179 of file driftfac.\-c.



\-References \-All.



\-Referenced by init\-\_\-drift\-\_\-table().


\begin{DoxyCode}
{
  double h;

  h = All.Omega0 / (a * a * a) + (1 - All.Omega0 - All.OmegaLambda) / (a * a) +
       All.OmegaLambda;
  h = All.Hubble * sqrt(h);

  return 1 / (h * a * a * a);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a8cb77fa18fd6b91a358bd0a9c04cbf2e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0}{\index{proto.\-h@{proto.\-h}!dump\-\_\-particles@{dump\-\_\-particles}}
\index{dump\-\_\-particles@{dump\-\_\-particles}!proto.h@{proto.\-h}}
\subsubsection[{dump\-\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf dump\-\_\-particles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0}
\-This function dumps some of the basic particle data to a file. \-In case the tree construction fails, it is called just before the run terminates with an error message. \-Examination of the generated file may then give clues to what caused the problem. 

\-Definition at line 3124 of file forcetree.\-c.



\-References fd, my\-\_\-fwrite(), \-Num\-Part, \-P, and \-This\-Task.



\-Referenced by force\-\_\-create\-\_\-empty\-\_\-nodes(), and force\-\_\-treebuild\-\_\-single().


\begin{DoxyCode}
{
  FILE *fd;
  char buffer[200];
  int i;

  sprintf(buffer, "particles%d.dat", ThisTask);
  fd = fopen(buffer, "w");
  my_fwrite(&NumPart, 1, sizeof(int), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].Pos[0], 3, sizeof(FLOAT), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].Vel[0], 3, sizeof(FLOAT), fd);

  for(i = 0; i < NumPart; i++)
    my_fwrite(&P[i].ID, 1, sizeof(int), fd);

  fclose(fd);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab303b92c6d6b4144999c5cebabd65ec0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a3757efb7e470353080a128388ccebec9}{\index{proto.\-h@{proto.\-h}!empty\-\_\-read\-\_\-buffer@{empty\-\_\-read\-\_\-buffer}}
\index{empty\-\_\-read\-\_\-buffer@{empty\-\_\-read\-\_\-buffer}!proto.h@{proto.\-h}}
\subsubsection[{empty\-\_\-read\-\_\-buffer}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf empty\-\_\-read\-\_\-buffer} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr, }
\item[{int}]{offset, }
\item[{int}]{pc, }
\item[{int}]{type}
\end{DoxyParamCaption}
)}}\label{proto_8h_a3757efb7e470353080a128388ccebec9}
\-This function reads out the buffer that was filled with particle data, and stores it at the appropriate place in the particle structures. 

\-Definition at line 168 of file read\-\_\-ic.\-c.



\-References \-Comm\-Buffer, \-P, and \-Sph\-P.



\-Referenced by read\-\_\-file().


\begin{DoxyCode}
{
  int n, k;
  float *fp;

#ifdef LONGIDS
  long long *ip;
#else
  int *ip;
#endif

  fp = CommBuffer;
  ip = CommBuffer;

  switch (blocknr)
    {
    case IO_POS:                /* positions */
      for(n = 0; n < pc; n++)
        for(k = 0; k < 3; k++)
          P[offset + n].Pos[k] = *fp++;

      for(n = 0; n < pc; n++)
        P[offset + n].Type = type;      /* initialize type here as well */
      break;

    case IO_VEL:                /* velocities */
      for(n = 0; n < pc; n++)
        for(k = 0; k < 3; k++)
          P[offset + n].Vel[k] = *fp++;
      break;

    case IO_ID:         /* particle ID */
      for(n = 0; n < pc; n++)
        P[offset + n].ID = *ip++;
      break;

    case IO_MASS:               /* particle mass */
      for(n = 0; n < pc; n++)
        P[offset + n].Mass = *fp++;
      break;

    case IO_U:                  /* temperature */
      for(n = 0; n < pc; n++)
        SphP[offset + n].Entropy = *fp++;
      break;

    case IO_RHO:                /* density */
      for(n = 0; n < pc; n++)
        SphP[offset + n].Density = *fp++;
      break;


    case IO_HSML:               /* SPH smoothing length */
      for(n = 0; n < pc; n++)
        SphP[offset + n].Hsml = *fp++;
      break;




      /* the other input fields (if present) are not needed to define the 
         initial conditions of the code */

    case IO_POT:
    case IO_ACCEL:
    case IO_DTENTR:
    case IO_TSTP:
      break;
    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a3757efb7e470353080a128388ccebec9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d}{\index{proto.\-h@{proto.\-h}!endrun@{endrun}}
\index{endrun@{endrun}!proto.h@{proto.\-h}}
\subsubsection[{endrun}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf endrun} (
\begin{DoxyParamCaption}
\item[{int}]{ierr}
\end{DoxyParamCaption}
)}}\label{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d}
\-This function aborts the simulations. \-If a single processors wants an immediate termination, the function needs to be called with ierr$>$0. \-A bunch of \-M\-P\-I-\/error messages may also appear in this case. \-For ierr=0, \-M\-P\-I is gracefully cleaned up, but this requires that all processors call \hyperlink{endrun_8c_a6c7c5d488c8a9e1fb9c408ae00aa8839}{endrun()}. 

\-Definition at line 25 of file endrun.\-c.



\-References terminate\-\_\-processes(), and \-This\-Task.



\-Referenced by allocate\-\_\-commbuffers(), allocate\-\_\-memory(), \-Allocate\-Interaction\-Table(), check\-\_\-omega(), compute\-\_\-potential(), density(), domain\-\_\-decompose(), domain\-\_\-exchange\-Particles(), domain\-\_\-topsplit(), domain\-\_\-topsplit\-\_\-local(), find\-\_\-files(), find\-\_\-next\-\_\-outputtime(), force\-\_\-create\-\_\-empty\-\_\-nodes(), force\-\_\-insert\-\_\-pseudo\-\_\-particles(), force\-\_\-treeallocate(), force\-\_\-treebuild\-\_\-single(), force\-\_\-treeevaluate(), force\-\_\-treeevaluate\-\_\-potential(), force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange(), force\-\_\-treeevaluate\-\_\-shortrange(), get\-\_\-particles\-\_\-in\-\_\-block(), get\-\_\-timestep(), gravity\-\_\-forcetest(), init(), long\-\_\-range\-\_\-force(), main(), my\-\_\-fread(), my\-\_\-fwrite(), ngb\-\_\-treeallocate(), open\-\_\-outputfiles(), pm\-\_\-init\-\_\-periodic\-\_\-allocate(), read\-\_\-file(), read\-\_\-parameter\-\_\-file(), readjust\-\_\-timebase(), restart(), savepositions(), update\-\_\-interaction\-\_\-table(), and write\-\_\-file().


\begin{DoxyCode}
{
  if(ierr)
    {
      printf("task %d: endrun called with an error level of %d\n\n\n", ThisTask
      , ierr);
      fflush(stdout);
#ifdef DEBUG
      terminate_processes();
      raise(SIGABRT);
      sleep(60);
#else
      MPI_Abort(MPI_COMM_WORLD, ierr);
#endif
      exit(0);
    }

  MPI_Finalize();
  exit(0);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=284pt]{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a9c69e0b6a074bb9341cf9854f17f245d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae903322da17c6875ab606b032b918099}{\index{proto.\-h@{proto.\-h}!energy\-\_\-statistics@{energy\-\_\-statistics}}
\index{energy\-\_\-statistics@{energy\-\_\-statistics}!proto.h@{proto.\-h}}
\subsubsection[{energy\-\_\-statistics}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf energy\-\_\-statistics} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ae903322da17c6875ab606b032b918099}
\-This routine first calls a computation of various global quantities of the particle distribution, and then writes some statistics about the energies in the various particle components to the file \-Fd\-Energy. 

\-Definition at line 432 of file run.\-c.



\-References \-All, compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system(), \-Fd\-Energy, \-Sys\-State, and \-This\-Task.



\-Referenced by run().


\begin{DoxyCode}
{
  compute_global_quantities_of_system();

  if(ThisTask == 0)
    {
      fprintf(FdEnergy,
              "%g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g
       %g %g %g %g %g %g %g\n",
              All.Time, SysState.EnergyInt, SysState.EnergyPot, SysState.
      EnergyKin, SysState.EnergyIntComp[0],
              SysState.EnergyPotComp[0], SysState.EnergyKinComp[0], SysState.
      EnergyIntComp[1],
              SysState.EnergyPotComp[1], SysState.EnergyKinComp[1], SysState.
      EnergyIntComp[2],
              SysState.EnergyPotComp[2], SysState.EnergyKinComp[2], SysState.
      EnergyIntComp[3],
              SysState.EnergyPotComp[3], SysState.EnergyKinComp[3], SysState.
      EnergyIntComp[4],
              SysState.EnergyPotComp[4], SysState.EnergyKinComp[4], SysState.
      EnergyIntComp[5],
              SysState.EnergyPotComp[5], SysState.EnergyKinComp[5], SysState.
      MassComp[0],
              SysState.MassComp[1], SysState.MassComp[2], SysState.MassComp[3],
       SysState.MassComp[4],
              SysState.MassComp[5]);

      fflush(FdEnergy);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae903322da17c6875ab606b032b918099_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_ae903322da17c6875ab606b032b918099_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d}{\index{proto.\-h@{proto.\-h}!every\-\_\-timestep\-\_\-stuff@{every\-\_\-timestep\-\_\-stuff}}
\index{every\-\_\-timestep\-\_\-stuff@{every\-\_\-timestep\-\_\-stuff}!proto.h@{proto.\-h}}
\subsubsection[{every\-\_\-timestep\-\_\-stuff}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf every\-\_\-timestep\-\_\-stuff} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d}
\-This routine writes one line for every timestep to two log-\/files. \-In \-Fd\-Info, we just list the timesteps that have been done, while in \-Fd\-C\-P\-U the cumulative cpu-\/time consumption in various parts of the code is stored. 

\-Definition at line 370 of file run.\-c.



\-References \-All, \-Fd\-C\-P\-U, \-Fd\-Info, \-N\-Task, set\-\_\-random\-\_\-numbers(), and \-This\-Task.



\-Referenced by run().


\begin{DoxyCode}
{
  double z;

  if(ThisTask == 0)
    {
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      if(All.ComovingIntegrationOn)
        {
          z = 1.0 / (All.Time) - 1;
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Redshift: %g, Systemstep:
       %g, Dloga: %g, NselfInteractions: %lu\n", 
                  All.NumCurrentTiStep, All.Time, z, All.TimeStep,
                  log(All.Time) - log(All.Time - All.TimeStep),  All.
      Nself_interactionsSum);
          printf("\nBegin Step %d, Time: %g, Redshift: %g, Systemstep: %g,
       Dloga: %g, NselfInteractions: %lu\n", All.NumCurrentTiStep,
                 All.Time, z, All.TimeStep, log(All.Time) - log(All.Time - All.
      TimeStep), All.Nself_interactionsSum);
          fflush(FdInfo);
        }
      else
        {
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Systemstep: %g,
       NselfInteractions: %lu\n", All.NumCurrentTiStep, All.Time,
                  All.TimeStep, All.Nself_interactionsSum);
          printf("\nBegin Step %d, Time: %g, Systemstep: %g, NselfInteractions:
       %lu\n", All.NumCurrentTiStep, All.Time, All.TimeStep, All.Nself_interactionsSum
      );
          fflush(FdInfo);
        }
#else       
      if(All.ComovingIntegrationOn)
        {
          z = 1.0 / (All.Time) - 1;
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Redshift: %g, Systemstep:
       %g, Dloga: %g\n",
                  All.NumCurrentTiStep, All.Time, z, All.TimeStep,
                  log(All.Time) - log(All.Time - All.TimeStep));
          printf("\nBegin Step %d, Time: %g, Redshift: %g, Systemstep: %g,
       Dloga: %g\n", All.NumCurrentTiStep,
                 All.Time, z, All.TimeStep, log(All.Time) - log(All.Time - All.
      TimeStep));
          fflush(FdInfo);
        }
      else
        {
          fprintf(FdInfo, "\nBegin Step %d, Time: %g, Systemstep: %g\n", All.
      NumCurrentTiStep, All.Time,
                  All.TimeStep);
          printf("\nBegin Step %d, Time: %g, Systemstep: %g\n", All.
      NumCurrentTiStep, All.Time, All.TimeStep);
          fflush(FdInfo);
        }
#endif
      fprintf(FdCPU, "Step %d, Time: %g, CPUs: %d\n", All.NumCurrentTiStep, All
      .Time, NTask);

      fprintf(FdCPU,
              "%10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f
       %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f\n",
              All.CPU_Total, All.CPU_Gravity, All.CPU_Hydro, All.CPU_Domain, All
      .CPU_Potential,
              All.CPU_Predict, All.CPU_TimeLine, All.CPU_Snapshot, All.
      CPU_TreeWalk, All.CPU_TreeConstruction,
              All.CPU_CommSum, All.CPU_Imbalance, All.CPU_HydCompWalk, All.
      CPU_HydCommSumm,
              All.CPU_HydImbalance, All.CPU_EnsureNgb, All.CPU_PM, All.
      CPU_Peano);
      fflush(FdCPU);
    }

  set_random_numbers();
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{proto_8h_a7e26319b203616f2c85b5fd6f2ade85d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad8b8e212e593e1795f6ba522239086fc}{\index{proto.\-h@{proto.\-h}!ewald\-\_\-corr@{ewald\-\_\-corr}}
\index{ewald\-\_\-corr@{ewald\-\_\-corr}!proto.h@{proto.\-h}}
\subsubsection[{ewald\-\_\-corr}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ewald\-\_\-corr} (
\begin{DoxyParamCaption}
\item[{double}]{dx, }
\item[{double}]{dy, }
\item[{double}]{dz, }
\item[{double $\ast$}]{fper}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad8b8e212e593e1795f6ba522239086fc}
\-This function looks up the correction force due to the infinite number of periodic particle/node images. \-We here use trilinear interpolation to get it from the precomputed tables, which contain one octant around the target particle at the origin. \-The other octants are obtained from it by exploiting the symmetry properties. 

\-Definition at line 3312 of file forcetree.\-c.



\-References \-E\-N, fac\-\_\-intp, fcorrx, fcorry, and fcorrz.



\-Referenced by force\-\_\-treeevaluate\-\_\-direct().


\begin{DoxyCode}
{
  int signx, signy, signz;
  int i, j, k;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;

  if(dx < 0)
    {
      dx = -dx;
      signx = +1;
    }
  else
    signx = -1;

  if(dy < 0)
    {
      dy = -dy;
      signy = +1;
    }
  else
    signy = -1;

  if(dz < 0)
    {
      dz = -dz;
      signz = +1;
    }
  else
    signz = -1;

  u = dx * fac_intp;
  i = (int) u;
  if(i >= EN)
    i = EN - 1;
  u -= i;
  v = dy * fac_intp;
  j = (int) v;
  if(j >= EN)
    j = EN - 1;
  v -= j;
  w = dz * fac_intp;
  k = (int) w;
  if(k >= EN)
    k = EN - 1;
  w -= k;

  f1 = (1 - u) * (1 - v) * (1 - w);
  f2 = (1 - u) * (1 - v) * (w);
  f3 = (1 - u) * (v) * (1 - w);
  f4 = (1 - u) * (v) * (w);
  f5 = (u) * (1 - v) * (1 - w);
  f6 = (u) * (1 - v) * (w);
  f7 = (u) * (v) * (1 - w);
  f8 = (u) * (v) * (w);

  fper[0] = signx * (fcorrx[i][j][k] * f1 +
                     fcorrx[i][j][k + 1] * f2 +
                     fcorrx[i][j + 1][k] * f3 +
                     fcorrx[i][j + 1][k + 1] * f4 +
                     fcorrx[i + 1][j][k] * f5 +
                     fcorrx[i + 1][j][k + 1] * f6 +
                     fcorrx[i + 1][j + 1][k] * f7 + fcorrx[i + 1][j + 1][k + 1]
       * f8);

  fper[1] = signy * (fcorry[i][j][k] * f1 +
                     fcorry[i][j][k + 1] * f2 +
                     fcorry[i][j + 1][k] * f3 +
                     fcorry[i][j + 1][k + 1] * f4 +
                     fcorry[i + 1][j][k] * f5 +
                     fcorry[i + 1][j][k + 1] * f6 +
                     fcorry[i + 1][j + 1][k] * f7 + fcorry[i + 1][j + 1][k + 1]
       * f8);

  fper[2] = signz * (fcorrz[i][j][k] * f1 +
                     fcorrz[i][j][k + 1] * f2 +
                     fcorrz[i][j + 1][k] * f3 +
                     fcorrz[i][j + 1][k + 1] * f4 +
                     fcorrz[i + 1][j][k] * f5 +
                     fcorrz[i + 1][j][k + 1] * f6 +
                     fcorrz[i + 1][j + 1][k] * f7 + fcorrz[i + 1][j + 1][k + 1]
       * f8);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad8b8e212e593e1795f6ba522239086fc_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0c4d2bd0695737095313d7dc47ce120c}{\index{proto.\-h@{proto.\-h}!ewald\-\_\-force@{ewald\-\_\-force}}
\index{ewald\-\_\-force@{ewald\-\_\-force}!proto.h@{proto.\-h}}
\subsubsection[{ewald\-\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ewald\-\_\-force} (
\begin{DoxyParamCaption}
\item[{int}]{iii, }
\item[{int}]{jjj, }
\item[{int}]{kkk, }
\item[{double}]{x\mbox{[}3\mbox{]}, }
\item[{double}]{force\mbox{[}3\mbox{]}}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0c4d2bd0695737095313d7dc47ce120c}
\-This function computes the force correction term (difference between full force of infinite lattice and nearest image) by \-Ewald summation. 

\-Definition at line 3495 of file forcetree.\-c.



\-Referenced by ewald\-\_\-init().


\begin{DoxyCode}
{
  double alpha, r2;
  double r, val, hdotx, dx[3];
  int i, h[3], n[3], h2;

  alpha = 2.0;

  for(i = 0; i < 3; i++)
    force[i] = 0;

  if(iii == 0 && jjj == 0 && kkk == 0)
    return;

  r2 = x[0] * x[0] + x[1] * x[1] + x[2] * x[2];

  for(i = 0; i < 3; i++)
    force[i] += x[i] / (r2 * sqrt(r2));

  for(n[0] = -4; n[0] <= 4; n[0]++)
    for(n[1] = -4; n[1] <= 4; n[1]++)
      for(n[2] = -4; n[2] <= 4; n[2]++)
        {
          for(i = 0; i < 3; i++)
            dx[i] = x[i] - n[i];

          r = sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);

          val = erfc(alpha * r) + 2 * alpha * r / sqrt(M_PI) * exp(-alpha * 
      alpha * r * r);

          for(i = 0; i < 3; i++)
            force[i] -= dx[i] / (r * r * r) * val;
        }

  for(h[0] = -4; h[0] <= 4; h[0]++)
    for(h[1] = -4; h[1] <= 4; h[1]++)
      for(h[2] = -4; h[2] <= 4; h[2]++)
        {
          hdotx = x[0] * h[0] + x[1] * h[1] + x[2] * h[2];
          h2 = h[0] * h[0] + h[1] * h[1] + h[2] * h[2];

          if(h2 > 0)
            {
              val = 2.0 / ((double) h2) * exp(-M_PI * M_PI * h2 / (alpha * 
      alpha)) * sin(2 * M_PI * hdotx);

              for(i = 0; i < 3; i++)
                force[i] -= h[i] * val;
            }
        }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a0c4d2bd0695737095313d7dc47ce120c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6}{\index{proto.\-h@{proto.\-h}!ewald\-\_\-init@{ewald\-\_\-init}}
\index{ewald\-\_\-init@{ewald\-\_\-init}!proto.h@{proto.\-h}}
\subsubsection[{ewald\-\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ewald\-\_\-init} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6}
\-This function initializes tables with the correction force and the correction potential due to the periodic images of a point mass located at the origin. \-These corrections are obtained by \-Ewald summation. (\-See \-Hernquist, \-Bouchet, \-Suto, \-Ap\-J\-S, 1991, 75, 231) \-The correction fields are used to obtain the full periodic force if periodic boundaries combined with the pure tree algorithm are used. \-For the \-Tree\-P\-M algorithm, the \-Ewald correction is not used.

\-The correction fields are stored on disk once they are computed. \-If a corresponding file is found, they are loaded from disk to speed up the initialization. \-The \-Ewald summation is done in parallel, i.\-e. the processors share the work to compute the tables if needed. 

\-Definition at line 3163 of file forcetree.\-c.



\-References \-All, \-E\-N, ewald\-\_\-force(), ewald\-\_\-psi(), fac\-\_\-intp, fcorrx, fcorry, fcorrz, fd, my\-\_\-fread(), my\-\_\-fwrite(), \-N\-Task, potcorr, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  int i, j, k, beg, len, size, n, task, count;
  double x[3], force[3];
  char buf[200];
  FILE *fd;

  if(ThisTask == 0)
    {
      printf("initialize Ewald correction...\n");
      fflush(stdout);
    }

#ifdef DOUBLEPRECISION
  sprintf(buf, "ewald_spc_table_%d_dbl.dat", EN);
#else
  sprintf(buf, "ewald_spc_table_%d.dat", EN);
#endif

  if((fd = fopen(buf, "r")))
    {
      if(ThisTask == 0)
        {
          printf("\nreading Ewald tables from file `%s'\n", buf);
          fflush(stdout);
        }

      my_fread(&fcorrx[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1),
       fd);
      my_fread(&fcorry[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1),
       fd);
      my_fread(&fcorrz[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1),
       fd);
      my_fread(&potcorr[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * (EN + 1)
      , fd);
      fclose(fd);
    }
  else
    {
      if(ThisTask == 0)
        {
          printf("\nNo Ewald tables in file `%s' found.\nRecomputing them...\n"
      , buf);
          fflush(stdout);
        }

      /* ok, let's recompute things. Actually, we do that in parallel. */

      size = (EN + 1) * (EN + 1) * (EN + 1) / NTask;


      beg = ThisTask * size;
      len = size;
      if(ThisTask == (NTask - 1))
        len = (EN + 1) * (EN + 1) * (EN + 1) - beg;

      for(i = 0, count = 0; i <= EN; i++)
        for(j = 0; j <= EN; j++)
          for(k = 0; k <= EN; k++)
            {
              n = (i * (EN + 1) + j) * (EN + 1) + k;
              if(n >= beg && n < (beg + len))
                {
                  if(ThisTask == 0)
                    {
                      if((count % (len / 20)) == 0)
                        {
                          printf("%4.1f percent done\n", count / (len / 100.0))
      ;
                          fflush(stdout);
                        }
                    }

                  x[0] = 0.5 * ((double) i) / EN;
                  x[1] = 0.5 * ((double) j) / EN;
                  x[2] = 0.5 * ((double) k) / EN;

                  ewald_force(i, j, k, x, force);

                  fcorrx[i][j][k] = force[0];
                  fcorry[i][j][k] = force[1];
                  fcorrz[i][j][k] = force[2];

                  if(i + j + k == 0)
                    potcorr[i][j][k] = 2.8372975;
                  else
                    potcorr[i][j][k] = ewald_psi(x);

                  count++;
                }
            }

      for(task = 0; task < NTask; task++)
        {
          beg = task * size;
          len = size;
          if(task == (NTask - 1))
            len = (EN + 1) * (EN + 1) * (EN + 1) - beg;

#ifdef DOUBLEPRECISION
          MPI_Bcast(&fcorrx[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorry[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorrz[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD);
          MPI_Bcast(&potcorr[0][0][beg], len, MPI_DOUBLE, task, MPI_COMM_WORLD)
      ;
#else
          MPI_Bcast(&fcorrx[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorry[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&fcorrz[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
          MPI_Bcast(&potcorr[0][0][beg], len, MPI_FLOAT, task, MPI_COMM_WORLD);
#endif
        }

      if(ThisTask == 0)
        {
          printf("\nwriting Ewald tables to file `%s'\n", buf);
          fflush(stdout);

          if((fd = fopen(buf, "w")))
            {
              my_fwrite(&fcorrx[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * 
      (EN + 1), fd);
              my_fwrite(&fcorry[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * 
      (EN + 1), fd);
              my_fwrite(&fcorrz[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) * 
      (EN + 1), fd);
              my_fwrite(&potcorr[0][0][0], sizeof(FLOAT), (EN + 1) * (EN + 1) *
       (EN + 1), fd);
              fclose(fd);
            }
        }
    }

  fac_intp = 2 * EN / All.BoxSize;

  for(i = 0; i <= EN; i++)
    for(j = 0; j <= EN; j++)
      for(k = 0; k <= EN; k++)
        {
          potcorr[i][j][k] /= All.BoxSize;
          fcorrx[i][j][k] /= All.BoxSize * All.BoxSize;
          fcorry[i][j][k] /= All.BoxSize * All.BoxSize;
          fcorrz[i][j][k] /= All.BoxSize * All.BoxSize;
        }

  if(ThisTask == 0)
    {
      printf("initialization of periodic boundaries finished.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{proto_8h_a47f99270d9b0b0f75d86b3b9d078dff6_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58}{\index{proto.\-h@{proto.\-h}!ewald\-\_\-pot\-\_\-corr@{ewald\-\_\-pot\-\_\-corr}}
\index{ewald\-\_\-pot\-\_\-corr@{ewald\-\_\-pot\-\_\-corr}!proto.h@{proto.\-h}}
\subsubsection[{ewald\-\_\-pot\-\_\-corr}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf ewald\-\_\-pot\-\_\-corr} (
\begin{DoxyParamCaption}
\item[{double}]{dx, }
\item[{double}]{dy, }
\item[{double}]{dz}
\end{DoxyParamCaption}
)}}\label{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58}
\-This function looks up the correction potential due to the infinite number of periodic particle/node images. \-We here use tri-\/linear interpolation to get it from the precomputed table, which contains one octant around the target particle at the origin. \-The other octants are obtained from it by exploiting symmetry properties. 

\-Definition at line 3401 of file forcetree.\-c.



\-References \-E\-N, fac\-\_\-intp, and potcorr.



\-Referenced by force\-\_\-treeevaluate\-\_\-potential().


\begin{DoxyCode}
{
  int i, j, k;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;

  if(dx < 0)
    dx = -dx;

  if(dy < 0)
    dy = -dy;

  if(dz < 0)
    dz = -dz;

  u = dx * fac_intp;
  i = (int) u;
  if(i >= EN)
    i = EN - 1;
  u -= i;
  v = dy * fac_intp;
  j = (int) v;
  if(j >= EN)
    j = EN - 1;
  v -= j;
  w = dz * fac_intp;
  k = (int) w;
  if(k >= EN)
    k = EN - 1;
  w -= k;

  f1 = (1 - u) * (1 - v) * (1 - w);
  f2 = (1 - u) * (1 - v) * (w);
  f3 = (1 - u) * (v) * (1 - w);
  f4 = (1 - u) * (v) * (w);
  f5 = (u) * (1 - v) * (1 - w);
  f6 = (u) * (1 - v) * (w);
  f7 = (u) * (v) * (1 - w);
  f8 = (u) * (v) * (w);

  return potcorr[i][j][k] * f1 +
    potcorr[i][j][k + 1] * f2 +
    potcorr[i][j + 1][k] * f3 +
    potcorr[i][j + 1][k + 1] * f4 +
    potcorr[i + 1][j][k] * f5 +
    potcorr[i + 1][j][k + 1] * f6 + potcorr[i + 1][j + 1][k] * f7 + potcorr[i +
       1][j + 1][k + 1] * f8;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aa0657e3de6bfb76715c14ddd72d25e58_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4a219224b239f0c20497e54ae421f134}{\index{proto.\-h@{proto.\-h}!ewald\-\_\-psi@{ewald\-\_\-psi}}
\index{ewald\-\_\-psi@{ewald\-\_\-psi}!proto.h@{proto.\-h}}
\subsubsection[{ewald\-\_\-psi}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf ewald\-\_\-psi} (
\begin{DoxyParamCaption}
\item[{double}]{x\mbox{[}3\mbox{]}}
\end{DoxyParamCaption}
)}}\label{proto_8h_a4a219224b239f0c20497e54ae421f134}
\-This function computes the potential correction term by means of \-Ewald summation. 

\-Definition at line 3454 of file forcetree.\-c.



\-Referenced by ewald\-\_\-init().


\begin{DoxyCode}
{
  double alpha, psi;
  double r, sum1, sum2, hdotx;
  double dx[3];
  int i, n[3], h[3], h2;

  alpha = 2.0;

  for(n[0] = -4, sum1 = 0; n[0] <= 4; n[0]++)
    for(n[1] = -4; n[1] <= 4; n[1]++)
      for(n[2] = -4; n[2] <= 4; n[2]++)
        {
          for(i = 0; i < 3; i++)
            dx[i] = x[i] - n[i];

          r = sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);
          sum1 += erfc(alpha * r) / r;
        }

  for(h[0] = -4, sum2 = 0; h[0] <= 4; h[0]++)
    for(h[1] = -4; h[1] <= 4; h[1]++)
      for(h[2] = -4; h[2] <= 4; h[2]++)
        {
          hdotx = x[0] * h[0] + x[1] * h[1] + x[2] * h[2];
          h2 = h[0] * h[0] + h[1] * h[1] + h[2] * h[2];
          if(h2 > 0)
            sum2 += 1 / (M_PI * h2) * exp(-M_PI * M_PI * h2 / (alpha * alpha)) 
      * cos(2 * M_PI * hdotx);
        }

  r = sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);

  psi = M_PI / (alpha * alpha) - sum1 - sum2 + 1 / r;

  return psi;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a4a219224b239f0c20497e54ae421f134_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a10281a87abe1e07d6ca603de6a533345}{\index{proto.\-h@{proto.\-h}!fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels@{fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels}}
\index{fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels@{fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels}!proto.h@{proto.\-h}}
\subsubsection[{fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a10281a87abe1e07d6ca603de6a533345}
\-This function associates a short 4-\/character block name with each block number. \-This is stored in front of each block for snapshot \-File\-Format=2. \-If one wants to add a new output-\/block, this function should be augmented accordingly. $<$ total number of defined information blocks for snapshot files. \-Must be equal to the number of entries in \char`\"{}enum iofields\char`\"{} 

\-Definition at line 566 of file io.\-c.



\-References \-Tab\-\_\-\-I\-O\-\_\-\-Labels.



\-Referenced by read\-\_\-ic(), and savepositions().


\begin{DoxyCode}
{
  enum iofields i;

  for(i = 0; i < IO_NBLOCKS; i++)
    switch (i)
      {
      case IO_POS:
        strncpy(Tab_IO_Labels[IO_POS], "POS ", 4);
        break;
      case IO_VEL:
        strncpy(Tab_IO_Labels[IO_VEL], "VEL ", 4);
        break;
      case IO_ID:
        strncpy(Tab_IO_Labels[IO_ID], "ID  ", 4);
        break;
      case IO_MASS:
        strncpy(Tab_IO_Labels[IO_MASS], "MASS", 4);
        break;
      case IO_U:
        strncpy(Tab_IO_Labels[IO_U], "U   ", 4);
        break;
      case IO_RHO:
        strncpy(Tab_IO_Labels[IO_RHO], "RHO ", 4);
        break;
      case IO_HSML:
        strncpy(Tab_IO_Labels[IO_HSML], "HSML", 4);
        break;
      case IO_POT:
        strncpy(Tab_IO_Labels[IO_POT], "POT ", 4);
        break;
      case IO_ACCEL:
        strncpy(Tab_IO_Labels[IO_ACCEL], "ACCE", 4);
        break;
      case IO_DTENTR:
        strncpy(Tab_IO_Labels[IO_DTENTR], "ENDT", 4);
        break;
      case IO_TSTP:
        strncpy(Tab_IO_Labels[IO_TSTP], "TSTP", 4);
        break;
      }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a10281a87abe1e07d6ca603de6a533345_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aea8fa222a10c4796687c6ff25550cd74}{\index{proto.\-h@{proto.\-h}!fill\-\_\-write\-\_\-buffer@{fill\-\_\-write\-\_\-buffer}}
\index{fill\-\_\-write\-\_\-buffer@{fill\-\_\-write\-\_\-buffer}!proto.h@{proto.\-h}}
\subsubsection[{fill\-\_\-write\-\_\-buffer}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf fill\-\_\-write\-\_\-buffer} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr, }
\item[{int $\ast$}]{startindex, }
\item[{int}]{pc, }
\item[{int}]{type}
\end{DoxyParamCaption}
)}}\label{proto_8h_aea8fa222a10c4796687c6ff25550cd74}
\-This function fills the write buffer with particle data. \-New output blocks can in principle be added here. $<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 

\-Definition at line 129 of file io.\-c.



\-References a3inv, \-All, box\-Size, \-Comm\-Buffer, dmax(), fac1, fac2, get\-\_\-gravkick\-\_\-factor(), get\-\_\-hydrokick\-\_\-factor(), \-P, pow(), and \-Sph\-P.



\-Referenced by write\-\_\-file().


\begin{DoxyCode}
{
  int n, k, pindex;
  float *fp;

#ifdef LONGIDS
  long long *ip;
#else
  int *ip;
#endif

#ifdef PERIODIC
  FLOAT boxSize;
#endif
#ifdef PMGRID
  double dt_gravkick_pm = 0;
#endif
  double dt_gravkick, dt_hydrokick, a3inv = 1, fac1, fac2;


  if(All.ComovingIntegrationOn)
    {
      a3inv = 1 / (All.Time * All.Time * All.Time);
      fac1 = 1 / (All.Time * All.Time);
      fac2 = 1 / pow(All.Time, 3 * GAMMA - 2);
    }
  else
    a3inv = fac1 = fac2 = 1;

#ifdef PMGRID
  if(All.ComovingIntegrationOn)
    dt_gravkick_pm =
      get_gravkick_factor(All.PM_Ti_begstep,
                          All.Ti_Current) -
      get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
  else
    dt_gravkick_pm = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep) 
      / 2) * All.Timebase_interval;
#endif



  fp = CommBuffer;
  ip = CommBuffer;

  pindex = *startindex;

  switch (blocknr)
    {
    case IO_POS:                /* positions */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            for(k = 0; k < 3; k++)
              {
                fp[k] = P[pindex].Pos[k];
#ifdef PERIODIC
                boxSize = All.BoxSize;
#ifdef LONG_X
                if(k == 0)
                  boxSize = All.BoxSize * LONG_X;
#endif
#ifdef LONG_Y
                if(k == 1)
                  boxSize = All.BoxSize * LONG_Y;
#endif
#ifdef LONG_Z
                if(k == 2)
                  boxSize = All.BoxSize * LONG_Z;
#endif
                while(fp[k] < 0)
                  fp[k] += boxSize;
                while(fp[k] >= boxSize)
                  fp[k] -= boxSize;
#endif
              }
            n++;
            fp += 3;
          }
      break;

    case IO_VEL:                /* velocities */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            if(All.ComovingIntegrationOn)
              {
                dt_gravkick =
                  get_gravkick_factor(P[pindex].Ti_begstep,
                                      All.Ti_Current) -
                  get_gravkick_factor(P[pindex].Ti_begstep,
                                      (P[pindex].Ti_begstep + P[pindex].
      Ti_endstep) / 2);
                dt_hydrokick =
                  get_hydrokick_factor(P[pindex].Ti_begstep,
                                       All.Ti_Current) -
                  get_hydrokick_factor(P[pindex].Ti_begstep,
                                       (P[pindex].Ti_begstep + P[pindex].
      Ti_endstep) / 2);
              }
            else
              dt_gravkick = dt_hydrokick =
                (All.Ti_Current - (P[pindex].Ti_begstep + P[pindex].Ti_endstep)
       / 2) * All.Timebase_interval;

            for(k = 0; k < 3; k++)
              {
                fp[k] = P[pindex].Vel[k] + P[pindex].GravAccel[k] * dt_gravkick
      ;
                if(P[pindex].Type == 0)
                  fp[k] += SphP[pindex].HydroAccel[k] * dt_hydrokick;
              }
#ifdef PMGRID
            for(k = 0; k < 3; k++)
              fp[k] += P[pindex].GravPM[k] * dt_gravkick_pm;
#endif
            for(k = 0; k < 3; k++)
              fp[k] *= sqrt(a3inv);

            n++;
            fp += 3;
          }
      break;

    case IO_ID:         /* particle ID */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *ip++ = P[pindex].ID;
            n++;
          }
      break;

    case IO_MASS:               /* particle mass */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = P[pindex].Mass;
            n++;
          }
      break;

    case IO_U:                  /* internal energy */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
#ifdef ISOTHERM_EQS
            *fp++ = SphP[pindex].Entropy;
#else
            *fp++ =
              dmax(All.MinEgySpec,
                   SphP[pindex].Entropy / GAMMA_MINUS1 * pow(SphP[pindex].
      Density * a3inv, GAMMA_MINUS1));
#endif
            n++;
          }
      break;

    case IO_RHO:                /* density */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = SphP[pindex].Density;
            n++;
          }
      break;

    case IO_HSML:               /* SPH smoothing length */
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = SphP[pindex].Hsml;
            n++;
          }
      break;


    case IO_POT:                /* gravitational potential */
#ifdef OUTPUTPOTENTIAL
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = P[pindex].Potential;
            n++;
          }
#endif
      break;

    case IO_ACCEL:              /* acceleration */
#ifdef OUTPUTACCELERATION
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            for(k = 0; k < 3; k++)
              fp[k] = fac1 * P[pindex].GravAccel[k];
#ifdef PMGRID
            for(k = 0; k < 3; k++)
              fp[k] += fac1 * P[pindex].GravPM[k];
#endif
            if(P[pindex].Type == 0)
              for(k = 0; k < 3; k++)
                fp[k] += fac2 * SphP[pindex].HydroAccel[k];
            fp += 3;
            n++;
          }
#endif
      break;

    case IO_DTENTR:             /* rate of change of entropy */
#ifdef OUTPUTCHANGEOFENTROPY
      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = SphP[pindex].DtEntropy;
            n++;
          }
#endif
      break;

    case IO_TSTP:               /* timestep  */
#ifdef OUTPUTTIMESTEP

      for(n = 0; n < pc; pindex++)
        if(P[pindex].Type == type)
          {
            *fp++ = (P[pindex].Ti_endstep - P[pindex].Ti_begstep) * All.
      Timebase_interval;
            n++;
          }
#endif
      break;

    }

  *startindex = pindex;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_aea8fa222a10c4796687c6ff25550cd74_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aea8fa222a10c4796687c6ff25550cd74_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a78ed439b8a1cb93647a2b9de998d9269}{\index{proto.\-h@{proto.\-h}!find\-\_\-dt\-\_\-displacement\-\_\-constraint@{find\-\_\-dt\-\_\-displacement\-\_\-constraint}}
\index{find\-\_\-dt\-\_\-displacement\-\_\-constraint@{find\-\_\-dt\-\_\-displacement\-\_\-constraint}!proto.h@{proto.\-h}}
\subsubsection[{find\-\_\-dt\-\_\-displacement\-\_\-constraint}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf find\-\_\-dt\-\_\-displacement\-\_\-constraint} (
\begin{DoxyParamCaption}
\item[{double}]{hfac}
\end{DoxyParamCaption}
)}}\label{proto_8h_a78ed439b8a1cb93647a2b9de998d9269}
\-This function computes an upper limit ('dt\-\_\-displacement') to the global timestep of the system based on the rms velocities of particles. \-For cosmological simulations, the criterion used is that the rms displacement should be at most a fraction \-Max\-R\-M\-S\-Displacement\-Fac of the mean particle separation. \-Note that the latter is estimated using the assigned particle masses, separately for each particle type. \-If comoving integration is not used, the function imposes no constraint on the timestep. 
\begin{DoxyParams}{\-Parameters}
{\em hfac} & should be a$^\wedge$2$\ast$\-H(a) \\
\hline
\end{DoxyParams}


\-Definition at line 579 of file timestep.\-c.



\-References \-All, dt\-\_\-displacement, \-N\-Task, \-Num\-Part, \-P, pow(), and \-This\-Task.



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps().


\begin{DoxyCode}
{
  int i, j, type, *temp;
  int count[6];
  long long count_sum[6];
  double v[6], v_sum[6], mim[6], min_mass[6];
  double dt, dmean, asmth = 0;

  dt_displacement = All.MaxSizeTimestep;

  if(All.ComovingIntegrationOn)
    {
      for(type = 0; type < 6; type++)
        {
          count[type] = 0;
          v[type] = 0;
          mim[type] = 1.0e30;
        }

      for(i = 0; i < NumPart; i++)
        {
          v[P[i].Type] += P[i].Vel[0] * P[i].Vel[0] + P[i].Vel[1] * P[i].Vel[1]
       + P[i].Vel[2] * P[i].Vel[2];
          if(mim[P[i].Type] > P[i].Mass)
            mim[P[i].Type] = P[i].Mass;
          count[P[i].Type]++;
        }

      MPI_Allreduce(v, v_sum, 6, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
      MPI_Allreduce(mim, min_mass, 6, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

      temp = malloc(NTask * 6 * sizeof(int));
      MPI_Allgather(count, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
      for(i = 0; i < 6; i++)
        {
          count_sum[i] = 0;
          for(j = 0; j < NTask; j++)
            count_sum[i] += temp[j * 6 + i];
        }
      free(temp);

      for(type = 0; type < 6; type++)
        {
          if(count_sum[type] > 0)
            {
              if(type == 0)
                dmean =
                  pow(min_mass[type] / (All.OmegaBaryon * 3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G)),
                      1.0 / 3);
              else
                dmean =
                  pow(min_mass[type] /
                      ((All.Omega0 - All.OmegaBaryon) * 3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G)),
                      1.0 / 3);

              dt = All.MaxRMSDisplacementFac * hfac * dmean / sqrt(v_sum[type] 
      / count_sum[type]);

#ifdef PMGRID
              asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
              if(((1 << type) & (PLACEHIGHRESREGION)))
                asmth = All.Asmth[1];
#endif
              if(asmth < dmean)
                dt = All.MaxRMSDisplacementFac * hfac * asmth / sqrt(v_sum[type
      ] / count_sum[type]);
#endif

              if(ThisTask == 0)
                printf("type=%d  dmean=%g asmth=%g minmass=%g a=%g 
       sqrt(<p^2>)=%g  dlogmax=%g\n",
                       type, dmean, asmth, min_mass[type], All.Time, sqrt(v_sum
      [type] / count_sum[type]), dt);

              if(dt < dt_displacement)
                dt_displacement = dt;
            }
        }

      if(ThisTask == 0)
        printf("displacement time constraint: %g  (%g)\n", dt_displacement, All
      .MaxSizeTimestep);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_a78ed439b8a1cb93647a2b9de998d9269_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a78ed439b8a1cb93647a2b9de998d9269_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac028b474d53a40e79377b7ae5dde636a}{\index{proto.\-h@{proto.\-h}!find\-\_\-files@{find\-\_\-files}}
\index{find\-\_\-files@{find\-\_\-files}!proto.h@{proto.\-h}}
\subsubsection[{find\-\_\-files}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf find\-\_\-files} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{proto_8h_ac028b474d53a40e79377b7ae5dde636a}
\-This function determines onto how many files a given snapshot is distributed. 

\-Definition at line 615 of file read\-\_\-ic.\-c.



\-References \-All, endrun(), fd, header, read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5(), and \-This\-Task.



\-Referenced by read\-\_\-ic().


\begin{DoxyCode}
{
  FILE *fd;
  char buf[200], buf1[200];
  int dummy;

  sprintf(buf, "%s.%d", fname, 0);
  sprintf(buf1, "%s", fname);

  if(All.ICFormat == 3)
    {
      sprintf(buf, "%s.%d.hdf5", fname, 0);
      sprintf(buf1, "%s.hdf5", fname);
    }

#ifndef  HAVE_HDF5
  if(All.ICFormat == 3)
    {
      if(ThisTask == 0)
        printf("Code wasn't compiled with HDF5 support enabled!\n");
      endrun(0);
    }
#endif

  header.num_files = 0;

  if(ThisTask == 0)
    {
      if((fd = fopen(buf, "r")))
        {
          if(All.ICFormat == 1 || All.ICFormat == 2)
            {
              if(All.ICFormat == 2)
                {
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                }

              fread(&dummy, sizeof(dummy), 1, fd);
              fread(&header, sizeof(header), 1, fd);
              fread(&dummy, sizeof(dummy), 1, fd);
            }
          fclose(fd);

#ifdef HAVE_HDF5
          if(All.ICFormat == 3)
            read_header_attributes_in_hdf5(buf);
#endif
        }
    }

  MPI_Bcast(&header, sizeof(header), MPI_BYTE, 0, MPI_COMM_WORLD);

  if(header.num_files > 0)
    return header.num_files;

  if(ThisTask == 0)
    {
      if((fd = fopen(buf1, "r")))
        {
          if(All.ICFormat == 1 || All.ICFormat == 2)
            {
              if(All.ICFormat == 2)
                {
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                  fread(&dummy, sizeof(dummy), 1, fd);
                }

              fread(&dummy, sizeof(dummy), 1, fd);
              fread(&header, sizeof(header), 1, fd);
              fread(&dummy, sizeof(dummy), 1, fd);
            }
          fclose(fd);

#ifdef HAVE_HDF5
          if(All.ICFormat == 3)
            read_header_attributes_in_hdf5(buf1);
#endif
          header.num_files = 1;
        }
    }

  MPI_Bcast(&header, sizeof(header), MPI_BYTE, 0, MPI_COMM_WORLD);

  if(header.num_files > 0)
    return header.num_files;

  if(ThisTask == 0)
    {
      printf("\nCan't find initial conditions file.");
      printf("neither as '%s'\nnor as '%s'\n", buf, buf1);
      fflush(stdout);
    }

  endrun(0);
  return 0;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac028b474d53a40e79377b7ae5dde636a_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac028b474d53a40e79377b7ae5dde636a_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a532b4637166ab194c1b1d0dee9f003f2}{\index{proto.\-h@{proto.\-h}!find\-\_\-next\-\_\-outputtime@{find\-\_\-next\-\_\-outputtime}}
\index{find\-\_\-next\-\_\-outputtime@{find\-\_\-next\-\_\-outputtime}!proto.h@{proto.\-h}}
\subsubsection[{find\-\_\-next\-\_\-outputtime}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf find\-\_\-next\-\_\-outputtime} (
\begin{DoxyParamCaption}
\item[{int}]{ti\-\_\-curr}
\end{DoxyParamCaption}
)}}\label{proto_8h_a532b4637166ab194c1b1d0dee9f003f2}
this function returns the next output time that is equal or larger to ti\-\_\-curr $<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29 

\-Definition at line 244 of file run.\-c.



\-References \-All, endrun(), and \-This\-Task.



\-Referenced by begrun(), and find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift().


\begin{DoxyCode}
{
  int i, ti, ti_next, iter = 0;
  double next, time;

  ti_next = -1;

  if(All.OutputListOn)
    {
      for(i = 0; i < All.OutputListLength; i++)
        {
          time = All.OutputListTimes[i];

          if(time >= All.TimeBegin && time <= All.TimeMax)
            {
              if(All.ComovingIntegrationOn)
                ti = log(time / All.TimeBegin) / All.Timebase_interval;
              else
                ti = (time - All.TimeBegin) / All.Timebase_interval;

              if(ti >= ti_curr)
                {
                  if(ti_next == -1)
                    ti_next = ti;

                  if(ti_next > ti)
                    ti_next = ti;
                }
            }
        }
    }
  else
    {
      if(All.ComovingIntegrationOn)
        {
          if(All.TimeBetSnapshot <= 1.0)
            {
              printf("TimeBetSnapshot > 1.0 required for your simulation.\n");
              endrun(13123);
            }
        }
      else
        {
          if(All.TimeBetSnapshot <= 0.0)
            {
              printf("TimeBetSnapshot > 0.0 required for your simulation.\n");
              endrun(13123);
            }
        }

      time = All.TimeOfFirstSnapshot;

      iter = 0;

      while(time < All.TimeBegin)
        {
          if(All.ComovingIntegrationOn)
            time *= All.TimeBetSnapshot;
          else
            time += All.TimeBetSnapshot;

          iter++;

          if(iter > 1000000)
            {
              printf("Can't determine next output time.\n");
              endrun(110);
            }
        }

      while(time <= All.TimeMax)
        {
          if(All.ComovingIntegrationOn)
            ti = log(time / All.TimeBegin) / All.Timebase_interval;
          else
            ti = (time - All.TimeBegin) / All.Timebase_interval;

          if(ti >= ti_curr)
            {
              ti_next = ti;
              break;
            }

          if(All.ComovingIntegrationOn)
            time *= All.TimeBetSnapshot;
          else
            time += All.TimeBetSnapshot;

          iter++;

          if(iter > 1000000)
            {
              printf("Can't determine next output time.\n");
              endrun(111);
            }
        }
    }

  if(ti_next == -1)
    {
      ti_next = 2 * TIMEBASE;   /* this will prevent any further output */

      if(ThisTask == 0)
        printf("\nThere is no valid time for a further snapshot file.\n");
    }
  else
    {
      if(All.ComovingIntegrationOn)
        next = All.TimeBegin * exp(ti_next * All.Timebase_interval);
      else
        next = All.TimeBegin + ti_next * All.Timebase_interval;

      if(ThisTask == 0)
        printf("\nSetting next time for snapshot file to Time_next= %g\n\n", 
      next);
    }

  return ti_next;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a532b4637166ab194c1b1d0dee9f003f2_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a532b4637166ab194c1b1d0dee9f003f2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad52604af910b3e1677718d863ab09391}{\index{proto.\-h@{proto.\-h}!find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift@{find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift}}
\index{find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift@{find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift}!proto.h@{proto.\-h}}
\subsubsection[{find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad52604af910b3e1677718d863ab09391}
\-This function finds the next synchronization point of the system (i.\-e. the earliest point of time any of the particles needs a force computation), and drifts the system to this point of time. \-If the system drifts over the desired time of a snapshot file, the function will drift to this moment, generate an output, and then resume the drift. 

\-Definition at line 151 of file run.\-c.



\-References \-All, compute\-\_\-potential(), domain\-\_\-\-Decomposition(), find\-\_\-next\-\_\-outputtime(), \-Flag\-\_\-\-Full\-Step, move\-\_\-particles(), \-N\-Task, \-Num\-Force\-Update, \-Num\-Part, \-P, savepositions(), second(), and timediff().



\-Referenced by run().


\begin{DoxyCode}
{
  int n, min, min_glob, flag, *temp;
  double timeold;
  double t0, t1;

  t0 = second();

  timeold = All.Time;

  for(n = 1, min = P[0].Ti_endstep; n < NumPart; n++)
    if(min > P[n].Ti_endstep)
      min = P[n].Ti_endstep;

  MPI_Allreduce(&min, &min_glob, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);

  /* We check whether this is a full step where all particles are synchronized 
      */
  flag = 1;
  for(n = 0; n < NumPart; n++)
    if(P[n].Ti_endstep > min_glob)
      flag = 0;

  MPI_Allreduce(&flag, &Flag_FullStep, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);

#ifdef PMGRID
  if(min_glob >= All.PM_Ti_endstep)
    {
      min_glob = All.PM_Ti_endstep;
      Flag_FullStep = 1;
    }
#endif

  /* Determine 'NumForceUpdate', i.e. the number of particles on this processor
       that are going to be active */
  for(n = 0, NumForceUpdate = 0; n < NumPart; n++)
    {
      if(P[n].Ti_endstep == min_glob)
#ifdef SELECTIVE_NO_GRAVITY
        if(!((1 << P[n].Type) & (SELECTIVE_NO_GRAVITY)))
#endif
          NumForceUpdate++;
    }

  /* note: NumForcesSinceLastDomainDecomp has type "long long" */
  temp = malloc(NTask * sizeof(int));
  MPI_Allgather(&NumForceUpdate, 1, MPI_INT, temp, 1, MPI_INT, MPI_COMM_WORLD);
  for(n = 0; n < NTask; n++)
    All.NumForcesSinceLastDomainDecomp += temp[n];
  free(temp);



  t1 = second();

  All.CPU_Predict += timediff(t0, t1);

  while(min_glob >= All.Ti_nextoutput && All.Ti_nextoutput >= 0)
    {
      move_particles(All.Ti_Current, All.Ti_nextoutput);

      All.Ti_Current = All.Ti_nextoutput;

      if(All.ComovingIntegrationOn)
        All.Time = All.TimeBegin * exp(All.Ti_Current * All.Timebase_interval);
      else
        All.Time = All.TimeBegin + All.Ti_Current * All.Timebase_interval;

#ifdef OUTPUTPOTENTIAL
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
      domain_Decomposition();
      compute_potential();
#endif
      savepositions(All.SnapshotFileCount++);   /* write snapshot file */

      All.Ti_nextoutput = find_next_outputtime(All.Ti_nextoutput + 1);
    }

  move_particles(All.Ti_Current, min_glob);

  All.Ti_Current = min_glob;

  if(All.ComovingIntegrationOn)
    All.Time = All.TimeBegin * exp(All.Ti_Current * All.Timebase_interval);
  else
    All.Time = All.TimeBegin + All.Ti_Current * All.Timebase_interval;

  All.TimeStep = All.Time - timeold;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad52604af910b3e1677718d863ab09391_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad52604af910b3e1677718d863ab09391_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8eaedfa5c6d72bca79b465003679ed89}{\index{proto.\-h@{proto.\-h}!force\-\_\-create\-\_\-empty\-\_\-nodes@{force\-\_\-create\-\_\-empty\-\_\-nodes}}
\index{force\-\_\-create\-\_\-empty\-\_\-nodes@{force\-\_\-create\-\_\-empty\-\_\-nodes}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-create\-\_\-empty\-\_\-nodes}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-create\-\_\-empty\-\_\-nodes} (
\begin{DoxyParamCaption}
\item[{int}]{no, }
\item[{int}]{topnode, }
\item[{int}]{bits, }
\item[{int}]{x, }
\item[{int}]{y, }
\item[{int}]{z, }
\item[{int $\ast$}]{nodecount, }
\item[{int $\ast$}]{nextfree}
\end{DoxyParamCaption}
)}}\label{proto_8h_a8eaedfa5c6d72bca79b465003679ed89}
\-This function recursively creates a set of empty tree nodes which corresponds to the top-\/level tree for the domain grid. \-This is done to ensure that this top-\/level tree is always \char`\"{}complete\char`\"{} so that we can easily associate the pseudo-\/particles of other \-C\-P\-Us with tree-\/nodes at a given level in the tree, even when the particle population is so sparse that some of these nodes are actually empty. 

\-Definition at line 292 of file forcetree.\-c.



\-References \-Domain\-Node\-Index, dump\-\_\-particles(), endrun(), force\-\_\-create\-\_\-empty\-\_\-nodes(), \-Max\-Nodes, \-Nodes, peano\-\_\-hilbert\-\_\-key(), \-This\-Task, and \-Top\-Nodes.



\-Referenced by force\-\_\-create\-\_\-empty\-\_\-nodes(), and force\-\_\-treebuild\-\_\-single().


\begin{DoxyCode}
{
  int i, j, k, n, sub, count;

  if(TopNodes[topnode].Daughter >= 0)
    {
      for(i = 0; i < 2; i++)
        for(j = 0; j < 2; j++)
          for(k = 0; k < 2; k++)
            {
              sub = 7 & peano_hilbert_key((x << 1) + i, (y << 1) + j, (z << 1) 
      + k, bits);

              count = i + 2 * j + 4 * k;

              Nodes[no].u.suns[count] = *nextfree;


              Nodes[*nextfree].len = 0.5 * Nodes[no].len;
              Nodes[*nextfree].center[0] = Nodes[no].center[0] + (2 * i - 1) * 
      0.25 * Nodes[no].len;
              Nodes[*nextfree].center[1] = Nodes[no].center[1] + (2 * j - 1) * 
      0.25 * Nodes[no].len;
              Nodes[*nextfree].center[2] = Nodes[no].center[2] + (2 * k - 1) * 
      0.25 * Nodes[no].len;

              for(n = 0; n < 8; n++)
                Nodes[*nextfree].u.suns[n] = -1;

              if(TopNodes[TopNodes[topnode].Daughter + sub].Daughter == -1)
                DomainNodeIndex[TopNodes[TopNodes[topnode].Daughter + sub].Leaf
      ] = *nextfree;

              *nextfree = *nextfree + 1;
              *nodecount = *nodecount + 1;

              if((*nodecount) >= MaxNodes)
                {
                  printf("task %d: maximum number %d of tree-nodes reached.\n",
       ThisTask, MaxNodes);
                  printf("in create empty nodes\n");
                  dump_particles();
                  endrun(11);
                }

              force_create_empty_nodes(*nextfree - 1, TopNodes[topnode].
      Daughter + sub,
                                       bits + 1, 2 * x + i, 2 * y + j, 2 * z + 
      k, nodecount, nextfree);
            }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a8eaedfa5c6d72bca79b465003679ed89_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a8eaedfa5c6d72bca79b465003679ed89_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb}{\index{proto.\-h@{proto.\-h}!force\-\_\-exchange\-\_\-pseudodata@{force\-\_\-exchange\-\_\-pseudodata}}
\index{force\-\_\-exchange\-\_\-pseudodata@{force\-\_\-exchange\-\_\-pseudodata}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-exchange\-\_\-pseudodata}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-exchange\-\_\-pseudodata} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb}
\-This function communicates the values of the multipole moments of the top-\/level tree-\/nodes of the domain grid. \-This data can then be used to update the pseudo-\/particles on each \-C\-P\-U accordingly. 

\-Definition at line 684 of file forcetree.\-c.



\-References \-Domain\-End\-List, \-Domain\-Moment, \-Domain\-My\-Last, \-Domain\-My\-Start, \-Domain\-Node\-Index, \-Domain\-Start\-List, \-Extnodes, \-Nodes, \-N\-Task, \-P\-Task, \-T\-A\-G\-\_\-\-D\-M\-O\-M, and \-This\-Task.



\-Referenced by force\-\_\-update\-\_\-pseudoparticles().


\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      /* read out the multipole moments from the local base cells */
      DomainMoment[i].s[0] = Nodes[no].u.d.s[0];
      DomainMoment[i].s[1] = Nodes[no].u.d.s[1];
      DomainMoment[i].s[2] = Nodes[no].u.d.s[2];
      DomainMoment[i].vs[0] = Extnodes[no].vs[0];
      DomainMoment[i].vs[1] = Extnodes[no].vs[1];
      DomainMoment[i].vs[2] = Extnodes[no].vs[2];
      DomainMoment[i].mass = Nodes[no].u.d.mass;
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      DomainMoment[i].bitflags = Nodes[no].u.d.bitflags;
#else
      DomainMoment[i].maxsoft = Nodes[no].maxsoft;
#endif
#endif
    }

  /* share the pseudo-particle data accross CPUs */

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainMoment[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) 
      * sizeof(struct DomainNODE),
                     MPI_BYTE, recvTask, TAG_DMOM,
                     &DomainMoment[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) 
      * sizeof(struct DomainNODE),
                     MPI_BYTE, recvTask, TAG_DMOM, MPI_COMM_WORLD, &status);
    }

}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aaabf16b5e99c9ac6bc6bbe039756bddb_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a947a734f3bbba14d4092c7480880d3c7}{\index{proto.\-h@{proto.\-h}!force\-\_\-flag\-\_\-localnodes@{force\-\_\-flag\-\_\-localnodes}}
\index{force\-\_\-flag\-\_\-localnodes@{force\-\_\-flag\-\_\-localnodes}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-flag\-\_\-localnodes}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-flag\-\_\-localnodes} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a947a734f3bbba14d4092c7480880d3c7}
\-This function flags nodes in the top-\/level tree that are dependent on local particle data. 

\-Definition at line 834 of file forcetree.\-c.



\-References \-Domain\-My\-Last, \-Domain\-My\-Start, \-Domain\-Node\-Index, \-Nodes, and \-N\-Topleaves.



\-Referenced by force\-\_\-treebuild().


\begin{DoxyCode}
{
  int no, i;

  /* mark all top-level nodes */

  for(i = 0; i < NTopleaves; i++)
    {
      no = DomainNodeIndex[i];

      while(no >= 0)
        {
          if((Nodes[no].u.d.bitflags & 1))
            break;

          Nodes[no].u.d.bitflags |= 1;

          no = Nodes[no].u.d.father;
        }
    }

  /* mark top-level nodes that contain local particles */

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      /*
         if(DomainMoment[i].mass > 0)
       */
      {
        no = DomainNodeIndex[i];

        while(no >= 0)
          {
            if((Nodes[no].u.d.bitflags & 2))
              break;

            Nodes[no].u.d.bitflags |= 2;

            no = Nodes[no].u.d.father;
          }
      }
    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a947a734f3bbba14d4092c7480880d3c7_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad9e0a57b7577d64a315c142e197d292d}{\index{proto.\-h@{proto.\-h}!force\-\_\-insert\-\_\-pseudo\-\_\-particles@{force\-\_\-insert\-\_\-pseudo\-\_\-particles}}
\index{force\-\_\-insert\-\_\-pseudo\-\_\-particles@{force\-\_\-insert\-\_\-pseudo\-\_\-particles}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-insert\-\_\-pseudo\-\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-insert\-\_\-pseudo\-\_\-particles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad9e0a57b7577d64a315c142e197d292d}
this function inserts pseudo-\/particles which will represent the mass distribution of the other \-C\-P\-Us. \-Initially, the mass of the pseudo-\/particles is set to zero, and their coordinate is set to the center of the domain-\/cell they correspond to. \-These quantities will be updated later on. 

\-Definition at line 346 of file forcetree.\-c.



\-References \-All, \-Domain\-Moment, \-Domain\-My\-Last, \-Domain\-Node\-Index, endrun(), \-Max\-Nodes, \-Nodes, and \-N\-Topleaves.



\-Referenced by force\-\_\-treebuild\-\_\-single().


\begin{DoxyCode}
{
  int i, index, subnode, nn, th;

  for(i = 0; i < NTopleaves; i++)
    {
      index = DomainNodeIndex[i];

      DomainMoment[i].mass = 0;
      DomainMoment[i].s[0] = Nodes[index].center[0];
      DomainMoment[i].s[1] = Nodes[index].center[1];
      DomainMoment[i].s[2] = Nodes[index].center[2];
    }

  for(i = 0; i < NTopleaves; i++)
    {
      if(i < DomainMyStart || i > DomainMyLast)
        {
          th = All.MaxPart;     /* select index of first node in tree */

          while(1)
            {
              if(th >= All.MaxPart)     /* we are dealing with an internal node
       */
                {
                  if(th >= All.MaxPart + MaxNodes)
                    endrun(888);        /* this can't be */

                  subnode = 0;
                  if(DomainMoment[i].s[0] > Nodes[th].center[0])
                    subnode += 1;
                  if(DomainMoment[i].s[1] > Nodes[th].center[1])
                    subnode += 2;
                  if(DomainMoment[i].s[2] > Nodes[th].center[2])
                    subnode += 4;

                  nn = Nodes[th].u.suns[subnode];

                  if(nn >= 0)   /* ok, something is in the daughter slot
       already, need to continue */
                    {
                      th = nn;
                    }
                  else
                    {
                      /* here we have found an empty slot where we can 
                       * attach the pseudo particle as a leaf 
                       */
                      Nodes[th].u.suns[subnode] = All.MaxPart + MaxNodes + i;

                      break;    /* done for this pseudo particle */
                    }
                }
              else
                {
                  endrun(889);  /* this can't be */
                }
            }
        }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad9e0a57b7577d64a315c142e197d292d_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad9e0a57b7577d64a315c142e197d292d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae809fba68f599de9874f593b77d0bbfd}{\index{proto.\-h@{proto.\-h}!force\-\_\-setupnonrecursive@{force\-\_\-setupnonrecursive}}
\index{force\-\_\-setupnonrecursive@{force\-\_\-setupnonrecursive}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-setupnonrecursive}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-setupnonrecursive} (
\begin{DoxyParamCaption}
\item[{int}]{no}
\end{DoxyParamCaption}
)}}\label{proto_8h_ae809fba68f599de9874f593b77d0bbfd}
\hypertarget{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeallocate@{force\-\_\-treeallocate}}
\index{force\-\_\-treeallocate@{force\-\_\-treeallocate}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeallocate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-treeallocate} (
\begin{DoxyParamCaption}
\item[{int}]{maxnodes, }
\item[{int}]{maxpart}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2}
\-This function allocates the memory used for storage of the tree and of auxiliary arrays needed for tree-\/walk and link-\/lists. \-Usually, maxnodes approximately equal to 0.\-7$\ast$maxpart is sufficient to store the tree for up to maxpart particles. $<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition 

\-Definition at line 2911 of file forcetree.\-c.



\-References \-All, endrun(), \-Extnodes, \-Extnodes\-\_\-base, \-Father, first\-\_\-flag, \-Max\-Nodes, \-Nextnode, \-Nodes, \-Nodes\-\_\-base, \-N\-T\-A\-B, shortrange\-\_\-table, shortrange\-\_\-table\-\_\-potential, tabfac, and \-This\-Task.



\-Referenced by init(), pmforce\-\_\-periodic(), pmpotential\-\_\-periodic(), and restart().


\begin{DoxyCode}
{
  int i;
  size_t bytes;
  double allbytes = 0;
  double u;

  MaxNodes = maxnodes;

  if(!(Nodes_base = malloc(bytes = (MaxNodes + 1) * sizeof(struct NODE))))
    {
      printf("failed to allocate memory for %d tree-nodes (%g MB).\n", MaxNodes
      , bytes / (1024.0 * 1024.0));
      endrun(3);
    }
  allbytes += bytes;

  if(!(Extnodes_base = malloc(bytes = (MaxNodes + 1) * sizeof(struct extNODE)))
      )
    {
      printf("failed to allocate memory for %d tree-extnodes (%g MB).\n", 
      MaxNodes,
             bytes / (1024.0 * 1024.0));
      endrun(3);
    }
  allbytes += bytes;

  Nodes = Nodes_base - All.MaxPart;
  Extnodes = Extnodes_base - All.MaxPart;

  if(!(Nextnode = malloc(bytes = (maxpart + MAXTOPNODES) * sizeof(int))))
    {
      printf("Failed to allocate %d spaces for 'Nextnode' array (%g MB)\n", 
      maxpart + MAXTOPNODES,
             bytes / (1024.0 * 1024.0));
      exit(0);
    }
  allbytes += bytes;

  if(!(Father = malloc(bytes = (maxpart) * sizeof(int))))
    {
      printf("Failed to allocate %d spaces for 'Father' array (%g MB)\n", 
      maxpart, bytes / (1024.0 * 1024.0));
      exit(0);
    }
  allbytes += bytes;

  if(first_flag == 0)
    {
      first_flag = 1;

      if(ThisTask == 0)
        printf("\nAllocated %g MByte for BH-tree. %lu\n\n", allbytes / (1024.0 
      * 1024.0),
               sizeof(struct NODE) + sizeof(struct extNODE));

      tabfac = NTAB / 3.0;

      for(i = 0; i < NTAB; i++)
        {
          u = 3.0 / NTAB * (i + 0.5);
          shortrange_table[i] = erfc(u) + 2.0 * u / sqrt(M_PI) * exp(-u * u);
          shortrange_table_potential[i] = erfc(u);
        }
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab98788ba31869c7bc55ce71b807d2ff2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a10f92098e86f82baec9f84a283f4c9e5}{\index{proto.\-h@{proto.\-h}!force\-\_\-treebuild@{force\-\_\-treebuild}}
\index{force\-\_\-treebuild@{force\-\_\-treebuild}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treebuild}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf force\-\_\-treebuild} (
\begin{DoxyParamCaption}
\item[{int}]{npart}
\end{DoxyParamCaption}
)}}\label{proto_8h_a10f92098e86f82baec9f84a283f4c9e5}
\-This function is a driver routine for constructing the gravitational oct-\/tree, which is done by calling a small number of other functions. 

\-Definition at line 61 of file forcetree.\-c.



\-References \-All, force\-\_\-flag\-\_\-localnodes(), force\-\_\-treebuild\-\_\-single(), force\-\_\-update\-\_\-pseudoparticles(), \-Numnodestree, and \-Time\-Of\-Last\-Tree\-Construction.



\-Referenced by compute\-\_\-potential(), gravity\-\_\-tree(), and ngb\-\_\-treebuild().


\begin{DoxyCode}
{
  Numnodestree = force_treebuild_single(npart);

  force_update_pseudoparticles();

  force_flag_localnodes();

  TimeOfLastTreeConstruction = All.Time;

  return Numnodestree;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a10f92098e86f82baec9f84a283f4c9e5_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a10f92098e86f82baec9f84a283f4c9e5_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6}{\index{proto.\-h@{proto.\-h}!force\-\_\-treebuild\-\_\-single@{force\-\_\-treebuild\-\_\-single}}
\index{force\-\_\-treebuild\-\_\-single@{force\-\_\-treebuild\-\_\-single}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treebuild\-\_\-single}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf force\-\_\-treebuild\-\_\-single} (
\begin{DoxyParamCaption}
\item[{int}]{npart}
\end{DoxyParamCaption}
)}}\label{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6}
\-Constructs the gravitational oct-\/tree.

\-The index convention for accessing tree nodes is the following\-: the indices 0...\-Num\-Part-\/1 reference single particles, the indices \-All.\-Max\-Part.... \-All.\-Max\-Part+nodes-\/1 reference tree nodes. `\-Nodes\-\_\-base' points to the first tree node, while `nodes' is shifted such that nodes\mbox{[}\-All.\-Max\-Part\mbox{]} gives the first tree node. \-Finally, node indices with values '\-All.\-Max\-Part + \-Max\-Nodes' and larger indicate \char`\"{}pseudo
  particles\char`\"{}, i.\-e. multipole moments of top-\/level nodes that lie on different \-C\-P\-Us. \-If such a node needs to be opened, the corresponding particle must be exported to that \-C\-P\-U. \-The '\-Extnodes' structure parallels that of '\-Nodes'. \-Its information is only needed for the \-S\-P\-H part of the computation. (\-The data is split onto these two structures as a tuning measure. \-If it is merged into '\-Nodes' a somewhat bigger size of the nodes also for gravity would result, which would reduce cache utilization slightly. $<$ \-Bits per dimension available for \-Peano-\/\-Hilbert order. \-Note\-: \-If peanokey is defined as type int, the allowed maximum is 10. \-If 64-\/bit integers are used, the maximum is 21 

\-Definition at line 93 of file forcetree.\-c.



\-References \-All, \-Domain\-Center, \-Domain\-Corner, \-Domain\-Fac, \-Domain\-Len, \-Domain\-Node\-Index, dump\-\_\-particles(), endrun(), force\-\_\-create\-\_\-empty\-\_\-nodes(), force\-\_\-insert\-\_\-pseudo\-\_\-particles(), force\-\_\-update\-\_\-node\-\_\-recursive(), get\-\_\-random\-\_\-number(), last, \-Max\-Nodes, \-Nextnode, \-Nodes, \-P, peano\-\_\-hilbert\-\_\-key(), \-This\-Task, and \-Top\-Nodes.



\-Referenced by force\-\_\-treebuild().


\begin{DoxyCode}
{
  int i, j, subnode = 0, parent, numnodes;
  int nfree, th, nn, no;
  struct NODE *nfreep;
  double lenhalf, epsilon;
  peanokey key;


  /* create an empty root node  */
  nfree = All.MaxPart;          /* index of first free node */
  nfreep = &Nodes[nfree];       /* select first node */

  nfreep->len = DomainLen;
  for(j = 0; j < 3; j++)
    nfreep->center[j] = DomainCenter[j];
  for(j = 0; j < 8; j++)
    nfreep->u.suns[j] = -1;


  numnodes = 1;
  nfreep++;
  nfree++;

  /* create a set of empty nodes corresponding to the top-level domain
   * grid. We need to generate these nodes first to make sure that we have a
   * complete top-level tree which allows the easy insertion of the
   * pseudo-particles at the right place 
   */

  force_create_empty_nodes(All.MaxPart, 0, 1, 0, 0, 0, &numnodes, &nfree);


  /* if a high-resolution region in a global tree is used, we need to generate
   * an additional set empty nodes to make sure that we have a complete
   * top-level tree for the high-resolution inset
   */

  nfreep = &Nodes[nfree];
  parent = -1;                  /* note: will not be used below before it is
       changed */


  /* now we insert all particles */
  for(i = 0; i < npart; i++)
    {

      /* the softening is only used to check whether particles are so close
       * that the tree needs not to be refined further
       */
      epsilon = All.ForceSoftening[P[i].Type];

      key = peano_hilbert_key((P[i].Pos[0] - DomainCorner[0]) * DomainFac,
                              (P[i].Pos[1] - DomainCorner[1]) * DomainFac,
                              (P[i].Pos[2] - DomainCorner[2]) * DomainFac, 
      BITS_PER_DIMENSION);

      no = 0;
      while(TopNodes[no].Daughter >= 0)
        no = TopNodes[no].Daughter + (key - TopNodes[no].StartKey) / (TopNodes[
      no].Size / 8);

      no = TopNodes[no].Leaf;
      th = DomainNodeIndex[no];

      while(1)
        {
          if(th >= All.MaxPart) /* we are dealing with an internal node */
            {
              subnode = 0;
              if(P[i].Pos[0] > Nodes[th].center[0])
                subnode += 1;
              if(P[i].Pos[1] > Nodes[th].center[1])
                subnode += 2;
              if(P[i].Pos[2] > Nodes[th].center[2])
                subnode += 4;

              nn = Nodes[th].u.suns[subnode];

              if(nn >= 0)       /* ok, something is in the daughter slot
       already, need to continue */
                {
                  parent = th;
                  th = nn;
                }
              else
                {
                  /* here we have found an empty slot where we can attach
                   * the new particle as a leaf.
                   */
                  Nodes[th].u.suns[subnode] = i;
                  break;        /* done for this particle */
                }
            }
          else
            {
              /* We try to insert into a leaf with a single particle.  Need
               * to generate a new internal node at this point.
               */
              Nodes[parent].u.suns[subnode] = nfree;

              nfreep->len = 0.5 * Nodes[parent].len;
              lenhalf = 0.25 * Nodes[parent].len;

              if(subnode & 1)
                nfreep->center[0] = Nodes[parent].center[0] + lenhalf;
              else
                nfreep->center[0] = Nodes[parent].center[0] - lenhalf;

              if(subnode & 2)
                nfreep->center[1] = Nodes[parent].center[1] + lenhalf;
              else
                nfreep->center[1] = Nodes[parent].center[1] - lenhalf;

              if(subnode & 4)
                nfreep->center[2] = Nodes[parent].center[2] + lenhalf;
              else
                nfreep->center[2] = Nodes[parent].center[2] - lenhalf;

              nfreep->u.suns[0] = -1;
              nfreep->u.suns[1] = -1;
              nfreep->u.suns[2] = -1;
              nfreep->u.suns[3] = -1;
              nfreep->u.suns[4] = -1;
              nfreep->u.suns[5] = -1;
              nfreep->u.suns[6] = -1;
              nfreep->u.suns[7] = -1;


              subnode = 0;
              if(P[th].Pos[0] > nfreep->center[0])
                subnode += 1;
              if(P[th].Pos[1] > nfreep->center[1])
                subnode += 2;
              if(P[th].Pos[2] > nfreep->center[2])
                subnode += 4;
#ifndef NOTREERND
              if(nfreep->len < 1.0e-3 * epsilon)
                {
                  /* seems like we're dealing with particles at identical (or
       extremely close)
                   * locations. Randomize subnode index to allow tree
       construction. Note: Multipole moments
                   * of tree are still correct, but this will only happen well
       below gravitational softening
                   * length-scale anyway.
                   */
                  subnode = (int) (8.0 * get_random_number((0xffff & P[i].ID) +
       P[i].GravCost));
                  P[i].GravCost += 1;
                  if(subnode >= 8)
                    subnode = 7;
                }
#endif
              nfreep->u.suns[subnode] = th;

              th = nfree;       /* resume trying to insert the new particle at
                                 * the newly created internal node
                                 */

              numnodes++;
              nfree++;
              nfreep++;

              if((numnodes) >= MaxNodes)
                {
                  printf("task %d: maximum number %d of tree-nodes reached.\n",
       ThisTask, MaxNodes);
                  printf("for particle %d\n", i);
                  dump_particles();
                  endrun(1);
                }
            }
        }
    }


  /* insert the pseudo particles that represent the mass distribution of other
       domains */
  force_insert_pseudo_particles();


  /* now compute the multipole moments recursively */
  last = -1;

  force_update_node_recursive(All.MaxPart, -1, -1);

  if(last >= All.MaxPart)
    {
      if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
        Nextnode[last - MaxNodes] = -1;
      else
        Nodes[last].u.d.nextnode = -1;
    }
  else
    Nextnode[last] = -1;

  return numnodes;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aadc9b1624ed78f3ccd0dbb9908fe0bb6_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a59ae74ef51d6a7065605638422489391}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeevaluate@{force\-\_\-treeevaluate}}
\index{force\-\_\-treeevaluate@{force\-\_\-treeevaluate}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeevaluate}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf force\-\_\-treeevaluate} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode, }
\item[{double $\ast$}]{ewaldcountsum}
\end{DoxyParamCaption}
)}}\label{proto_8h_a59ae74ef51d6a7065605638422489391}
\-This routine computes the gravitational force for a given local particle, or for a particle in the communication buffer. \-Depending on the value of \-Type\-Of\-Opening\-Criterion, either the geometrical \-B\-H cell-\/opening criterion, or the `relative' opening criterion is used. 

\-Definition at line 1126 of file forcetree.\-c.



\-References \-All, calculate\-\_\-interact\-\_\-kick(), check\-\_\-interaction\-\_\-table(), \-Domain\-Task, endrun(), \-Exportflag, force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction(), \-Grav\-Data\-Get, \-Grav\-Data\-Result, \-Max\-Nodes, \-N\-E\-A\-R\-E\-S\-T, \-Nextnode, \-Nodes, \-P, prob\-\_\-of\-\_\-interaction(), random\-\_\-generator, \-Sph\-P, and update\-\_\-interaction\-\_\-table().



\-Referenced by gravity\-\_\-tree().


\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ninteractions, ptype;
  double r2, dx, dy, dz, mass, r, fac, u, h, h_inv, h3_inv;
  double acc_x, acc_y, acc_z, pos_x, pos_y, pos_z, aold;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center,kick_x,kick_y,kick_z,kick_target[3],kick_no[3],prob,
      prob_tmp,max_prob;
  FLOAT  targetVel[3];
  int targetBegstep,targetEndstep,targetdTi_selfInt;
  IDTYPE targetID;              
  int si_count,i;
  kick_x = 0;
  kick_y = 0;
  kick_z = 0;
  si_count = 0;
  max_prob = 0;
  if(mode == 0)
  {
    for(i=0;i<3;i++)
      targetVel[i] = P[target].Vel[i];
    targetBegstep = P[target].Ti_begstep;
    targetEndstep = P[target].Ti_endstep;
    targetID      = P[target].ID;
    targetdTi_selfInt = P[target].dTi_selfInt;
  }
  else
  {
    for(i=0;i<3;i++)
      targetVel[i] = GravDataGet[target].Vel[i];
    targetBegstep = GravDataGet[target].Ti_begstep;
    targetEndstep = GravDataGet[target].Ti_endstep;
    targetID      = GravDataGet[target].ID;
    targetdTi_selfInt =  GravDataGet[target].dTi_selfInt;
  }
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  ninteractions = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#ifdef COMPUTE_SELFINTERACTION_FORDARK      
      ptype = GravDataGet[target].Type;
#endif
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }



#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
  h3_inv = h_inv * h_inv * h_inv;
#endif
  no = All.MaxPart;             /* root node */

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;

          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }
          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;

          mass = nop->u.d.mass;
        }
#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          if (targetID != P[no].ID)
            {
              if (ptype == 1 && P[no].Type == 1) 
              //if ((ptype == 1 && P[no].Type == 4) || (ptype == 4 &&
       P[no].Type == 1) ) /*Use this for Test1 and Test2 only*/
                {
                  r = sqrt(r2);
                  if (r < 2.0*All.SIDMSmoothingFactor*All.ForceSoftening[1])
                    {
                      if (check_interaction_table(targetID,P[no].ID) == 0)
                        {
                          prob = prob_of_interaction(r, targetVel, P[no].Vel, 
      targetBegstep, targetEndstep);
                          if(prob > max_prob) max_prob = prob;
                          
                          if(prob > 0.2)
                            {
                              if(targetdTi_selfInt == 0 || prob_of_interaction(
      r, targetVel, P[no].Vel, 0, targetdTi_selfInt) > 0.2)
                                {
                                  targetdTi_selfInt = targetEndstep-
      targetBegstep;
                                  prob_tmp = prob;
                                  while(prob_tmp > 0.2)
                                    {
                                      targetdTi_selfInt /= 2; 
                                      prob_tmp = prob_of_interaction(r, 
      targetVel, P[no].Vel, 0, targetdTi_selfInt); 
                                    }
                                }
                            }
                          
                          if (gsl_rng_uniform(random_generator) < prob)
                            {
                              calculate_interact_kick(targetVel, P[no].Vel, 
      kick_target, kick_no); 
                              kick_x += kick_target[0];
                              kick_y += kick_target[1];
                              kick_z += kick_target[2];
                              for (i = 0; i < 3 ; i++)
                                P[no].Vel[i] += kick_no[i];
                              //if(sqrt(pos_x*pos_x + pos_y*pos_y +
       pos_z*pos_z) > 127.0 && sqrt(pos_x*pos_x + pos_y*pos_y + pos_z*pos_z) < 167.0 ) /* This if
       statement is for the sake of Test1 only. REMOVE FOR ANY OTHER RUNS!!.*/
                              si_count+=1;
                              update_interaction_table(targetID,P[no].ID);
                            }                   
                        }
                    }
                }
            }
#endif
          
          no = Nextnode[no];
        }
      else                      /* we have an  internal node. Need to check
       opening criterion */
        {
          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can
                                                 * continue to do a short-cut 
      */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - 
      pos_x) + 
                                (nop->center[1] - pos_y)*(nop->center[1] - 
      pos_y) +
                                (nop->center[2] - pos_z)*(nop->center[2] - 
      pos_z));
           /* check if any portion the cell lies withing the intercation range 
      */
          if(dist_to_center - nop->len*sqrt(3.0)/2.0 < 2.0*All.
      SIDMSmoothingFactor*All.ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#else

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* check in addition whether we lie inside the cell */

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#endif

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes 
      */
            {
              if(mass > 0)
                endrun(986);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5
       signals that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif

          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node
       belongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        fac = mass / (r2 * r);
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
          h3_inv = h_inv * h_inv * h_inv;
#endif
          u = r * h_inv;
          if(u < 0.5)
            fac = mass * h3_inv * (10.666666666667 + u * u * (32.0 * u - 38.4))
      ;
          else
            fac =
              mass * h3_inv * (21.333333333333 - 48.0 * u +
                               38.4 * u * u - 10.666666666667 * u * u * u - 0.0
      66666666667 / (u * u * u));
        }
      
        acc_x += dx * fac;
        acc_y += dy * fac;
        acc_z += dz * fac;

      ninteractions++;
    }
  
#ifdef COMPUTE_SELFINTERACTION_FORDARK 
  All.Nself_interactions += si_count;
  if(max_prob < 0.1 && max_prob > 0 && mode == 0 && targetdTi_selfInt > 0)
    {
      while(max_prob < 0.1)
        {
          targetdTi_selfInt *= 2; 
          max_prob *= 2.0;
        }
    }

  /*for test2 we want to turn off gravity for all the particles
  acc_x = 0.0;
  acc_y = 0.0;
  acc_z = 0.0;*/
#endif

  /* store result at the proper place */
  if(mode == 0)
    {
      P[target].GravAccel[0] = acc_x;
      P[target].GravAccel[1] = acc_y;
      P[target].GravAccel[2] = acc_z;
      P[target].GravCost = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      P[target].Vel[0] += kick_x;
      P[target].Vel[1] += kick_y;
      P[target].Vel[2] += kick_z;
      P[target].dTi_selfInt = targetdTi_selfInt;
#endif
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
      GravDataResult[target].w.Ninteractions = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      GravDataResult[target].Vel[0] = kick_x;
      GravDataResult[target].Vel[1] = kick_y;
      GravDataResult[target].Vel[2] = kick_z;
      GravDataResult[target].dTi_selfInt = targetdTi_selfInt;
#endif
    }

#ifdef PERIODIC
  *ewaldcountsum += force_treeevaluate_ewald_correction(target, mode, pos_x, 
      pos_y, pos_z, aold);
#endif

  return ninteractions;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a59ae74ef51d6a7065605638422489391_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a59ae74ef51d6a7065605638422489391_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0ec221b2517893874b12dc366bfe0da8}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeevaluate\-\_\-direct@{force\-\_\-treeevaluate\-\_\-direct}}
\index{force\-\_\-treeevaluate\-\_\-direct@{force\-\_\-treeevaluate\-\_\-direct}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeevaluate\-\_\-direct}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf force\-\_\-treeevaluate\-\_\-direct} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0ec221b2517893874b12dc366bfe0da8}
\-This function does the force computation with direct summation for the specified particle in the communication buffer. \-This can be useful for debugging purposes, in particular for explicit checks of the force accuracy. 

\-Definition at line 2993 of file forcetree.\-c.



\-References \-All, dmax(), ewald\-\_\-corr(), \-Grav\-Data\-Get, \-Grav\-Data\-Result, \-Num\-Part, and \-P.



\-Referenced by gravity\-\_\-forcetest().


\begin{DoxyCode}
{
  double epsilon;
  double h, h_inv, dx, dy, dz, r, r2, u, r_inv, fac;
  int i, ptype;
  double pos_x, pos_y, pos_z;
  double acc_x, acc_y, acc_z;

#ifdef PERIODIC
  double fcorr[3];
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
    }

  for(i = 0; i < NumPart; i++)
    {
      epsilon = dmax(All.ForceSoftening[P[i].Type], All.ForceSoftening[ptype]);

      h = epsilon;
      h_inv = 1 / h;

      dx = P[i].Pos[0] - pos_x;
      dy = P[i].Pos[1] - pos_y;
      dz = P[i].Pos[2] - pos_z;

#ifdef PERIODIC
      while(dx > boxhalf)
        dx -= boxsize;
      while(dy > boxhalf)
        dy -= boxsize;
      while(dz > boxhalf)
        dz -= boxsize;
      while(dx < -boxhalf)
        dx += boxsize;
      while(dy < -boxhalf)
        dy += boxsize;
      while(dz < -boxhalf)
        dz += boxsize;
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      r = sqrt(r2);

      u = r * h_inv;

      if(u >= 1)
        {
          r_inv = 1 / r;

          fac = P[i].Mass * r_inv * r_inv * r_inv;
        }
      else
        {
          if(u < 0.5)
            fac = P[i].Mass * h_inv * h_inv * h_inv * (10.666666666667 + u * u 
      * (32.0 * u - 38.4));
          else
            fac =
              P[i].Mass * h_inv * h_inv * h_inv * (21.333333333333 -
                                                   48.0 * u + 38.4 * u * u -
                                                   10.666666666667 * u * u *
                                                   u - 0.066666666667 / (u * u 
      * u));
        }

      acc_x += dx * fac;
      acc_y += dy * fac;
      acc_z += dz * fac;

#ifdef PERIODIC
      if(u > 1.0e-5)
        {
          ewald_corr(dx, dy, dz, fcorr);

          acc_x += P[i].Mass * fcorr[0];
          acc_y += P[i].Mass * fcorr[1];
          acc_z += P[i].Mass * fcorr[2];
        }
#endif
    }


  if(mode == 0)
    {
      P[target].GravAccelDirect[0] = acc_x;
      P[target].GravAccelDirect[1] = acc_y;
      P[target].GravAccelDirect[2] = acc_z;
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
    }


  return NumPart;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{proto_8h_a0ec221b2517893874b12dc366bfe0da8_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a0ec221b2517893874b12dc366bfe0da8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction@{force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction}}
\index{force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction@{force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf force\-\_\-treeevaluate\-\_\-ewald\-\_\-correction} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode, }
\item[{double}]{pos\-\_\-x, }
\item[{double}]{pos\-\_\-y, }
\item[{double}]{pos\-\_\-z, }
\item[{double}]{aold}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f}
\-This function computes the \-Ewald correction, and is needed if periodic boundary conditions together with a pure tree algorithm are used. \-Note that the ordinary tree walk does not carry out this correction directly as it was done in \-Gadget-\/1.\-1. \-Instead, the tree is walked a second time. \-This is actually faster because the \char`\"{}\-Ewald-\/\-Treewalk\char`\"{} can use a different opening criterion than the normal tree walk. \-In particular, the \-Ewald correction is negligible for particles that are very close, but it is large for particles that are far away (this is quite different for the normal direct force). \-So we can here use a different opening criterion. \-Sufficient accuracy is usually obtained if the node length has dropped to a certain fraction $\sim$$<$ 0.\-25 of the \-Box\-Length. \-However, we may only short-\/cut the interaction list of the normal full \-Ewald tree walk if we are sure that the whole node and all daughter nodes \char`\"{}lie on the same side\char`\"{} of the periodic boundary, i.\-e. that the real tree walk would not find a daughter node or particle that was mapped to a different nearest neighbour position when the tree walk would be further refined. 

\-Definition at line 2018 of file forcetree.\-c.



\-References \-All, \-Domain\-Task, \-E\-N, \-Exportflag, fac\-\_\-intp, fcorrx, fcorry, fcorrz, \-Grav\-Data\-Result, \-Max\-Nodes, \-N\-E\-A\-R\-E\-S\-T, \-Nextnode, \-Nodes, and \-P.



\-Referenced by force\-\_\-treeevaluate().


\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, cost;
  double dx, dy, dz, mass, r2;
  int signx, signy, signz;
  int i, j, k, openflag;
  double u, v, w;
  double f1, f2, f3, f4, f5, f6, f7, f8;
  double acc_x, acc_y, acc_z;
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif
  
  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  cost = 0;

  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }

              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);

      if(no < All.MaxPart)
        no = Nextnode[no];
      else                      /* we have an  internal node. Need to check
       opening criterion */
        {
          openflag = 0;

          r2 = dx * dx + dy * dy + dz * dz;
        
#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - 
      pos_x) +
                              (nop->center[1] - pos_y)*(nop->center[1] - pos_y)
       +
                              (nop->center[2] - pos_z)*(nop->center[2] - pos_z)
      );
          /*check if any portion the cell lies withing the intercation range*/
        if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0*All.
      SIDMSmoothingFactor*All.ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  openflag = 1;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  openflag = 1;
                }
              else
                {
                  if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                        {
                          if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                            {
                              openflag = 1;
                            }
                        }
                    }
                }
            }

          if(openflag)
            {
              /* now we check if we can avoid opening the cell */

              u = nop->center[0] - pos_x;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              u = nop->center[1] - pos_y;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              u = nop->center[2] - pos_z;
              if(u > boxhalf)
                u -= boxsize;
              if(u < -boxhalf)
                u += boxsize;

              if(fabs(u) > 0.5 * (boxsize - nop->len))
                {
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* if the cell is too large, we need to refine
               * it further 
               */
              if(nop->len > 0.20 * boxsize)
                {
                  /* cell is too large */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }

          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 1))       /* Bit 0 signals that this node
       belongs to top-level tree */
                continue;
            }
        }

      /* compute the Ewald correction force */

      if(dx < 0)
        {
          dx = -dx;
          signx = +1;
        }
      else
        signx = -1;

      if(dy < 0)
        {
          dy = -dy;
          signy = +1;
        }
      else
        signy = -1;

      if(dz < 0)
        {
          dz = -dz;
          signz = +1;
        }
      else
        signz = -1;

      u = dx * fac_intp;
      i = (int) u;
      if(i >= EN)
        i = EN - 1;
      u -= i;
      v = dy * fac_intp;
      j = (int) v;
      if(j >= EN)
        j = EN - 1;
      v -= j;
      w = dz * fac_intp;
      k = (int) w;
      if(k >= EN)
        k = EN - 1;
      w -= k;

      /* compute factors for trilinear interpolation */

      f1 = (1 - u) * (1 - v) * (1 - w);
      f2 = (1 - u) * (1 - v) * (w);
      f3 = (1 - u) * (v) * (1 - w);
      f4 = (1 - u) * (v) * (w);
      f5 = (u) * (1 - v) * (1 - w);
      f6 = (u) * (1 - v) * (w);
      f7 = (u) * (v) * (1 - w);
      f8 = (u) * (v) * (w);

      acc_x += mass * signx * (fcorrx[i][j][k] * f1 +
                               fcorrx[i][j][k + 1] * f2 +
                               fcorrx[i][j + 1][k] * f3 +
                               fcorrx[i][j + 1][k + 1] * f4 +
                               fcorrx[i + 1][j][k] * f5 +
                               fcorrx[i + 1][j][k + 1] * f6 +
                               fcorrx[i + 1][j + 1][k] * f7 + fcorrx[i + 1][j +
       1][k + 1] * f8);

      acc_y += mass * signy * (fcorry[i][j][k] * f1 +
                               fcorry[i][j][k + 1] * f2 +
                               fcorry[i][j + 1][k] * f3 +
                               fcorry[i][j + 1][k + 1] * f4 +
                               fcorry[i + 1][j][k] * f5 +
                               fcorry[i + 1][j][k + 1] * f6 +
                               fcorry[i + 1][j + 1][k] * f7 + fcorry[i + 1][j +
       1][k + 1] * f8);

      acc_z += mass * signz * (fcorrz[i][j][k] * f1 +
                               fcorrz[i][j][k + 1] * f2 +
                               fcorrz[i][j + 1][k] * f3 +
                               fcorrz[i][j + 1][k + 1] * f4 +
                               fcorrz[i + 1][j][k] * f5 +
                               fcorrz[i + 1][j][k + 1] * f6 +
                               fcorrz[i + 1][j + 1][k] * f7 + fcorrz[i + 1][j +
       1][k + 1] * f8);
      cost++;
    }


  /* add the result at the proper place */

  if(mode == 0)
    {
      P[target].GravAccel[0] += acc_x;
      P[target].GravAccel[1] += acc_y;
      P[target].GravAccel[2] += acc_z;
      P[target].GravCost += cost;
    }
  else
    {
      GravDataResult[target].u.Acc[0] += acc_x;
      GravDataResult[target].u.Acc[1] += acc_y;
      GravDataResult[target].u.Acc[2] += acc_z;
      GravDataResult[target].w.Ninteractions += cost;
    }

  return cost;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab6894fe5ae268ea8f6bc7c4a8c87a87f_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a804166b1847da509d8fe57072b40d5f9}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeevaluate\-\_\-potential@{force\-\_\-treeevaluate\-\_\-potential}}
\index{force\-\_\-treeevaluate\-\_\-potential@{force\-\_\-treeevaluate\-\_\-potential}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeevaluate\-\_\-potential}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-treeevaluate\-\_\-potential} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a804166b1847da509d8fe57072b40d5f9}
\-This routine computes the gravitational potential by walking the tree. \-The same opening criteria is used as for the gravitational force walk. 

\-Definition at line 2300 of file forcetree.\-c.



\-References \-All, \-Domain\-Task, endrun(), ewald\-\_\-pot\-\_\-corr(), \-Exportflag, \-Grav\-Data\-Get, \-Grav\-Data\-Result, \-Max\-Nodes, \-N\-E\-A\-R\-E\-S\-T, \-Nextnode, \-Nodes, \-P, and \-Sph\-P.



\-Referenced by compute\-\_\-potential().


\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype;
  double r2, dx, dy, dz, mass, r, u, h, h_inv, wp;
  double pot, pos_x, pos_y, pos_z, aold;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif
  
  pot = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }


#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
#endif
  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an internal node. Need to check
       opening criterion */
        {
          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can make
                                                 * a short-cut 
                                                 */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - 
      pos_x) + 
                                (nop->center[1] - pos_y)*(nop->center[1] - 
      pos_y) +
                                (nop->center[2] - pos_z)*(nop->center[2] - 
      pos_z));
           /*check if any portion the cell lies withing the intercation range*/
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0*All.
      SIDMSmoothingFactor*All.ForceSoftening[1])
          {
            /* open cell */
            no = nop->u.d.nextnode;
            continue;
          }
#endif
        
          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes 
      */
            {
              if(mass > 0)
                endrun(988);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5
       signals that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif

          no = nop->u.d.sibling;        /* node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node
       belongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        pot -= mass / r;
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
#endif
          u = r * h_inv;

          if(u < 0.5)
            wp = -2.8 + u * u * (5.333333333333 + u * u * (6.4 * u - 9.6));
          else
            wp =
              -3.2 + 0.066666666667 / u + u * u * (10.666666666667 +
                                                   u * (-16.0 + u * (9.6 - 2.13
      3333333333 * u)));

          pot += mass * h_inv * wp;
        }
#ifdef PERIODIC
      pot += mass * ewald_pot_corr(dx, dy, dz);
#endif
    }

  /* store result at the proper place */

  if(mode == 0)
    P[target].Potential = pot;
  else
    GravDataResult[target].u.Potential = pot;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a804166b1847da509d8fe57072b40d5f9_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a804166b1847da509d8fe57072b40d5f9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange@{force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange}}
\index{force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange@{force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-treeevaluate\-\_\-potential\-\_\-shortrange} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7}
\-This function computes the short-\/range potential when the \-Tree\-P\-M algorithm is used. \-This potential is the \-Newtonian potential, modified by a complementary error function. 

\-Definition at line 2577 of file forcetree.\-c.



\-References \-All, \-Domain\-Task, endrun(), \-Exportflag, \-Grav\-Data\-Get, \-Grav\-Data\-Result, \-Max\-Nodes, \-N\-E\-A\-R\-E\-S\-T, \-Nextnode, \-Nodes, \-N\-T\-A\-B, \-P, shortrange\-\_\-table\-\_\-potential, and \-Sph\-P.



\-Referenced by compute\-\_\-potential().


\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype, tabindex;
  double r2, dx, dy, dz, mass, r, u, h, h_inv, wp;
  double pot, pos_x, pos_y, pos_z, aold;
  double eff_dist, fac, rcut, asmth, asmthfac;
  double dxx, dyy, dzz;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif

#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif
#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center;
#endif

  pot = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }


  rcut = All.Rcut[0];
  asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
  if(((1 << ptype) & (PLACEHIGHRESREGION)))
    {
      rcut = All.Rcut[1];
      asmth = All.Asmth[1];
    }
#endif
  asmthfac = 0.5 / asmth * (NTAB / 3.0);

#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
#endif

  no = All.MaxPart;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          /* the index of the node is the index of the particle */
          /* observe the sign  */

          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
          mass = P[no].Mass;
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];
          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
          mass = nop->u.d.mass;
        }

#ifdef PERIODIC
      dx = NEAREST(dx);
      dy = NEAREST(dy);
      dz = NEAREST(dz);
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(no < All.MaxPart)
        {
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif
          no = Nextnode[no];
        }
      else                      /* we have an  internal node. Need to check
       opening criterion */
        {
          /* check whether we can stop walking along this branch */
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
       which does not contain local particles */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

          eff_dist = rcut + 0.5 * nop->len;

          dxx = nop->center[0] - pos_x; /* observe the sign ! */
          dyy = nop->center[1] - pos_y; /* this vector is -y in my thesis
       notation */
          dzz = nop->center[2] - pos_z;
#ifdef PERIODIC
          dxx = NEAREST(dxx);
          dyy = NEAREST(dyy);
          dzz = NEAREST(dzz);
#endif
          if(dxx < -eff_dist || dxx > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

          if(dyy < -eff_dist || dyy > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

          if(dzz < -eff_dist || dzz > eff_dist)
            {
              no = nop->u.d.sibling;
              continue;
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - 
      pos_x) + 
                                (nop->center[1] - pos_y)*(nop->center[1] - 
      pos_y) +
                                (nop->center[2] - pos_z)*(nop->center[2] - 
      pos_z));
           /*check if any portion the cell lies withing the intercation range*/
          if(dist_to_center - nop->len * sqrt(3.0) / 2.0 < 2.0*All.
      SIDMSmoothingFactor*All.ForceSoftening[1])
          {
            /* open cell */
            no = nop->u.d.nextnode;
            continue;
          }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes 
      */
            {
              if(mass > 0)
                endrun(989);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      /* bit-5 signals that there are particles of
                       * different softening in the node
                       */
                      if(((nop->u.d.bitflags >> 5) & 1))
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif
          no = nop->u.d.sibling;        /* node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node
       belongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      tabindex = (int) (r * asmthfac);

      if(tabindex < NTAB)
        {
          fac = shortrange_table_potential[tabindex];

          if(r >= h)
            pot -= fac * mass / r;
          else
            {
#ifdef UNEQUALSOFTENINGS
              h_inv = 1.0 / h;
#endif
              u = r * h_inv;

              if(u < 0.5)
                wp = -2.8 + u * u * (5.333333333333 + u * u * (6.4 * u - 9.6));
              else
                wp =
                  -3.2 + 0.066666666667 / u + u * u * (10.666666666667 +
                                                       u * (-16.0 + u * (9.6 - 
      2.133333333333 * u)));
              pot += fac * mass * h_inv * wp;
            }
        }
    }


  /* store result at the proper place */
  if(mode == 0)
    P[target].Potential = pot;
  else
    GravDataResult[target].u.Potential = pot;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_abd9d86a6c08e77a4fa78fa76b96cdde7_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae01e179b7686a7fe62970160b7bbdb46}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeevaluate\-\_\-shortrange@{force\-\_\-treeevaluate\-\_\-shortrange}}
\index{force\-\_\-treeevaluate\-\_\-shortrange@{force\-\_\-treeevaluate\-\_\-shortrange}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeevaluate\-\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf force\-\_\-treeevaluate\-\_\-shortrange} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_ae01e179b7686a7fe62970160b7bbdb46}
\-In the \-Tree\-P\-M algorithm, the tree is walked only locally around the target coordinate. \-Tree nodes that fall outside a box of half side-\/length \-Rcut= \-R\-C\-U\-T$\ast$\-A\-S\-M\-T\-H$\ast$\-Mesh\-Size can be discarded. \-The short-\/range potential is modified by a complementary error function, multiplied with the \-Newtonian form. \-The resulting short-\/range suppression compared to the \-Newtonian force is tabulated, because looking up from this table is faster than recomputing the corresponding factor, despite the memory-\/access panelty (which reduces cache performance) incurred by the table. 

\-Definition at line 1542 of file forcetree.\-c.



\-References \-All, calculate\-\_\-interact\-\_\-kick(), check\-\_\-interaction\-\_\-table(), \-Domain\-Task, endrun(), \-Exportflag, \-Grav\-Data\-Get, \-Grav\-Data\-Result, \-Max\-Nodes, \-N\-E\-A\-R\-E\-S\-T, \-Nextnode, \-Nodes, \-N\-T\-A\-B, \-P, prob\-\_\-of\-\_\-interaction(), random\-\_\-generator, shortrange\-\_\-table, \-Sph\-P, and update\-\_\-interaction\-\_\-table().



\-Referenced by gravity\-\_\-tree().


\begin{DoxyCode}
{
  struct NODE *nop = 0;
  int no, ptype, ninteractions, tabindex;
  double r2, dx, dy, dz, mass, r, fac, u, h, h_inv, h3_inv;
  double acc_x, acc_y, acc_z, pos_x, pos_y, pos_z, aold;
  double eff_dist;
  double rcut, asmth, asmthfac, rcut2, dist;
#if defined(UNEQUALSOFTENINGS) && !defined(ADAPTIVE_GRAVSOFT_FORGAS)
  int maxsofttype;
#endif
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
  double soft = 0;
#endif
#ifdef PERIODIC
  double boxsize, boxhalf;

  boxsize = All.BoxSize;
  boxhalf = 0.5 * All.BoxSize;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  double  dist_to_center,kick_x,kick_y,kick_z,kick_target[3],kick_no[3],prob,
      prob_tmp,max_prob;
  FLOAT targetVel[3];
  int targetBegstep,targetEndstep,targetdTi_selfInt;
  IDTYPE targetID;              
  int si_count,i;
  kick_x = 0;
  kick_y = 0;
  kick_z = 0;
  si_count = 0;
  max_prob = 0;
  if(mode == 0)
    {
      for(i=0;i<3;i++)
        targetVel[i] = P[target].Vel[i];
      targetBegstep = P[target].Ti_begstep;
      targetEndstep = P[target].Ti_endstep;
      targetID      = P[target].ID;
      targetdTi_selfInt = P[target].dTi_selfInt;
    }
  else
    {
      for(i=0;i<3;i++)
        targetVel[i] = GravDataGet[target].Vel[i];
      targetBegstep = GravDataGet[target].Ti_begstep;
      targetEndstep = GravDataGet[target].Ti_endstep;
      targetID      = GravDataGet[target].ID;
      targetdTi_selfInt = GravDataGet[target].dTi_selfInt;;
    }
#endif

  acc_x = 0;
  acc_y = 0;
  acc_z = 0;
  ninteractions = 0;

  if(mode == 0)
    {
      pos_x = P[target].Pos[0];
      pos_y = P[target].Pos[1];
      pos_z = P[target].Pos[2];
      ptype = P[target].Type;
      aold = All.ErrTolForceAcc * P[target].OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = SphP[target].Hsml;
#endif
    }
  else
    {
      pos_x = GravDataGet[target].u.Pos[0];
      pos_y = GravDataGet[target].u.Pos[1];
      pos_z = GravDataGet[target].u.Pos[2];
#ifdef UNEQUALSOFTENINGS
      ptype = GravDataGet[target].Type;
#else
      ptype = P[0].Type;
#ifdef COMPUTE_SELFINTERACTION_FORDARK      
      ptype = GravDataGet[target].Type;
#endif
#endif
      aold = All.ErrTolForceAcc * GravDataGet[target].w.OldAcc;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(ptype == 0)
        soft = GravDataGet[target].Soft;
#endif
    }

  rcut = All.Rcut[0];
  asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
  if(((1 << ptype) & (PLACEHIGHRESREGION)))
    {
      rcut = All.Rcut[1];
      asmth = All.Asmth[1];
    }
#endif
  rcut2 = rcut * rcut;

  asmthfac = 0.5 / asmth * (NTAB / 3.0);

#ifndef UNEQUALSOFTENINGS
  h = All.ForceSoftening[ptype];
  h_inv = 1.0 / h;
  h3_inv = h_inv * h_inv * h_inv;
#endif
  no = All.MaxPart;             /* root node */

  while(no >= 0)
    {
      if(no < All.MaxPart)
        {
          /* the index of the node is the index of the particle */
          dx = P[no].Pos[0] - pos_x;
          dy = P[no].Pos[1] - pos_y;
          dz = P[no].Pos[2] - pos_z;
#ifdef PERIODIC
          dx = NEAREST(dx);
          dy = NEAREST(dy);
          dz = NEAREST(dz);
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          mass = P[no].Mass;
#ifdef UNEQUALSOFTENINGS
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(P[no].Type == 0)
            {
              if(h < SphP[no].Hsml)
                h = SphP[no].Hsml;
            }
          else
            {
              if(h < All.ForceSoftening[P[no].Type])
                h = All.ForceSoftening[P[no].Type];
            }
#else
          h = All.ForceSoftening[ptype];
          if(h < All.ForceSoftening[P[no].Type])
            h = All.ForceSoftening[P[no].Type];
#endif
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          if (targetID != P[no].ID)
            {
              if (ptype == 1 && P[no].Type == 1)
              //if ((ptype == 1 && P[no].Type == 4) || (ptype == 4 &&
       P[no].Type == 1) ) /*Use this for Test1 and Test2 only*/ 
                {
                  r = sqrt(r2);
                  if (r < 2.0*All.SIDMSmoothingFactor*All.ForceSoftening[1])
                    {
                      if (check_interaction_table(targetID,P[no].ID) == 0)
                        {
                          prob = prob_of_interaction(r, targetVel, P[no].Vel, 
      targetBegstep, targetEndstep);
                          if(prob > max_prob) max_prob = prob;
                          
                          if(prob > 0.2)
                            {
                              if(targetdTi_selfInt == 0 || prob_of_interaction(
      r, targetVel, P[no].Vel, 0, targetdTi_selfInt) > 0.2)
                                {
                                  targetdTi_selfInt = targetEndstep-
      targetBegstep;
                                  prob_tmp = prob;
                                  while(prob_tmp > 0.2)
                                    {
                                      targetdTi_selfInt /= 2; 
                                      prob_tmp = prob_of_interaction(r, 
      targetVel, P[no].Vel, 0, targetdTi_selfInt); 
                                    }
                                }
                            }
                          
                          if(gsl_rng_uniform(random_generator) < prob)
                            {
                              calculate_interact_kick(targetVel, P[no].Vel, 
      kick_target, kick_no);
                              kick_x += kick_target[0];
                              kick_y += kick_target[1];
                              kick_z += kick_target[2];
                              for(i = 0; i < 3 ; i++)
                                P[no].Vel[i] += kick_no[i];
                              //if(sqrt(pos_x*pos_x + pos_y*pos_y +
       pos_z*pos_z) > 127.0 && sqrt(pos_x*pos_x + pos_y*pos_y + pos_z*pos_z) < 167.0 ) /* This if
       statement is for the sake of Test1 only. REMOVE FOR ANY OTHER RUNS!!.*/
                              si_count+=1;
                              update_interaction_table(targetID,P[no].ID);
                            }
                        }
                    }
                }
            }
#endif
          
          no = Nextnode[no];
        }
      else                      /* we have an  internal node */
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              if(mode == 0)
                {
                  Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
                }
              no = Nextnode[no - MaxNodes];
              continue;
            }

          nop = &Nodes[no];

          if(mode == 1)
            {
              if((nop->u.d.bitflags & 3) == 1)  /* if it's a top-level node
                                                 * which does not contain
                                                 * local particles we can
                                                 * continue at this point
                                                 */
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

          mass = nop->u.d.mass;

          dx = nop->u.d.s[0] - pos_x;
          dy = nop->u.d.s[1] - pos_y;
          dz = nop->u.d.s[2] - pos_z;
#ifdef PERIODIC
          dx = NEAREST(dx);
          dy = NEAREST(dy);
          dz = NEAREST(dz);
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          if(r2 > rcut2)
            {
              /* check whether we can stop walking along this branch */
              eff_dist = rcut + 0.5 * nop->len;
#ifdef PERIODIC
              dist = NEAREST(nop->center[0] - pos_x);
#else
              dist = nop->center[0] - pos_x;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
#ifdef PERIODIC
              dist = NEAREST(nop->center[1] - pos_y);
#else
              dist = nop->center[1] - pos_y;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
#ifdef PERIODIC
              dist = NEAREST(nop->center[2] - pos_z);
#else
              dist = nop->center[2] - pos_z;
#endif
              if(dist < -eff_dist || dist > eff_dist)
                {
                  no = nop->u.d.sibling;
                  continue;
                }
            }

#ifdef COMPUTE_SELFINTERACTION_FORDARK
          dist_to_center = sqrt((nop->center[0] - pos_x)*(nop->center[0] - 
      pos_x) + 
                                (nop->center[1] - pos_y)*(nop->center[1] - 
      pos_y) +
                                (nop->center[2] - pos_z)*(nop->center[2] - 
      pos_z));
          /*check if any portion the cell lies withing the intercation range */
          if(dist_to_center - nop->len*sqrt(3.0)/2.0 < 2.0*All.
      SIDMSmoothingFactor*All.ForceSoftening[1])
            {
              /* open cell */
              no = nop->u.d.nextnode;
              continue;
            }
#endif

          if(All.ErrTolTheta)   /* check Barnes-Hut opening criterion */
            {
              if(nop->len * nop->len > r2 * All.ErrTolTheta * All.ErrTolTheta)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
          else                  /* check relative opening criterion */
            {
              if(mass * nop->len * nop->len > r2 * r2 * aold)
                {
                  /* open cell */
                  no = nop->u.d.nextnode;
                  continue;
                }

              /* check in addition whether we lie inside the cell */

              if(fabs(nop->center[0] - pos_x) < 0.60 * nop->len)
                {
                  if(fabs(nop->center[1] - pos_y) < 0.60 * nop->len)
                    {
                      if(fabs(nop->center[2] - pos_z) < 0.60 * nop->len)
                        {
                          no = nop->u.d.nextnode;
                          continue;
                        }
                    }
                }
            }

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
          h = All.ForceSoftening[ptype];
          maxsofttype = (nop->u.d.bitflags >> 2) & 7;
          if(maxsofttype == 7) /* may only occur for zero mass top-level nodes 
      */
            {
              if(mass > 0)
                endrun(987);
              no = nop->u.d.nextnode;
              continue;
            }
          else
            {
              if(h < All.ForceSoftening[maxsofttype])
                {
                  h = All.ForceSoftening[maxsofttype];
                  if(r2 < h * h)
                    {
                      if(((nop->u.d.bitflags >> 5) & 1))        /* bit-5
       signals that there are particles of different softening in the node */
                        {
                          no = nop->u.d.nextnode;
                          
                          continue;
                        }
                    }
                }
            }
#else
          if(ptype == 0)
            h = soft;
          else
            h = All.ForceSoftening[ptype];

          if(h < nop->maxsoft)
            {
              h = nop->maxsoft;
              if(r2 < h * h)
                {
                  no = nop->u.d.nextnode;
                  continue;
                }
            }
#endif
#endif
          no = nop->u.d.sibling;        /* ok, node can be used */

          if(mode == 1)
            {
              if(((nop->u.d.bitflags) & 1))     /* Bit 0 signals that this node
       belongs to top-level tree */
                continue;
            }
        }

      r = sqrt(r2);

      if(r >= h)
        fac = mass / (r2 * r);
      else
        {
#ifdef UNEQUALSOFTENINGS
          h_inv = 1.0 / h;
          h3_inv = h_inv * h_inv * h_inv;
#endif
          u = r * h_inv;
          if(u < 0.5)
            fac = mass * h3_inv * (10.666666666667 + u * u * (32.0 * u - 38.4))
      ;
          else
            fac =
              mass * h3_inv * (21.333333333333 - 48.0 * u +
                               38.4 * u * u - 10.666666666667 * u * u * u - 0.0
      66666666667 / (u * u * u));
        }

      tabindex = (int) (asmthfac * r);

      if(tabindex < NTAB)
        {
          fac *= shortrange_table[tabindex];

          acc_x += dx * fac;
          acc_y += dy * fac;
          acc_z += dz * fac;

          ninteractions++;
        }
    }

#ifdef COMPUTE_SELFINTERACTION_FORDARK 
  All.Nself_interactions += si_count;
  if(max_prob < 0.1 && max_prob > 0 && mode == 0 && targetdTi_selfInt > 0)
    {
      while(max_prob < 0.1)
        {
          targetdTi_selfInt *= 2; 
          max_prob *= 2.0;
        }
    }
 
  /*for test2 we want to turn off gravity for all the particles
  acc_x = 0.0;
  acc_y = 0.0;
  acc_z = 0.0;*/
#endif

  /* store result at the proper place */

  if(mode == 0)
    {
      P[target].GravAccel[0] = acc_x;
      P[target].GravAccel[1] = acc_y;
      P[target].GravAccel[2] = acc_z;
      P[target].GravCost = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      P[target].Vel[0] += kick_x;
      P[target].Vel[1] += kick_y;
      P[target].Vel[2] += kick_z;
      P[target].dTi_selfInt = targetdTi_selfInt;
#endif
    }
  else
    {
      GravDataResult[target].u.Acc[0] = acc_x;
      GravDataResult[target].u.Acc[1] = acc_y;
      GravDataResult[target].u.Acc[2] = acc_z;
      GravDataResult[target].w.Ninteractions = ninteractions;
#ifdef COMPUTE_SELFINTERACTION_FORDARK
      GravDataResult[target].Vel[0] = kick_x;
      GravDataResult[target].Vel[1] = kick_y;
      GravDataResult[target].Vel[2] = kick_z;
      GravDataResult[target].dTi_selfInt = targetdTi_selfInt;
#endif
    }

  return ninteractions;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae01e179b7686a7fe62970160b7bbdb46_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae01e179b7686a7fe62970160b7bbdb46_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888}{\index{proto.\-h@{proto.\-h}!force\-\_\-treefree@{force\-\_\-treefree}}
\index{force\-\_\-treefree@{force\-\_\-treefree}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treefree}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-treefree} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888}
\-This function frees the memory allocated for the tree, i.\-e. it frees the space allocated by the function \hyperlink{forcetree_8c_ab98788ba31869c7bc55ce71b807d2ff2}{force\-\_\-treeallocate()}. 

\-Definition at line 2976 of file forcetree.\-c.



\-References \-Extnodes\-\_\-base, \-Father, \-Nextnode, and \-Nodes\-\_\-base.



\-Referenced by pmforce\-\_\-periodic(), and pmpotential\-\_\-periodic().


\begin{DoxyCode}
{
  free(Father);
  free(Nextnode);
  free(Extnodes_base);
  free(Nodes_base);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a0a9667f530dad09ebed8c0c98e5d3888_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19}{\index{proto.\-h@{proto.\-h}!force\-\_\-treeupdate\-\_\-pseudos@{force\-\_\-treeupdate\-\_\-pseudos}}
\index{force\-\_\-treeupdate\-\_\-pseudos@{force\-\_\-treeupdate\-\_\-pseudos}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-treeupdate\-\_\-pseudos}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-treeupdate\-\_\-pseudos} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19}
\-This function updates the top-\/level tree after the multipole moments of the pseudo-\/particles have been updated. 

\-Definition at line 732 of file forcetree.\-c.



\-References \-All, \-Domain\-Moment, \-Domain\-My\-Last, \-Domain\-Node\-Index, \-Extnodes, \-Nodes, and \-N\-Topleaves.



\-Referenced by force\-\_\-update\-\_\-pseudoparticles().


\begin{DoxyCode}
{
  int i, k, no;
  FLOAT sold[3], vsold[3], snew[3], vsnew[3], massold, massnew, mm;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
  int maxsofttype, diffsoftflag;
#else
  FLOAT maxsoft;
#endif
#endif

  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        for(k = 0; k < 3; k++)
          {
            sold[k] = Nodes[no].u.d.s[k];
            vsold[k] = Extnodes[no].vs[k];
          }
        massold = Nodes[no].u.d.mass;

        for(k = 0; k < 3; k++)
          {
            snew[k] = DomainMoment[i].s[k];
            vsnew[k] = DomainMoment[i].vs[k];
          }
        massnew = DomainMoment[i].mass;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
        maxsofttype = (DomainMoment[i].bitflags >> 2) & 7;
        diffsoftflag = (DomainMoment[i].bitflags >> 5) & 1;
#else
        maxsoft = DomainMoment[i].maxsoft;
#endif
#endif
        do
          {
            mm = Nodes[no].u.d.mass + massnew - massold;
            for(k = 0; k < 3; k++)
              {
                if(mm > 0)
                  {
                    Nodes[no].u.d.s[k] =
                      (Nodes[no].u.d.mass * Nodes[no].u.d.s[k] + massnew * snew
      [k] - massold * sold[k]) / mm;
                    Extnodes[no].vs[k] =
                      (Nodes[no].u.d.mass * Extnodes[no].vs[k] + massnew * 
      vsnew[k] -
                       massold * vsold[k]) / mm;
                  }
              }
            Nodes[no].u.d.mass = mm;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
            diffsoftflag |= (Nodes[no].u.d.bitflags >> 5) & 1;

            if(maxsofttype == 7)
              maxsofttype = (Nodes[no].u.d.bitflags >> 2) & 7;
            else
              {
                if(((Nodes[no].u.d.bitflags >> 2) & 7) != 7)
                  {
                    if(All.ForceSoftening[((Nodes[no].u.d.bitflags >> 2) & 7)] 
      >
                       All.ForceSoftening[maxsofttype])
                      {
                        maxsofttype = ((Nodes[no].u.d.bitflags >> 2) & 7);
                        diffsoftflag = 1;
                      }
                    else
                      {
                        if(All.ForceSoftening[((Nodes[no].u.d.bitflags >> 2) & 
      7)] <
                           All.ForceSoftening[maxsofttype])
                          diffsoftflag = 1;
                      }
                  }
              }

            Nodes[no].u.d.bitflags = (Nodes[no].u.d.bitflags & 3) + 4 * 
      maxsofttype + 32 * diffsoftflag;
#else
            if(Nodes[no].maxsoft < maxsoft)
              Nodes[no].maxsoft = maxsoft;
            maxsoft = Nodes[no].maxsoft;
#endif
#endif
            no = Nodes[no].u.d.father;

          }
        while(no >= 0);
      }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab8e5d4fed349d96c6d4f55897473ce19_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4764c1fb83a956c1712345538630854c}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-hmax@{force\-\_\-update\-\_\-hmax}}
\index{force\-\_\-update\-\_\-hmax@{force\-\_\-update\-\_\-hmax}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-hmax}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-hmax} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a4764c1fb83a956c1712345538630854c}
\-This function updates the hmax-\/values in tree nodes that hold \-S\-P\-H particles. \-These values are needed to find all neighbors in the hydro-\/force computation. \-Since the \-Hsml-\/values are potentially changed in the \-S\-P\-H-\/denity computation, \hyperlink{forcetree_8c_a4764c1fb83a956c1712345538630854c}{force\-\_\-update\-\_\-hmax()} should be carried out just before the hydrodynamical \-S\-P\-H forces are computed, i.\-e. after \hyperlink{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density()}. 

\-Definition at line 1014 of file forcetree.\-c.



\-References \-Domain\-End\-List, \-Domain\-Hmax, \-Domain\-My\-Last, \-Domain\-My\-Start, \-Domain\-Node\-Index, \-Domain\-Start\-List, \-Extnodes, force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local(), force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree(), \-N\-Task, \-P\-Task, \-T\-A\-G\-\_\-\-H\-M\-A\-X, and \-This\-Task.



\-Referenced by compute\-\_\-accelerations().


\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  force_update_node_hmax_local();

  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      DomainHmax[i] = Extnodes[no].hmax;
    }

  /* share the hmax-data of the pseudo-particles accross CPUs */

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainHmax[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) 
      * sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_HMAX,
                     &DomainHmax[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) 
      * sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_HMAX, MPI_COMM_WORLD, &status);
    }


  force_update_node_hmax_toptree();
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a4764c1fb83a956c1712345538630854c_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a4764c1fb83a956c1712345538630854c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a04fb647ef783d5baeb9275d806c08365}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-len@{force\-\_\-update\-\_\-len}}
\index{force\-\_\-update\-\_\-len@{force\-\_\-update\-\_\-len}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-len}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-len} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a04fb647ef783d5baeb9275d806c08365}
\-This function updates the side-\/length of tree nodes in case the tree is not reconstructed, but only drifted. \-The grouping of particles to tree nodes is not changed in this case, but some tree nodes may need to be enlarged because particles moved out of their original bounds. 

\-Definition at line 885 of file forcetree.\-c.



\-References \-Domain\-End\-List, \-Domain\-My\-Last, \-Domain\-My\-Start, \-Domain\-Node\-Index, \-Domain\-Start\-List, \-Domain\-Tree\-Node\-Len, force\-\_\-update\-\_\-node\-\_\-len\-\_\-local(), force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree(), \-Nodes, \-N\-Task, \-P\-Task, \-T\-A\-G\-\_\-\-N\-O\-D\-E\-L\-E\-N, and \-This\-Task.



\-Referenced by move\-\_\-particles().


\begin{DoxyCode}
{
  int i, no;
  MPI_Status status;
  int level, sendTask, recvTask;

  force_update_node_len_local();

  /* first update the side-lengths of all local nodes */
  for(i = DomainMyStart; i <= DomainMyLast; i++)
    {
      no = DomainNodeIndex[i];

      DomainTreeNodeLen[i] = Nodes[no].len;
    }

  for(level = 1; level < (1 << PTask); level++)
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        MPI_Sendrecv(&DomainTreeNodeLen[DomainStartList[sendTask]],
                     (DomainEndList[sendTask] - DomainStartList[sendTask] + 1) 
      * sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_NODELEN,
                     &DomainTreeNodeLen[DomainStartList[recvTask]],
                     (DomainEndList[recvTask] - DomainStartList[recvTask] + 1) 
      * sizeof(FLOAT),
                     MPI_BYTE, recvTask, TAG_NODELEN, MPI_COMM_WORLD, &status);
    }

  /* Finally, we update the top-level tree. */
  force_update_node_len_toptree();
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a04fb647ef783d5baeb9275d806c08365_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a04fb647ef783d5baeb9275d806c08365_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0292cb282788bf4e4f06636096c5abdf}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-node@{force\-\_\-update\-\_\-node}}
\index{force\-\_\-update\-\_\-node@{force\-\_\-update\-\_\-node}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-node}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-node} (
\begin{DoxyParamCaption}
\item[{int}]{no, }
\item[{int}]{flag}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0292cb282788bf4e4f06636096c5abdf}
\hypertarget{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local@{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local}}
\index{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local@{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-local} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074}
\-This routine updates the hmax-\/values of local tree nodes. 

\-Definition at line 1051 of file forcetree.\-c.



\-References \-Extnodes, \-Father, \-N\-\_\-gas, \-Nodes, and \-Sph\-P.



\-Referenced by force\-\_\-update\-\_\-hmax().


\begin{DoxyCode}
{
  int i, p, no;

  for(i = 0; i < N_gas; i++)
    {

      no = Father[i];

      if(SphP[i].Hsml > Extnodes[no].hmax)
        {

          Extnodes[no].hmax = SphP[i].Hsml;
          p = Nodes[no].u.d.father;

          while(p >= 0)
            {
              if(Extnodes[no].hmax > Extnodes[p].hmax)
                {
                  Extnodes[p].hmax = Extnodes[no].hmax;
                  no = p;
                  p = Nodes[p].u.d.father;
                }
              else
                break;
            }
        }

    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a4c108b1da2bc4f2620f62aeab90c1074_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac3f5945bb7c73936ef49af1507265afe}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree@{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree}}
\index{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree@{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-node\-\_\-hmax\-\_\-toptree} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ac3f5945bb7c73936ef49af1507265afe}
\-This function recursively sets the hmax-\/values of the top-\/level tree. 

\-Definition at line 1087 of file forcetree.\-c.



\-References \-Domain\-Hmax, \-Domain\-My\-Last, \-Domain\-Node\-Index, \-Extnodes, \-Nodes, and \-N\-Topleaves.



\-Referenced by force\-\_\-update\-\_\-hmax().


\begin{DoxyCode}
{

  int i, no, p;


  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        if(Extnodes[no].hmax < DomainHmax[i])
          Extnodes[no].hmax = DomainHmax[i];

        p = Nodes[no].u.d.father;

        while(p >= 0)
          {
            if(Extnodes[no].hmax > Extnodes[p].hmax)
              {
                Extnodes[p].hmax = Extnodes[no].hmax;
                no = p;
                p = Nodes[p].u.d.father;
              }
            else
              break;
          }
      }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac3f5945bb7c73936ef49af1507265afe_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4592b750f8555f580691103acf1e5366}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-node\-\_\-len\-\_\-local@{force\-\_\-update\-\_\-node\-\_\-len\-\_\-local}}
\index{force\-\_\-update\-\_\-node\-\_\-len\-\_\-local@{force\-\_\-update\-\_\-node\-\_\-len\-\_\-local}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-node\-\_\-len\-\_\-local}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-node\-\_\-len\-\_\-local} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a4592b750f8555f580691103acf1e5366}
\-This function recursively enlarges nodes such that they always contain all their daughter nodes and daughter particles. 

\-Definition at line 923 of file forcetree.\-c.



\-References \-Father, \-Nodes, \-Num\-Part, and \-P.



\-Referenced by force\-\_\-update\-\_\-len().


\begin{DoxyCode}
{
  int i, p, k, no;
  FLOAT dist, distmax;

  for(i = 0; i < NumPart; i++)
    {
      no = Father[i];

      for(k = 0, distmax = 0; k < 3; k++)
        {
          dist = P[i].Pos[k] - Nodes[no].center[k];
          if(dist < 0)
            dist = -dist;
          if(dist > distmax)
            distmax = dist;
        }

      if(distmax + distmax > Nodes[no].len)
        {
          Nodes[no].len = distmax + distmax;
          p = Nodes[no].u.d.father;

          while(p >= 0)
            {
              distmax = Nodes[p].center[0] - Nodes[no].center[0];
              if(distmax < 0)
                distmax = -distmax;
              distmax = distmax + distmax + Nodes[no].len;

              if(0.999999 * distmax > Nodes[p].len)
                {
                  Nodes[p].len = distmax;
                  no = p;
                  p = Nodes[p].u.d.father;
                }
              else
                break;
            }
        }
    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a4592b750f8555f580691103acf1e5366_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5f85438d619d63c812c8e05faf1f0074}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree@{force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree}}
\index{force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree@{force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-node\-\_\-len\-\_\-toptree} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a5f85438d619d63c812c8e05faf1f0074}
\-This function recursively enlarges nodes of the top-\/level tree such that they always contain all their daughter nodes. 

\-Definition at line 970 of file forcetree.\-c.



\-References \-Domain\-My\-Last, \-Domain\-Node\-Index, \-Domain\-Tree\-Node\-Len, \-Nodes, and \-N\-Topleaves.



\-Referenced by force\-\_\-update\-\_\-len().


\begin{DoxyCode}
{
  int i, no, p;
  FLOAT distmax;

  for(i = 0; i < NTopleaves; i++)
    if(i < DomainMyStart || i > DomainMyLast)
      {
        no = DomainNodeIndex[i];

        if(Nodes[no].len < DomainTreeNodeLen[i])
          Nodes[no].len = DomainTreeNodeLen[i];

        p = Nodes[no].u.d.father;

        while(p >= 0)
          {
            distmax = Nodes[p].center[0] - Nodes[no].center[0];
            if(distmax < 0)
              distmax = -distmax;
            distmax = distmax + distmax + Nodes[no].len;

            if(0.999999 * distmax > Nodes[p].len)
              {
                Nodes[p].len = distmax;
                no = p;
                p = Nodes[p].u.d.father;
              }
            else
              break;
          }
      }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5f85438d619d63c812c8e05faf1f0074_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ab745c54c805d07ad255a3f86ff77e18d}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-node\-\_\-recursive@{force\-\_\-update\-\_\-node\-\_\-recursive}}
\index{force\-\_\-update\-\_\-node\-\_\-recursive@{force\-\_\-update\-\_\-node\-\_\-recursive}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-node\-\_\-recursive}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-node\-\_\-recursive} (
\begin{DoxyParamCaption}
\item[{int}]{no, }
\item[{int}]{sib, }
\item[{int}]{father}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab745c54c805d07ad255a3f86ff77e18d}
this routine determines the multipole moments for a given internal node and all its subnodes using a recursive computation. \-The result is stored in the \-Nodes\mbox{[}\mbox{]} structure in the sequence of this tree-\/walk.

\-Note that the bitflags-\/variable for each node is used to store in the lowest bits some special information\-: \-Bit 0 flags whether the node belongs to the top-\/level tree corresponding to the domain decomposition, while \-Bit 1 signals whether the top-\/level node is dependent on local mass.

\-If \-U\-N\-E\-Q\-U\-A\-L\-S\-O\-F\-T\-E\-N\-I\-N\-G\-S is set, bits 2-\/4 give the particle type with the maximum softening among the particles in the node, and bit 5 flags whether the node contains any particles with lower softening than that. 

\-Definition at line 422 of file forcetree.\-c.



\-References \-All, \-Extnodes, \-Father, force\-\_\-update\-\_\-node\-\_\-recursive(), last, \-Max\-Nodes, \-Nextnode, \-Nodes, \-P, and \-Sph\-P.



\-Referenced by force\-\_\-treebuild\-\_\-single(), and force\-\_\-update\-\_\-node\-\_\-recursive().


\begin{DoxyCode}
{
  int j, jj, p, pp, nextsib, suns[8];
  FLOAT hmax;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
  int maxsofttype, diffsoftflag;
#else
  FLOAT maxsoft;
#endif
#endif
  struct particle_data *pa;
  double s[3], vs[3], mass;

  if(no >= All.MaxPart && no < All.MaxPart + MaxNodes)  /* internal node */
    {
      for(j = 0; j < 8; j++)
        suns[j] = Nodes[no].u.suns[j];  /* this "backup" is necessary because
       the nextnode entry will
                                           overwrite one element (union!) */
      if(last >= 0)
        {
          if(last >= All.MaxPart)
            {
              if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
                Nextnode[last - MaxNodes] = no;
              else
                Nodes[last].u.d.nextnode = no;
            }
          else
            Nextnode[last] = no;
        }

      last = no;

      mass = 0;
      s[0] = 0;
      s[1] = 0;
      s[2] = 0;
      vs[0] = 0;
      vs[1] = 0;
      vs[2] = 0;
      hmax = 0;
#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      maxsofttype = 7;
      diffsoftflag = 0;
#else
      maxsoft = 0;
#endif
#endif

      for(j = 0; j < 8; j++)
        {
          if((p = suns[j]) >= 0)
            {
              /* check if we have a sibling on the same level */
              for(jj = j + 1; jj < 8; jj++)
                if((pp = suns[jj]) >= 0)
                  break;

              if(jj < 8)        /* yes, we do */
                nextsib = pp;
              else
                nextsib = sib;

              force_update_node_recursive(p, nextsib, no);


              if(p >= All.MaxPart)      /* an internal node or pseudo particle 
      */
                {
                  if(p >= All.MaxPart + MaxNodes)       /* a pseudo particle */
                    {
                      /* nothing to be done here because the mass of the
                       * pseudo-particle is still zero. This will be changed
                       * later.
                       */
                    }
                  else
                    {
                      mass += Nodes[p].u.d.mass;
                      s[0] += Nodes[p].u.d.mass * Nodes[p].u.d.s[0];
                      s[1] += Nodes[p].u.d.mass * Nodes[p].u.d.s[1];
                      s[2] += Nodes[p].u.d.mass * Nodes[p].u.d.s[2];
                      vs[0] += Nodes[p].u.d.mass * Extnodes[p].vs[0];
                      vs[1] += Nodes[p].u.d.mass * Extnodes[p].vs[1];
                      vs[2] += Nodes[p].u.d.mass * Extnodes[p].vs[2];

                      if(Extnodes[p].hmax > hmax)
                        hmax = Extnodes[p].hmax;

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
                      diffsoftflag |= (Nodes[p].u.d.bitflags >> 5) & 1;

                      if(maxsofttype == 7)
                        {
                          maxsofttype = (Nodes[p].u.d.bitflags >> 2) & 7;
                        }
                      else
                        {
                          if(((Nodes[p].u.d.bitflags >> 2) & 7) != 7)
                            {
                              if(All.ForceSoftening[((Nodes[p].u.d.bitflags >> 
      2) & 7)] >
                                 All.ForceSoftening[maxsofttype])
                                {
                                  maxsofttype = ((Nodes[p].u.d.bitflags >> 2) &
       7);
                                  diffsoftflag = 1;
                                }
                              else
                                {
                                  if(All.ForceSoftening[((Nodes[p].u.d.bitflags
       >> 2) & 7)] <
                                     All.ForceSoftening[maxsofttype])
                                    diffsoftflag = 1;
                                }
                            }
                        }
#else
                      if(Nodes[p].maxsoft > maxsoft)
                        maxsoft = Nodes[p].maxsoft;
#endif
#endif
                    }
                }
              else              /* a particle */
                {
                  pa = &P[p];

                  mass += pa->Mass;
                  s[0] += pa->Mass * pa->Pos[0];
                  s[1] += pa->Mass * pa->Pos[1];
                  s[2] += pa->Mass * pa->Pos[2];
                  vs[0] += pa->Mass * pa->Vel[0];
                  vs[1] += pa->Mass * pa->Vel[1];
                  vs[2] += pa->Mass * pa->Vel[2];

#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
                  if(maxsofttype == 7)
                    {
                      maxsofttype = pa->Type;
                    }
                  else
                    {
                      if(All.ForceSoftening[pa->Type] > All.ForceSoftening[
      maxsofttype])
                        {
                          maxsofttype = pa->Type;
                          diffsoftflag = 1;
                        }
                      else
                        {
                          if(All.ForceSoftening[pa->Type] < All.ForceSoftening[
      maxsofttype])
                            diffsoftflag = 1;
                        }
                    }
#else
                  if(pa->Type == 0)
                    {
                      if(SphP[p].Hsml > maxsoft)
                        maxsoft = SphP[p].Hsml;
                    }
                  else
                    {
                      if(All.ForceSoftening[pa->Type] > maxsoft)
                        maxsoft = All.ForceSoftening[pa->Type];
                    }
#endif
#endif
                  if(pa->Type == 0)
                    if(SphP[p].Hsml > hmax)
                      hmax = SphP[p].Hsml;
                }
            }
        }


      if(mass)
        {
          s[0] /= mass;
          s[1] /= mass;
          s[2] /= mass;
          vs[0] /= mass;
          vs[1] /= mass;
          vs[2] /= mass;
        }
      else
        {
          s[0] = Nodes[no].center[0];
          s[1] = Nodes[no].center[1];
          s[2] = Nodes[no].center[2];
        }

      Nodes[no].u.d.s[0] = s[0];
      Nodes[no].u.d.s[1] = s[1];
      Nodes[no].u.d.s[2] = s[2];
      Nodes[no].u.d.mass = mass;


#ifdef UNEQUALSOFTENINGS
#ifndef ADAPTIVE_GRAVSOFT_FORGAS
      Nodes[no].u.d.bitflags = 4 * maxsofttype + 32 * diffsoftflag;
#else
      Nodes[no].u.d.bitflags = 0;
      Nodes[no].maxsoft = maxsoft;
#endif
#else
      Nodes[no].u.d.bitflags = 0;
#endif


      Extnodes[no].vs[0] = vs[0];
      Extnodes[no].vs[1] = vs[1];
      Extnodes[no].vs[2] = vs[2];
      Extnodes[no].hmax = hmax;

      Nodes[no].u.d.sibling = sib;
      Nodes[no].u.d.father = father;
    }
  else                          /* single particle or pseudo particle */
    {
      if(last >= 0)
        {
          if(last >= All.MaxPart)
            {
              if(last >= All.MaxPart + MaxNodes)        /* a pseudo-particle */
                Nextnode[last - MaxNodes] = no;
              else
                Nodes[last].u.d.nextnode = no;
            }
          else
            Nextnode[last] = no;
        }

      last = no;

      if(no < All.MaxPart)      /* only set it for single particles */
        Father[no] = father;
    }

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab745c54c805d07ad255a3f86ff77e18d_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ab745c54c805d07ad255a3f86ff77e18d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-pseudoparticles@{force\-\_\-update\-\_\-pseudoparticles}}
\index{force\-\_\-update\-\_\-pseudoparticles@{force\-\_\-update\-\_\-pseudoparticles}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-pseudoparticles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-pseudoparticles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0}
\-This function updates the multipole moments of the pseudo-\/particles that represent the mass distribution on different \-C\-P\-Us. \-For that purpose, it first exchanges the necessary data, and then updates the top-\/level tree accordingly. \-The detailed implementation of these two tasks is done in separate functions. 

\-Definition at line 671 of file forcetree.\-c.



\-References force\-\_\-exchange\-\_\-pseudodata(), and force\-\_\-treeupdate\-\_\-pseudos().



\-Referenced by force\-\_\-treebuild(), and move\-\_\-particles().


\begin{DoxyCode}
{
  force_exchange_pseudodata();

  force_treeupdate_pseudos();
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af9a7e3a922557e089da5d7ee1dde89a0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a207b80df2a123bc29295a0d496186d70}{\index{proto.\-h@{proto.\-h}!force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node@{force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node}}
\index{force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node@{force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node}!proto.h@{proto.\-h}}
\subsubsection[{force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf force\-\_\-update\-\_\-size\-\_\-of\-\_\-parent\-\_\-node} (
\begin{DoxyParamCaption}
\item[{int}]{no}
\end{DoxyParamCaption}
)}}\label{proto_8h_a207b80df2a123bc29295a0d496186d70}
\hypertarget{proto_8h_a99877ff0dc6228eabf8f959569f2771e}{\index{proto.\-h@{proto.\-h}!free\-\_\-memory@{free\-\_\-memory}}
\index{free\-\_\-memory@{free\-\_\-memory}!proto.h@{proto.\-h}}
\subsubsection[{free\-\_\-memory}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf free\-\_\-memory} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a99877ff0dc6228eabf8f959569f2771e}
\-This routine frees the memory for the particle storage. \-Note\-: \-We don't actually bother to call it in the code... \-When the program terminats, the memory will be automatically freed by the operating system. 

\-Definition at line 144 of file allocate.\-c.



\-References \-All, \-P, and \-Sph\-P.


\begin{DoxyCode}
{
  if(All.MaxPartSph > 0)
    free(SphP);

  if(All.MaxPart > 0)
    free(P);
}
\end{DoxyCode}
\hypertarget{proto_8h_a49492470fcccf9d05bf51993f281f16c}{\index{proto.\-h@{proto.\-h}!get\-\_\-bytes\-\_\-per\-\_\-blockelement@{get\-\_\-bytes\-\_\-per\-\_\-blockelement}}
\index{get\-\_\-bytes\-\_\-per\-\_\-blockelement@{get\-\_\-bytes\-\_\-per\-\_\-blockelement}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-bytes\-\_\-per\-\_\-blockelement}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf get\-\_\-bytes\-\_\-per\-\_\-blockelement} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr}
\end{DoxyParamCaption}
)}}\label{proto_8h_a49492470fcccf9d05bf51993f281f16c}
\-This function tells the size of one data entry in each of the blocks defined for the output file. \-If one wants to add a new output-\/block, this function should be augmented accordingly. 

\-Definition at line 366 of file io.\-c.



\-Referenced by read\-\_\-file(), and write\-\_\-file().


\begin{DoxyCode}
{
  int bytes_per_blockelement = 0;

  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
      bytes_per_blockelement = 3 * sizeof(float);
      break;

    case IO_ID:
#ifdef LONGIDS
      bytes_per_blockelement = sizeof(long long);
#else
      bytes_per_blockelement = sizeof(int);
#endif
      break;

    case IO_MASS:
    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_POT:
    case IO_DTENTR:
    case IO_TSTP:
      bytes_per_blockelement = sizeof(float);
      break;
    }

  return bytes_per_blockelement;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a49492470fcccf9d05bf51993f281f16c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a4d30ce1aad9c69d5af676a6a13173686}{\index{proto.\-h@{proto.\-h}!get\-\_\-dataset\-\_\-name@{get\-\_\-dataset\-\_\-name}}
\index{get\-\_\-dataset\-\_\-name@{get\-\_\-dataset\-\_\-name}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-dataset\-\_\-name}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf get\-\_\-dataset\-\_\-name} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr, }
\item[{char $\ast$}]{buf}
\end{DoxyParamCaption}
)}}\label{proto_8h_a4d30ce1aad9c69d5af676a6a13173686}
\-This function returns a descriptive character string that describes the name of the block when the \-H\-D\-F5 file format is used. \-If one wants to add a new output-\/block, this function should be augmented accordingly. 

\-Definition at line 613 of file io.\-c.



\-Referenced by read\-\_\-file(), and write\-\_\-file().


\begin{DoxyCode}
{

  strcpy(buf, "default");

  switch (blocknr)
    {
    case IO_POS:
      strcpy(buf, "Coordinates");
      break;
    case IO_VEL:
      strcpy(buf, "Velocities");
      break;
    case IO_ID:
      strcpy(buf, "ParticleIDs");
      break;
    case IO_MASS:
      strcpy(buf, "Masses");
      break;
    case IO_U:
      strcpy(buf, "InternalEnergy");
      break;
    case IO_RHO:
      strcpy(buf, "Density");
      break;
    case IO_HSML:
      strcpy(buf, "SmoothingLength");
      break;
    case IO_POT:
      strcpy(buf, "Potential");
      break;
    case IO_ACCEL:
      strcpy(buf, "Acceleration");
      break;
    case IO_DTENTR:
      strcpy(buf, "RateOfChangeOfEntropy");
      break;
    case IO_TSTP:
      strcpy(buf, "TimeStep");
      break;
    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a4d30ce1aad9c69d5af676a6a13173686_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_acdf59daa02f065452a596cf88b4de1a1}{\index{proto.\-h@{proto.\-h}!get\-\_\-datatype\-\_\-in\-\_\-block@{get\-\_\-datatype\-\_\-in\-\_\-block}}
\index{get\-\_\-datatype\-\_\-in\-\_\-block@{get\-\_\-datatype\-\_\-in\-\_\-block}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-datatype\-\_\-in\-\_\-block}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf get\-\_\-datatype\-\_\-in\-\_\-block} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr}
\end{DoxyParamCaption}
)}}\label{proto_8h_acdf59daa02f065452a596cf88b4de1a1}
\-This function returns the type of the data contained in a given block of the output file. \-If one wants to add a new output-\/block, this function should be augmented accordingly. 

\-Definition at line 405 of file io.\-c.



\-Referenced by read\-\_\-file(), and write\-\_\-file().


\begin{DoxyCode}
{
  int typekey;

  switch (blocknr)
    {
    case IO_ID:
#ifdef LONGIDS
      typekey = 2;              /* native long long */
#else
      typekey = 0;              /* native int */
#endif
      break;

    default:
      typekey = 1;              /* native float */
      break;
    }

  return typekey;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_acdf59daa02f065452a596cf88b4de1a1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_adadb384299eb936596574417d4b6b28c}{\index{proto.\-h@{proto.\-h}!get\-\_\-drift\-\_\-factor@{get\-\_\-drift\-\_\-factor}}
\index{get\-\_\-drift\-\_\-factor@{get\-\_\-drift\-\_\-factor}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-drift\-\_\-factor}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf get\-\_\-drift\-\_\-factor} (
\begin{DoxyParamCaption}
\item[{int}]{time0, }
\item[{int}]{time1}
\end{DoxyParamCaption}
)}}\label{proto_8h_adadb384299eb936596574417d4b6b28c}
\-This function integrates the cosmological prefactor for a drift step between time0 and time1. \-The value returned is $\ast$ \[ \int_{a_0}^{a_1} \frac{{\rm d}a}{H(a)} * \] $<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 

\-Definition at line 67 of file driftfac.\-c.



\-References \-All, \-Drift\-Table, log\-Time\-Begin, and log\-Time\-Max.



\-Referenced by move\-\_\-particles().


\begin{DoxyCode}
{
  double a1, a2, df1, df2, u1, u2;
  int i1, i2;

  /* note: will only be called for cosmological integration */

  a1 = logTimeBegin + time0 * All.Timebase_interval;
  a2 = logTimeBegin + time1 * All.Timebase_interval;

  u1 = (a1 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i1 = (int) u1;
  if(i1 >= DRIFT_TABLE_LENGTH)
    i1 = DRIFT_TABLE_LENGTH - 1;

  if(i1 <= 1)
    df1 = u1 * DriftTable[0];
  else
    df1 = DriftTable[i1 - 1] + (DriftTable[i1] - DriftTable[i1 - 1]) * (u1 - i1
      );


  u2 = (a2 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i2 = (int) u2;
  if(i2 >= DRIFT_TABLE_LENGTH)
    i2 = DRIFT_TABLE_LENGTH - 1;

  if(i2 <= 1)
    df2 = u2 * DriftTable[0];
  else
    df2 = DriftTable[i2 - 1] + (DriftTable[i2] - DriftTable[i2 - 1]) * (u2 - i2
      );

  return df2 - df1;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_adadb384299eb936596574417d4b6b28c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a29057b821b850ab54b318d7339633059}{\index{proto.\-h@{proto.\-h}!get\-\_\-gravkick\-\_\-factor@{get\-\_\-gravkick\-\_\-factor}}
\index{get\-\_\-gravkick\-\_\-factor@{get\-\_\-gravkick\-\_\-factor}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-gravkick\-\_\-factor}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf get\-\_\-gravkick\-\_\-factor} (
\begin{DoxyParamCaption}
\item[{int}]{time0, }
\item[{int}]{time1}
\end{DoxyParamCaption}
)}}\label{proto_8h_a29057b821b850ab54b318d7339633059}
\-This function integrates the cosmological prefactor for a kick step of the gravitational force. $<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 

\-Definition at line 105 of file driftfac.\-c.



\-References \-All, \-Grav\-Kick\-Table, log\-Time\-Begin, and log\-Time\-Max.



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps(), compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system(), fill\-\_\-write\-\_\-buffer(), and move\-\_\-particles().


\begin{DoxyCode}
{
  double a1, a2, df1, df2, u1, u2;
  int i1, i2;

  /* note: will only be called for cosmological integration */

  a1 = logTimeBegin + time0 * All.Timebase_interval;
  a2 = logTimeBegin + time1 * All.Timebase_interval;

  u1 = (a1 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i1 = (int) u1;
  if(i1 >= DRIFT_TABLE_LENGTH)
    i1 = DRIFT_TABLE_LENGTH - 1;

  if(i1 <= 1)
    df1 = u1 * GravKickTable[0];
  else
    df1 = GravKickTable[i1 - 1] + (GravKickTable[i1] - GravKickTable[i1 - 1]) *
       (u1 - i1);


  u2 = (a2 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i2 = (int) u2;
  if(i2 >= DRIFT_TABLE_LENGTH)
    i2 = DRIFT_TABLE_LENGTH - 1;

  if(i2 <= 1)
    df2 = u2 * GravKickTable[0];
  else
    df2 = GravKickTable[i2 - 1] + (GravKickTable[i2] - GravKickTable[i2 - 1]) *
       (u2 - i2);

  return df2 - df1;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a29057b821b850ab54b318d7339633059_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ace65dca1556185b12c7f22427724c90c}{\index{proto.\-h@{proto.\-h}!get\-\_\-hydrokick\-\_\-factor@{get\-\_\-hydrokick\-\_\-factor}}
\index{get\-\_\-hydrokick\-\_\-factor@{get\-\_\-hydrokick\-\_\-factor}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-hydrokick\-\_\-factor}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf get\-\_\-hydrokick\-\_\-factor} (
\begin{DoxyParamCaption}
\item[{int}]{time0, }
\item[{int}]{time1}
\end{DoxyParamCaption}
)}}\label{proto_8h_ace65dca1556185b12c7f22427724c90c}
\-This function integrates the cosmological prefactor for a kick step of the hydrodynamical force. $<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 

\-Definition at line 142 of file driftfac.\-c.



\-References \-All, \-Hydro\-Kick\-Table, log\-Time\-Begin, and log\-Time\-Max.



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps(), compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system(), fill\-\_\-write\-\_\-buffer(), and move\-\_\-particles().


\begin{DoxyCode}
{
  double a1, a2, df1, df2, u1, u2;
  int i1, i2;

  /* note: will only be called for cosmological integration */

  a1 = logTimeBegin + time0 * All.Timebase_interval;
  a2 = logTimeBegin + time1 * All.Timebase_interval;

  u1 = (a1 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i1 = (int) u1;
  if(i1 >= DRIFT_TABLE_LENGTH)
    i1 = DRIFT_TABLE_LENGTH - 1;

  if(i1 <= 1)
    df1 = u1 * HydroKickTable[0];
  else
    df1 = HydroKickTable[i1 - 1] + (HydroKickTable[i1] - HydroKickTable[i1 - 1]
      ) * (u1 - i1);


  u2 = (a2 - logTimeBegin) / (logTimeMax - logTimeBegin) * DRIFT_TABLE_LENGTH;
  i2 = (int) u2;
  if(i2 >= DRIFT_TABLE_LENGTH)
    i2 = DRIFT_TABLE_LENGTH - 1;

  if(i2 <= 1)
    df2 = u2 * HydroKickTable[0];
  else
    df2 = HydroKickTable[i2 - 1] + (HydroKickTable[i2] - HydroKickTable[i2 - 1]
      ) * (u2 - i2);

  return df2 - df1;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ace65dca1556185b12c7f22427724c90c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9}{\index{proto.\-h@{proto.\-h}!get\-\_\-particles\-\_\-in\-\_\-block@{get\-\_\-particles\-\_\-in\-\_\-block}}
\index{get\-\_\-particles\-\_\-in\-\_\-block@{get\-\_\-particles\-\_\-in\-\_\-block}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-particles\-\_\-in\-\_\-block}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf get\-\_\-particles\-\_\-in\-\_\-block} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr, }
\item[{int $\ast$}]{typelist}
\end{DoxyParamCaption}
)}}\label{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9}
\-This function determines how many particles there are in a given block, based on the information in the header-\/structure. \-It also flags particle types that are present in the block in the typelist array. \-If one wants to add a new output-\/block, this function should be augmented accordingly. 

\-Definition at line 465 of file io.\-c.



\-References \-All, endrun(), and header.



\-Referenced by read\-\_\-file(), and write\-\_\-file().


\begin{DoxyCode}
{
  int i, nall, ntot_withmasses, ngas, nstars;

  nall = 0;
  ntot_withmasses = 0;

  for(i = 0; i < 6; i++)
    {
      typelist[i] = 0;

      if(header.npart[i] > 0)
        {
          nall += header.npart[i];
          typelist[i] = 1;
        }

      if(All.MassTable[i] == 0)
        ntot_withmasses += header.npart[i];
    }

  ngas = header.npart[0];
  nstars = header.npart[4];


  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
    case IO_TSTP:
    case IO_ID:
    case IO_POT:
      return nall;
      break;

    case IO_MASS:
      for(i = 0; i < 6; i++)
        {
          typelist[i] = 0;
          if(All.MassTable[i] == 0 && header.npart[i] > 0)
            typelist[i] = 1;
        }
      return ntot_withmasses;
      break;

    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_DTENTR:
      for(i = 1; i < 6; i++)
        typelist[i] = 0;
      return ngas;
      break;
    }

  endrun(212);
  return 0;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5ce310b1efc19d96d530c1264fd5eca9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05}{\index{proto.\-h@{proto.\-h}!get\-\_\-random\-\_\-number@{get\-\_\-random\-\_\-number}}
\index{get\-\_\-random\-\_\-number@{get\-\_\-random\-\_\-number}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-random\-\_\-number}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf get\-\_\-random\-\_\-number} (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05}
\-This routine returns a random number taken from a table of random numbers, which is refilled every timestep. \-This method is used to allow random number application to particles independent of the number of processors used, and independent of the particular order the particles have. \-In order to work properly, the particle \-I\-Ds should be set properly to unique integer values. $<$ gives the length of a table with random numbers, refreshed at every timestep. \-This is used to allow application of random numbers to a specific particle in a way that is independent of the number of processors used. 

\-Definition at line 29 of file system.\-c.



\-References \-Rnd\-Table.



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps(), force\-\_\-treebuild\-\_\-single(), gravity\-\_\-forcetest(), and init().


\begin{DoxyCode}
{
  return RndTable[(id % RNDTABLE)];
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a0d508d57eb6f608ff6eec8ac11bb9c05_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8}{\index{proto.\-h@{proto.\-h}!get\-\_\-timestep@{get\-\_\-timestep}}
\index{get\-\_\-timestep@{get\-\_\-timestep}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-timestep}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf get\-\_\-timestep} (
\begin{DoxyParamCaption}
\item[{int}]{p, }
\item[{double $\ast$}]{aphys, }
\item[{int}]{flag}
\end{DoxyParamCaption}
)}}\label{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8}
\-This function normally (for flag==0) returns the maximum allowed timestep of a particle, expressed in terms of the integer mapping that is used to represent the total simulated timespan. \-The physical acceleration is returned in `aphys'. \-The latter is used in conjunction with the \-P\-S\-E\-U\-D\-O\-S\-Y\-M\-M\-E\-T\-R\-I\-C integration option, which also makes of the second function of get\-\_\-timestep. \-When it is called with a finite timestep for flag, it returns the physical acceleration that would lead to this timestep, assuming timestep criterion 0. $<$ adiabatic index of simulated gas

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29 
\begin{DoxyParams}{\-Parameters}
{\em p} & particle index \\
\hline
{\em aphys} & acceleration (physical units) \\
\hline
{\em flag} & either 0 for normal operation, or finite timestep to get corresponding aphys \\
\hline
\end{DoxyParams}


\-Definition at line 423 of file timestep.\-c.



\-References \-All, atime, dt\-\_\-displacement, endrun(), fac1, fac2, fac3, hubble\-\_\-a, \-P, \-Sph\-P, and \-This\-Task.



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps().


\begin{DoxyCode}
{
  double ax, ay, az, ac, csnd;
  double dt = 0, dt_courant = 0, dt_accel;
  int ti_step;

#ifdef CONDUCTION
  double dt_cond;
#endif

  if(flag == 0)
    {
      ax = fac1 * P[p].GravAccel[0];
      ay = fac1 * P[p].GravAccel[1];
      az = fac1 * P[p].GravAccel[2];

#ifdef PMGRID
      ax += fac1 * P[p].GravPM[0];
      ay += fac1 * P[p].GravPM[1];
      az += fac1 * P[p].GravPM[2];
#endif

      if(P[p].Type == 0)
        {
          ax += fac2 * SphP[p].HydroAccel[0];
          ay += fac2 * SphP[p].HydroAccel[1];
          az += fac2 * SphP[p].HydroAccel[2];
        }

      ac = sqrt(ax * ax + ay * ay + az * az);   /* this is now the physical
       acceleration */
      *aphys = ac;
    }
  else
    ac = *aphys;

  if(ac == 0)
    ac = 1.0e-30;

  switch (All.TypeOfTimestepCriterion)
    {
    case 0:
      if(flag > 0)
        {
          dt = flag * All.Timebase_interval;
          dt /= hubble_a;       /* convert dloga to physical timestep  */
          ac = 2 * All.ErrTolIntAccuracy * atime * All.SofteningTable[P[p].Type
      ] / (dt * dt);
          *aphys = ac;
          return flag;
        }
      dt = dt_accel = sqrt(2 * All.ErrTolIntAccuracy * atime * All.
      SofteningTable[P[p].Type] / ac);
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(P[p].Type == 0)
        dt = dt_accel = sqrt(2 * All.ErrTolIntAccuracy * atime * SphP[p].Hsml /
       2.8 / ac);
#endif
      break;
    default:
      endrun(888);
      break;
    }

  if(P[p].Type == 0)
    {
      csnd = sqrt(GAMMA * SphP[p].Pressure / SphP[p].Density);

      if(All.ComovingIntegrationOn)
        dt_courant = 2 * All.CourantFac * All.Time * SphP[p].Hsml / (fac3 * SphP
      [p].MaxSignalVel);
      else
        dt_courant = 2 * All.CourantFac * SphP[p].Hsml / SphP[p].MaxSignalVel;

      if(dt_courant < dt)
        dt = dt_courant;
    }

  /* convert the physical timestep to dloga if needed. Note: If comoving
       integration has not been selected,
     hubble_a=1.
   */
  dt *= hubble_a;

  if(dt >= All.MaxSizeTimestep)
    dt = All.MaxSizeTimestep;

  if(dt >= dt_displacement)
    dt = dt_displacement;

  if(dt < All.MinSizeTimestep)
    {
#ifndef NOSTOP_WHEN_BELOW_MINTIMESTEP
      printf("warning: Timestep wants to be below the limit `MinSizeTimestep'\n
      ");

      if(P[p].Type == 0)
        {
          printf
            ("Part-ID=%d  dt=%g dtc=%g ac=%g xyz=(%g|%g|%g)  hsml=%g 
       maxsignalvel=%g dt0=%g eps=%g\n",
             (int) P[p].ID, dt, dt_courant * hubble_a, ac, P[p].Pos[0], P[p].
      Pos[1], P[p].Pos[2],
             SphP[p].Hsml, SphP[p].MaxSignalVel,
             sqrt(2 * All.ErrTolIntAccuracy * atime * All.SofteningTable[P[p].
      Type] / ac) * hubble_a,
             All.SofteningTable[P[p].Type]);
        }
      else
        {
          printf("Part-ID=%d  dt=%g ac=%g xyz=(%g|%g|%g)\n", (int) P[p].ID, dt,
       ac, P[p].Pos[0], P[p].Pos[1],
                 P[p].Pos[2]);
        }
      fflush(stdout);
      endrun(888);
#endif
      dt = All.MinSizeTimestep;
    }

  ti_step = dt / All.Timebase_interval;

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  if(P[p].dTi_selfInt > 0)
    {
      if(P[p].dTi_selfInt < ti_step)
        ti_step = P[p].dTi_selfInt;
      else
        P[p].dTi_selfInt = 0;
      
      if(ti_step*All.Timebase_interval < All.MinSizeTimestep)
        printf("Warning: A Timestep below the limit`MinSizeTimestep' is being
       used to keep self interaction probabilities smaller than one. dt = %g\n",ti_step*
      All.Timebase_interval);
    }
#endif

  if(!(ti_step > 0 && ti_step < TIMEBASE))
    {
      printf("\nError: A timestep of size zero was assigned on the integer
       timeline!\n"
             "We better stop.\n"
             "Task=%d Part-ID=%d dt=%g tibase=%g ti_step=%d ac=%g
       xyz=(%g|%g|%g) tree=(%g|%g%g)\n\n",
             ThisTask, (int) P[p].ID, dt, All.Timebase_interval, ti_step, ac,
             P[p].Pos[0], P[p].Pos[1], P[p].Pos[2], P[p].GravAccel[0], P[p].
      GravAccel[1], P[p].GravAccel[2]);
#ifdef PMGRID
      printf("pm_force=(%g|%g|%g)\n", P[p].GravPM[0], P[p].GravPM[1], P[p].
      GravPM[2]);
#endif
      if(P[p].Type == 0)
        printf("hydro-frc=(%g|%g|%g)\n", SphP[p].HydroAccel[0], SphP[p].
      HydroAccel[1], SphP[p].HydroAccel[2]);

      fflush(stdout);
      endrun(818);
    }

  return ti_step;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a1d72b071e6cb4691ecc0da4de4cb8af8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a3892776d6528c51f720d2a48deb2486f}{\index{proto.\-h@{proto.\-h}!get\-\_\-values\-\_\-per\-\_\-blockelement@{get\-\_\-values\-\_\-per\-\_\-blockelement}}
\index{get\-\_\-values\-\_\-per\-\_\-blockelement@{get\-\_\-values\-\_\-per\-\_\-blockelement}!proto.h@{proto.\-h}}
\subsubsection[{get\-\_\-values\-\_\-per\-\_\-blockelement}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf get\-\_\-values\-\_\-per\-\_\-blockelement} (
\begin{DoxyParamCaption}
\item[{enum iofields}]{blocknr}
\end{DoxyParamCaption}
)}}\label{proto_8h_a3892776d6528c51f720d2a48deb2486f}
\-This function informs about the number of elements stored per particle for the given block of the output file. \-If one wants to add a new output-\/block, this function should be augmented accordingly. 

\-Definition at line 432 of file io.\-c.



\-Referenced by read\-\_\-file(), and write\-\_\-file().


\begin{DoxyCode}
{
  int values = 0;

  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
      values = 3;
      break;

    case IO_ID:
    case IO_MASS:
    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_POT:
    case IO_DTENTR:
    case IO_TSTP:
      values = 1;
      break;
    }

  return values;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a3892776d6528c51f720d2a48deb2486f_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae9c157451dcc4cdbe02813141df2be42}{\index{proto.\-h@{proto.\-h}!grav\-\_\-tree\-\_\-compare\-\_\-key@{grav\-\_\-tree\-\_\-compare\-\_\-key}}
\index{grav\-\_\-tree\-\_\-compare\-\_\-key@{grav\-\_\-tree\-\_\-compare\-\_\-key}!proto.h@{proto.\-h}}
\subsubsection[{grav\-\_\-tree\-\_\-compare\-\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf grav\-\_\-tree\-\_\-compare\-\_\-key} (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{proto_8h_ae9c157451dcc4cdbe02813141df2be42}
\-This function is used as a comparison kernel in a sort routine. \-It is used to group particles in the communication buffer that are going to be sent to the same \-C\-P\-U. 

\-Definition at line 551 of file gravtree.\-c.



\-Referenced by compute\-\_\-potential(), gravity\-\_\-forcetest(), and gravity\-\_\-tree().


\begin{DoxyCode}
{
  if(((struct gravdata_index *) a)->Task < (((struct gravdata_index *) b)->Task
      ))
    return -1;

  if(((struct gravdata_index *) a)->Task > (((struct gravdata_index *) b)->Task
      ))
    return +1;

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae9c157451dcc4cdbe02813141df2be42_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79}{\index{proto.\-h@{proto.\-h}!gravity\-\_\-forcetest@{gravity\-\_\-forcetest}}
\index{gravity\-\_\-forcetest@{gravity\-\_\-forcetest}!proto.h@{proto.\-h}}
\subsubsection[{gravity\-\_\-forcetest}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf gravity\-\_\-forcetest} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79}
\-This routine does the test of the gravitational tree force by computing the force for a random subset of particles with direct summation. 

\-Definition at line 28 of file gravtree\-\_\-forcetest.\-c.



\-References \-All, endrun(), \-Exportflag, fac1, \-Fd\-Force\-Test, \-Fd\-Timings, force\-\_\-treeevaluate\-\_\-direct(), get\-\_\-random\-\_\-number(), grav\-\_\-tree\-\_\-compare\-\_\-key(), \-Grav\-Data\-Get, \-Grav\-Data\-In, \-Grav\-Data\-Index\-Table, \-Grav\-Data\-Out, \-Grav\-Data\-Result, \-N\-Task, \-Num\-Force\-Update, \-Num\-Part, \-P, \-P\-Task, second(), set\-\_\-softenings(), \-T\-A\-G\-\_\-\-D\-I\-R\-E\-C\-T\-\_\-\-A, \-T\-A\-G\-\_\-\-D\-I\-R\-E\-C\-T\-\_\-\-B, \-This\-Task, timediff(), and \-Time\-Of\-Last\-Tree\-Construction.



\-Referenced by compute\-\_\-accelerations().


\begin{DoxyCode}
{
  int ntot, iter = 0, ntotleft, nthis;
  double tstart, tend, timetree = 0;
  int i, j, ndone, ngrp, maxfill, place, ndonetot;

#ifndef NOGRAVITY
  int *noffset, *nbuffer, *nsend, *nsend_local;
  int k, nexport;
  int level, sendTask, recvTask;
  double fac1;
  MPI_Status status;
#endif
  double costtotal, *costtreelist;
  double maxt, sumt, *timetreelist;
  double fac;
  char buf[200];

#ifdef PMGRID
  if(All.PM_Ti_endstep != All.Ti_Current)
    return;
#endif

  if(All.ComovingIntegrationOn)
    set_softenings();           /* set new softening lengths */

  for(i = 0, NumForceUpdate = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          if(get_random_number(P[i].ID) < FORCETEST)
            {
              P[i].Ti_endstep = -P[i].Ti_endstep - 1;
              NumForceUpdate++;
            }
        }
    }

  /* NumForceUpdate is the number of particles on this processor that want a
       force update */

  MPI_Allreduce(&NumForceUpdate, &ntot, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

  costtotal = 0;

  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common
       list */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);

  i = 0;                        /* beginn with this index */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      iter++;

      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      tstart = second();
      for(nexport = 0, ndone = 0; i < NumPart && nexport < All.BunchSizeForce -
       NTask; i++)
        if(P[i].Ti_endstep < 0)
          {
            ndone++;

            for(j = 0; j < NTask; j++)
              Exportflag[j] = 1;
            Exportflag[ThisTask] = 0;

            costtotal += force_treeevaluate_direct(i, 0);

            for(j = 0; j < NTask; j++)
              {
                if(Exportflag[j])
                  {
                    for(k = 0; k < 3; k++)
                      GravDataGet[nexport].u.Pos[k] = P[i].Pos[k];

#ifdef UNEQUALSOFTENINGS
                    GravDataGet[nexport].Type = P[i].Type;
#endif
                    GravDataGet[nexport].w.OldAcc = P[i].OldAcc;

                    GravDataIndexTable[nexport].Task = j;
                    GravDataIndexTable[nexport].Index = i;
                    GravDataIndexTable[nexport].SortIndex = nexport;

                    nexport++;
                    nsend_local[j]++;
                  }
              }
          }
      tend = second();
      timetree += timediff(tstart, tend);

      qsort(GravDataIndexTable, nexport, sizeof(struct gravdata_index), 
      grav_tree_compare_key);

      for(j = 0; j < nexport; j++)
        GravDataIn[j] = GravDataGet[GravDataIndexTable[j].SortIndex];

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, 
      MPI_COMM_WORLD);

      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&GravDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in), MPI_BYTE,
                                   recvTask, TAG_DIRECT_A,
                                   &GravDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct gravdata_in), MPI_BYTE,
                                   recvTask, TAG_DIRECT_A, MPI_COMM_WORLD, &
      status);
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          tstart = second();
          for(j = 0; j < nbuffer[ThisTask]; j++)
            {
              costtotal += force_treeevaluate_direct(j, 1);
            }
          tend = second();
          timetree += timediff(tstart, tend);


          /* get the result */
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;
              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&GravDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct gravdata_in),
                                   MPI_BYTE, recvTask, TAG_DIRECT_B,
                                   &GravDataOut[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in),
                                   MPI_BYTE, recvTask, TAG_DIRECT_B, 
      MPI_COMM_WORLD, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          place = GravDataIndexTable[noffset[recvTask] + j].
      Index;

                          for(k = 0; k < 3; k++)
                            P[place].GravAccelDirect[k] += GravDataOut[j + 
      noffset[recvTask]].u.Acc[k];
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }

          level = ngrp - 1;
        }

      MPI_Allreduce(&ndone, &ndonetot, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);

      ntotleft -= ndonetot;
    }

  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* now add things for comoving integration */

  if(All.ComovingIntegrationOn)
    {
#ifndef PERIODIC
      fac1 = 0.5 * All.Hubble * All.Hubble * All.Omega0 / All.G;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep < 0)
          for(j = 0; j < 3; j++)
            P[i].GravAccelDirect[j] += fac1 * P[i].Pos[j];
#endif
    }



  /*  muliply by G */

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      for(j = 0; j < 3; j++)
        P[i].GravAccelDirect[j] *= All.G;



  /* Finally, the following factor allows a computation of cosmological
       simulation 
     with vacuum energy in physical coordinates */

  if(All.ComovingIntegrationOn == 0)
    {
      fac1 = All.OmegaLambda * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep < 0)
          for(j = 0; j < 3; j++)
            P[i].GravAccelDirect[j] += fac1 * P[i].Pos[j];
    }

  /* now output the forces to a file */

  for(nthis = 0; nthis < NTask; nthis++)
    {
      if(nthis == ThisTask)
        {
          sprintf(buf, "%s%s", All.OutputDir, "forcetest.txt");
          if(!(FdForceTest = fopen(buf, "a")))
            {
              printf("error in opening file '%s'\n", buf);
              endrun(17);
            }
          for(i = 0; i < NumPart; i++)
            if(P[i].Ti_endstep < 0)
              {
#ifndef PMGRID
                fprintf(FdForceTest, "%d %g %g %g %g %g %g %g %g %g %g %g\n",
                        P[i].Type, All.Time, All.Time - 
      TimeOfLastTreeConstruction,
                        P[i].Pos[0], P[i].Pos[1], P[i].Pos[2],
                        P[i].GravAccelDirect[0], P[i].GravAccelDirect[1], P[i].
      GravAccelDirect[2],
                        P[i].GravAccel[0], P[i].GravAccel[1], P[i].GravAccel[2]
      );
#else
                fprintf(FdForceTest, "%d %g %g %g %g %g %g %g %g %g %g %g %g %g
       %g\n",
                        P[i].Type, All.Time, All.Time - 
      TimeOfLastTreeConstruction,
                        P[i].Pos[0], P[i].Pos[1], P[i].Pos[2],
                        P[i].GravAccelDirect[0], P[i].GravAccelDirect[1], P[i].
      GravAccelDirect[2],
                        P[i].GravAccel[0], P[i].GravAccel[1], P[i].GravAccel[2]
      ,
                        P[i].GravPM[0] + P[i].GravAccel[0],
                        P[i].GravPM[1] + P[i].GravAccel[1], P[i].GravPM[2] + P[
      i].GravAccel[2]);
#endif
              }
          fclose(FdForceTest);
        }
      MPI_Barrier(MPI_COMM_WORLD);
    }

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;

  /* Now the force computation is finished */



  timetreelist = malloc(sizeof(double) * NTask);
  costtreelist = malloc(sizeof(double) * NTask);

  MPI_Gather(&costtotal, 1, MPI_DOUBLE, costtreelist, 1, MPI_DOUBLE, 0, 
      MPI_COMM_WORLD);
  MPI_Gather(&timetree, 1, MPI_DOUBLE, timetreelist, 1, MPI_DOUBLE, 0, 
      MPI_COMM_WORLD);

  if(ThisTask == 0)
    {
      fac = NTask / ((double) All.TotNumPart);

      for(i = 0, maxt = timetreelist[0], sumt = 0, costtotal = 0; i < NTask; i+
      +)
        {
          costtotal += costtreelist[i];

          if(maxt < timetreelist[i])
            maxt = timetreelist[i];
          sumt += timetreelist[i];
        }

      fprintf(FdTimings, "DIRECT Nf= %d    part/sec=%g | %g  ia/part=%g \n", 
      ntot, ntot / (sumt + 1.0e-20),
              ntot / (maxt * NTask), ((double) (costtotal)) / ntot);
      fprintf(FdTimings, "\n");

      fflush(FdTimings);
    }

  free(costtreelist);
  free(timetreelist);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a51b074bdf1ec1efc0f7a323415a47e79_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac559dc2aeb21d5a379a3751bea7736af}{\index{proto.\-h@{proto.\-h}!gravity\-\_\-tree@{gravity\-\_\-tree}}
\index{gravity\-\_\-tree@{gravity\-\_\-tree}!proto.h@{proto.\-h}}
\subsubsection[{gravity\-\_\-tree}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf gravity\-\_\-tree} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ac559dc2aeb21d5a379a3751bea7736af}
\-This function computes the gravitational forces for all active particles. \-If needed, a new tree is constructed, otherwise the dynamically updated tree is used. \-Particles are only exported to other processors when really needed, thereby allowing a good use of the communication buffer. 

\-Definition at line 27 of file gravtree.\-c.



\-References \-All, \-Exportflag, \-Fd\-Timings, force\-\_\-treebuild(), force\-\_\-treeevaluate(), force\-\_\-treeevaluate\-\_\-shortrange(), grav\-\_\-tree\-\_\-compare\-\_\-key(), \-Grav\-Data\-Get, \-Grav\-Data\-In, \-Grav\-Data\-Index\-Table, \-Grav\-Data\-Out, \-Grav\-Data\-Result, \-N\-Task, \-Num\-Force\-Update, \-Numnodestree, \-Num\-Part, \-P, \-P\-Task, second(), set\-\_\-softenings(), \-Sph\-P, \-T\-A\-G\-\_\-\-G\-R\-A\-V\-\_\-\-A, \-T\-A\-G\-\_\-\-G\-R\-A\-V\-\_\-\-B, \-This\-Task, timediff(), and \-Tree\-Reconstruct\-Flag.



\-Referenced by compute\-\_\-accelerations().


\begin{DoxyCode}
{
  long long ntot;
  int numnodes, nexportsum = 0;
  int i, j, iter = 0;
  int *numnodeslist, maxnumnodes, nexport, *numlist, *nrecv, *ndonelist;
  double tstart, tend, timetree = 0, timecommsumm = 0, timeimbalance = 0, 
      sumimbalance;
  double ewaldcount;
  double costtotal, ewaldtot, *costtreelist, *ewaldlist;
  double maxt, sumt, *timetreelist, *timecommlist;
  double fac, plb, plb_max, sumcomm;

#ifndef NOGRAVITY
  int *noffset, *nbuffer, *nsend, *nsend_local;
  long long ntotleft;
  int ndone, maxfill, ngrp;
  int k, place;
  int level, sendTask, recvTask;
  double ax, ay, az;
  MPI_Status status;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  unsigned long *Nself_interactionsList;
#endif

  /* set new softening lengths */
  if(All.ComovingIntegrationOn)
    set_softenings();


  /* contruct tree if needed */
  tstart = second();
  if(TreeReconstructFlag)
    {
      if(ThisTask == 0)
        printf("Tree construction.\n");

      force_treebuild(NumPart);

      TreeReconstructFlag = 0;

      if(ThisTask == 0)
        printf("Tree construction done.\n");
    }
  tend = second();
  All.CPU_TreeConstruction += timediff(tstart, tend);

  costtotal = ewaldcount = 0;

  /* Note: 'NumForceUpdate' has already been determined in
       find_next_sync_point_and_drift() */
  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumForceUpdate, 1, MPI_INT, numlist, 1, MPI_INT, 
      MPI_COMM_WORLD);
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);


#ifndef NOGRAVITY
  if(ThisTask == 0)
    printf("Begin tree force.\n");


#ifdef SELECTIVE_NO_GRAVITY
  for(i = 0; i < NumPart; i++)
    if(((1 << P[i].Type) & (SELECTIVE_NO_GRAVITY)))
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;
#endif

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  All.Nself_interactions = 0;
  All.Nself_interactionsSum = 0;
  for (i = 0; i < INTERACTION_TABLE_LENGTH; i++)
    for(j = 0; j < PARTICLE_MAX_INTERACTIONS + 1; j++)
      InteractionTable[i][j] = 0;
#endif

  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common
       list */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  i = 0;                        /* beginn with this index */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      iter++;

      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      tstart = second();
      for(nexport = 0, ndone = 0; i < NumPart && nexport < All.BunchSizeForce -
       NTask; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          {
            ndone++;

            for(j = 0; j < NTask; j++)
              Exportflag[j] = 0;
#ifndef PMGRID
            costtotal += force_treeevaluate(i, 0, &ewaldcount);
#else
            costtotal += force_treeevaluate_shortrange(i, 0);
#endif
            for(j = 0; j < NTask; j++)
              {
                if(Exportflag[j])
                  {
                    for(k = 0; k < 3; k++)
                      GravDataGet[nexport].u.Pos[k] = P[i].Pos[k];
#ifdef COMPUTE_SELFINTERACTION_FORDARK
                    for(k = 0; k < 3; k++)
                      GravDataGet[nexport].Vel[k] = P[i].Vel[k];                
        
                    GravDataGet[nexport].Ti_begstep = P[i].Ti_begstep;
                    GravDataGet[nexport].Ti_endstep = P[i].Ti_endstep;
                    GravDataGet[nexport].dTi_selfInt = P[i].dTi_selfInt;
                    GravDataGet[nexport].ID = P[i].ID;
                    GravDataGet[nexport].Type = P[i].Type;
#endif
#ifdef UNEQUALSOFTENINGS
                    GravDataGet[nexport].Type = P[i].Type;
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
                    if(P[i].Type == 0)
                      GravDataGet[nexport].Soft = SphP[i].Hsml;
#endif
#endif
                    GravDataGet[nexport].w.OldAcc = P[i].OldAcc;
                    GravDataIndexTable[nexport].Task = j;
                    GravDataIndexTable[nexport].Index = i;
                    GravDataIndexTable[nexport].SortIndex = nexport;
                    nexport++;
                    nexportsum++;
                    nsend_local[j]++;
                  }
              }
          }
      tend = second();
      timetree += timediff(tstart, tend);

      qsort(GravDataIndexTable, nexport, sizeof(struct gravdata_index), 
      grav_tree_compare_key);

      for(j = 0; j < nexport; j++)
        GravDataIn[j] = GravDataGet[GravDataIndexTable[j].SortIndex];

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      tstart = second();

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, 
      MPI_COMM_WORLD);

      tend = second();
      timeimbalance += timediff(tstart, tend);

      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&GravDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in), MPI_BYTE,
                                   recvTask, TAG_GRAV_A,
                                   &GravDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct gravdata_in), MPI_BYTE,
                                   recvTask, TAG_GRAV_A, MPI_COMM_WORLD, &
      status);
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);


          tstart = second();
          for(j = 0; j < nbuffer[ThisTask]; j++)
            {
#ifndef PMGRID
              costtotal += force_treeevaluate(j, 1, &ewaldcount);
#else
              costtotal += force_treeevaluate_shortrange(j, 1);
#endif
            }
          tend = second();
          timetree += timediff(tstart, tend);

          tstart = second();
          MPI_Barrier(MPI_COMM_WORLD);
          tend = second();
          timeimbalance += timediff(tstart, tend);

          /* get the result */
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeForce)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;
              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&GravDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct gravdata_in),
                                   MPI_BYTE, recvTask, TAG_GRAV_B,
                                   &GravDataOut[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      gravdata_in),
                                   MPI_BYTE, recvTask, TAG_GRAV_B, 
      MPI_COMM_WORLD, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          place = GravDataIndexTable[noffset[recvTask] + j].
      Index;

                          for(k = 0; k < 3; k++)
                            P[place].GravAccel[k] += GravDataOut[j + noffset[
      recvTask]].u.Acc[k];
#ifdef COMPUTE_SELFINTERACTION_FORDARK
                          if( All.ErrTolTheta == 0 || All.
      TypeOfOpeningCriterion == 0)
                            {
                              for(k = 0; k < 3; k++)
                                P[place].Vel[k] += GravDataOut[j + noffset[
      recvTask]].Vel[k];
                              P[place].dTi_selfInt = GravDataOut[j + noffset[
      recvTask]].dTi_selfInt;
                            }
#endif
                          P[place].GravCost += GravDataOut[j + noffset[recvTask
      ]].w.Ninteractions;
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);

          level = ngrp - 1;
        }

      MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD);
      for(j = 0; j < NTask; j++)
        ntotleft -= ndonelist[j];
    }

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);

  /* now add things for comoving integration */

#ifndef PERIODIC
#ifndef PMGRID
  if(All.ComovingIntegrationOn)
    {
      fac = 0.5 * All.Hubble * All.Hubble * All.Omega0 / All.G;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          for(j = 0; j < 3; j++)
            P[i].GravAccel[j] += fac * P[i].Pos[j];
    }
#endif
#endif

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      {
#ifdef PMGRID
        ax = P[i].GravAccel[0] + P[i].GravPM[0] / All.G;
        ay = P[i].GravAccel[1] + P[i].GravPM[1] / All.G;
        az = P[i].GravAccel[2] + P[i].GravPM[2] / All.G;
#else
        ax = P[i].GravAccel[0];
        ay = P[i].GravAccel[1];
        az = P[i].GravAccel[2];
#endif
        P[i].OldAcc = sqrt(ax * ax + ay * ay + az * az);
      }


  if(All.TypeOfOpeningCriterion == 1)
    All.ErrTolTheta = 0;        /* This will switch to the relative opening
       criterion for the following force computations */

  /*  muliply by G */
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      for(j = 0; j < 3; j++)
        P[i].GravAccel[j] *= All.G;


  /* Finally, the following factor allows a computation of a cosmological
       simulation 
     with vacuum energy in physical coordinates */
#ifndef PERIODIC
#ifndef PMGRID
  if(All.ComovingIntegrationOn == 0)
    {
      fac = All.OmegaLambda * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          for(j = 0; j < 3; j++)
            P[i].GravAccel[j] += fac * P[i].Pos[j];
    }
#endif
#endif

#ifdef SELECTIVE_NO_GRAVITY
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;
#endif

  if(ThisTask == 0)
    printf("tree is done.\n");

#else /* gravity is switched off */

  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      for(j = 0; j < 3; j++)
        P[i].GravAccel[j] = 0;

#endif




  /* Now the force computation is finished */

  /*  gather some diagnostic information */

  timetreelist = malloc(sizeof(double) * NTask);
  timecommlist = malloc(sizeof(double) * NTask);
  costtreelist = malloc(sizeof(double) * NTask);
  numnodeslist = malloc(sizeof(int) * NTask);
  ewaldlist = malloc(sizeof(double) * NTask);
  nrecv = malloc(sizeof(int) * NTask);

  numnodes = Numnodestree;

  MPI_Gather(&costtotal, 1, MPI_DOUBLE, costtreelist, 1, MPI_DOUBLE, 0, 
      MPI_COMM_WORLD);
  MPI_Gather(&numnodes, 1, MPI_INT, numnodeslist, 1, MPI_INT, 0, MPI_COMM_WORLD
      );
  MPI_Gather(&timetree, 1, MPI_DOUBLE, timetreelist, 1, MPI_DOUBLE, 0, 
      MPI_COMM_WORLD);
  MPI_Gather(&timecommsumm, 1, MPI_DOUBLE, timecommlist, 1, MPI_DOUBLE, 0, 
      MPI_COMM_WORLD);
  MPI_Gather(&NumPart, 1, MPI_INT, nrecv, 1, MPI_INT, 0, MPI_COMM_WORLD);
  MPI_Gather(&ewaldcount, 1, MPI_DOUBLE, ewaldlist, 1, MPI_DOUBLE, 0, 
      MPI_COMM_WORLD);
  MPI_Reduce(&nexportsum, &nexport, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, 
      MPI_COMM_WORLD);

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  Nself_interactionsList = malloc(sizeof(unsigned long) * NTask);
  MPI_Gather(&All.Nself_interactions, 1, MPI_UNSIGNED_LONG, 
      Nself_interactionsList, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);
  if(ThisTask == 0)
    {
      for(i = 0; i < NTask; i++)
        {
          All.Nself_interactionsSum += Nself_interactionsList[i];
        }
    }
  free(Nself_interactionsList);  
#endif

  if(ThisTask == 0)
    {
      All.TotNumOfForces += ntot;

      fprintf(FdTimings, "Step= %d  t= %g  dt= %g \n", All.NumCurrentTiStep, All
      .Time, All.TimeStep);
      fprintf(FdTimings, "Nf= %d%09d  total-Nf= %d%09d  ex-frac= %g  iter= %d\n
      ",
              (int) (ntot / 1000000000), (int) (ntot % 1000000000),
              (int) (All.TotNumOfForces / 1000000000), (int) (All.
      TotNumOfForces % 1000000000),
              nexport / ((double) ntot), iter);
      /* note: on Linux, the 8-byte integer could be printed with the format
       identifier "%qd", but doesn't work on AIX */

      fac = NTask / ((double) All.TotNumPart);

      for(i = 0, maxt = timetreelist[0], sumt = 0, plb_max = 0,
          maxnumnodes = 0, costtotal = 0, sumcomm = 0, ewaldtot = 0; i < NTask;
       i++)
        {
          costtotal += costtreelist[i];

          sumcomm += timecommlist[i];

          if(maxt < timetreelist[i])
            maxt = timetreelist[i];
          sumt += timetreelist[i];

          plb = nrecv[i] * fac;

          if(plb > plb_max)
            plb_max = plb;

          if(numnodeslist[i] > maxnumnodes)
            maxnumnodes = numnodeslist[i];

          ewaldtot += ewaldlist[i];
        }
      fprintf(FdTimings, "work-load balance: %g  max=%g avg=%g PE0=%g\n",
              maxt / (sumt / NTask), maxt, sumt / NTask, timetreelist[0]);
      fprintf(FdTimings, "particle-load balance: %g\n", plb_max);
      fprintf(FdTimings, "max. nodes: %d, filled: %g\n", maxnumnodes,
              maxnumnodes / (All.TreeAllocFactor * All.MaxPart));
      fprintf(FdTimings, "part/sec=%g | %g  ia/part=%g (%g)\n", ntot / (sumt + 
      1.0e-20),
              ntot / (maxt * NTask), ((double) (costtotal)) / ntot, ((double) 
      ewaldtot) / ntot);
      fprintf(FdTimings, "\n");

      fflush(FdTimings);

      All.CPU_TreeWalk += sumt / NTask;
      All.CPU_Imbalance += sumimbalance / NTask;
      All.CPU_CommSum += sumcomm / NTask;
    }

  free(nrecv);
  free(ewaldlist);
  free(numnodeslist);
  free(costtreelist);
  free(timecommlist);
  free(timetreelist);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac559dc2aeb21d5a379a3751bea7736af_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac559dc2aeb21d5a379a3751bea7736af_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a483c8f5e73b8445bbb44e3bab59f2f1d}{\index{proto.\-h@{proto.\-h}!gravity\-\_\-tree\-\_\-shortrange@{gravity\-\_\-tree\-\_\-shortrange}}
\index{gravity\-\_\-tree\-\_\-shortrange@{gravity\-\_\-tree\-\_\-shortrange}!proto.h@{proto.\-h}}
\subsubsection[{gravity\-\_\-tree\-\_\-shortrange}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf gravity\-\_\-tree\-\_\-shortrange} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a483c8f5e73b8445bbb44e3bab59f2f1d}
\hypertarget{proto_8h_a2eafe05fb12d7f9d954d5b501e186051}{\index{proto.\-h@{proto.\-h}!gravkick\-\_\-integ@{gravkick\-\_\-integ}}
\index{gravkick\-\_\-integ@{gravkick\-\_\-integ}!proto.h@{proto.\-h}}
\subsubsection[{gravkick\-\_\-integ}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf gravkick\-\_\-integ} (
\begin{DoxyParamCaption}
\item[{double}]{a, }
\item[{void $\ast$}]{param}
\end{DoxyParamCaption}
)}}\label{proto_8h_a2eafe05fb12d7f9d954d5b501e186051}
\-Integration kernel for gravitational kick factor computation. 

\-Definition at line 191 of file driftfac.\-c.



\-References \-All.



\-Referenced by init\-\_\-drift\-\_\-table().


\begin{DoxyCode}
{
  double h;

  h = All.Omega0 / (a * a * a) + (1 - All.Omega0 - All.OmegaLambda) / (a * a) +
       All.OmegaLambda;
  h = All.Hubble * sqrt(h);

  return 1 / (h * a * a);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a2eafe05fb12d7f9d954d5b501e186051_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a}{\index{proto.\-h@{proto.\-h}!hydro\-\_\-compare\-\_\-key@{hydro\-\_\-compare\-\_\-key}}
\index{hydro\-\_\-compare\-\_\-key@{hydro\-\_\-compare\-\_\-key}!proto.h@{proto.\-h}}
\subsubsection[{hydro\-\_\-compare\-\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf hydro\-\_\-compare\-\_\-key} (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{a, }
\item[{const void $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a}
\-This is a comparison kernel for a sort routine, which is used to group particles that are going to be exported to the same \-C\-P\-U. 

\-Definition at line 563 of file hydra.\-c.



\-Referenced by hydro\-\_\-force().


\begin{DoxyCode}
{
  if(((struct hydrodata_in *) a)->Task < (((struct hydrodata_in *) b)->Task))
    return -1;
  if(((struct hydrodata_in *) a)->Task > (((struct hydrodata_in *) b)->Task))
    return +1;
  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a8331f87f49dedbeb9e7d61d0deb8926a_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e}{\index{proto.\-h@{proto.\-h}!hydro\-\_\-evaluate@{hydro\-\_\-evaluate}}
\index{hydro\-\_\-evaluate@{hydro\-\_\-evaluate}!proto.h@{proto.\-h}}
\subsubsection[{hydro\-\_\-evaluate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf hydro\-\_\-evaluate} (
\begin{DoxyParamCaption}
\item[{int}]{target, }
\item[{int}]{mode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e}
\-This function is the 'core' of the \-S\-P\-H force computation. \-A target particle is specified which may either be local, or reside in the communication buffer. $<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 

\-Definition at line 353 of file hydra.\-c.



\-References \-All, box\-Half\-\_\-\-X, box\-Half\-\_\-\-Y, box\-Half\-\_\-\-Z, box\-Size\-\_\-\-X, box\-Size\-\_\-\-Y, box\-Size\-\_\-\-Z, dmin(), fac\-\_\-mu, fac\-\_\-vsic\-\_\-fix, hubble\-\_\-a2, \-Hydro\-Data\-Get, \-Hydro\-Data\-Result, imax(), ngb\-\_\-treefind\-\_\-pairs(), \-Ngblist, \-P, and \-Sph\-P.



\-Referenced by hydro\-\_\-force().


\begin{DoxyCode}
{
  int j, k, n, timestep, startnode, numngb;
  FLOAT *pos, *vel;
  FLOAT mass, h_i, dhsmlDensityFactor, rho, pressure, f1, f2;
  double acc[3], dtEntropy, maxSignalVel;
  double dx, dy, dz, dvx, dvy, dvz;
  double h_i2, hinv, hinv4;
  double p_over_rho2_i, p_over_rho2_j, soundspeed_i, soundspeed_j;
  double hfc, dwk_i, vdotr, vdotr2, visc, mu_ij, rho_ij, vsig;
  double h_j, dwk_j, r, r2, u, hfc_visc;

#ifndef NOVISCOSITYLIMITER
  double dt;
#endif

  if(mode == 0)
    {
      pos = P[target].Pos;
      vel = SphP[target].VelPred;
      h_i = SphP[target].Hsml;
      mass = P[target].Mass;
      dhsmlDensityFactor = SphP[target].DhsmlDensityFactor;
      rho = SphP[target].Density;
      pressure = SphP[target].Pressure;
      timestep = P[target].Ti_endstep - P[target].Ti_begstep;
      soundspeed_i = sqrt(GAMMA * pressure / rho);
      f1 = fabs(SphP[target].DivVel) /
        (fabs(SphP[target].DivVel) + SphP[target].CurlVel +
         0.0001 * soundspeed_i / SphP[target].Hsml / fac_mu);
    }
  else
    {
      pos = HydroDataGet[target].Pos;
      vel = HydroDataGet[target].Vel;
      h_i = HydroDataGet[target].Hsml;
      mass = HydroDataGet[target].Mass;
      dhsmlDensityFactor = HydroDataGet[target].DhsmlDensityFactor;
      rho = HydroDataGet[target].Density;
      pressure = HydroDataGet[target].Pressure;
      timestep = HydroDataGet[target].Timestep;
      soundspeed_i = sqrt(GAMMA * pressure / rho);
      f1 = HydroDataGet[target].F1;
    }


  /* initialize variables before SPH loop is started */
  acc[0] = acc[1] = acc[2] = dtEntropy = 0;
  maxSignalVel = 0;

  p_over_rho2_i = pressure / (rho * rho) * dhsmlDensityFactor;
  h_i2 = h_i * h_i;

  /* Now start the actual SPH computation for this particle */
  startnode = All.MaxPart;
  do
    {
      numngb = ngb_treefind_pairs(&pos[0], h_i, &startnode);

      for(n = 0; n < numngb; n++)
        {
          j = Ngblist[n];

          dx = pos[0] - P[j].Pos[0];
          dy = pos[1] - P[j].Pos[1];
          dz = pos[2] - P[j].Pos[2];

#ifdef PERIODIC                 /*  find the closest image in the given box
       size  */
          if(dx > boxHalf_X)
            dx -= boxSize_X;
          if(dx < -boxHalf_X)
            dx += boxSize_X;
          if(dy > boxHalf_Y)
            dy -= boxSize_Y;
          if(dy < -boxHalf_Y)
            dy += boxSize_Y;
          if(dz > boxHalf_Z)
            dz -= boxSize_Z;
          if(dz < -boxHalf_Z)
            dz += boxSize_Z;
#endif
          r2 = dx * dx + dy * dy + dz * dz;
          h_j = SphP[j].Hsml;
          if(r2 < h_i2 || r2 < h_j * h_j)
            {
              r = sqrt(r2);
              if(r > 0)
                {
                  p_over_rho2_j = SphP[j].Pressure / (SphP[j].Density * SphP[j]
      .Density);
                  soundspeed_j = sqrt(GAMMA * p_over_rho2_j * SphP[j].Density);
                  dvx = vel[0] - SphP[j].VelPred[0];
                  dvy = vel[1] - SphP[j].VelPred[1];
                  dvz = vel[2] - SphP[j].VelPred[2];
                  vdotr = dx * dvx + dy * dvy + dz * dvz;

                  if(All.ComovingIntegrationOn)
                    vdotr2 = vdotr + hubble_a2 * r2;
                  else
                    vdotr2 = vdotr;

                  if(r2 < h_i2)
                    {
                      hinv = 1.0 / h_i;
#ifndef  TWODIMS
                      hinv4 = hinv * hinv * hinv * hinv;
#else
                      hinv4 = hinv * hinv * hinv / boxSize_Z;
#endif
                      u = r * hinv;
                      if(u < 0.5)
                        dwk_i = hinv4 * u * (KERNEL_COEFF_3 * u - 
      KERNEL_COEFF_4);
                      else
                        dwk_i = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                    }
                  else
                    {
                      dwk_i = 0;
                    }

                  if(r2 < h_j * h_j)
                    {
                      hinv = 1.0 / h_j;
#ifndef  TWODIMS
                      hinv4 = hinv * hinv * hinv * hinv;
#else
                      hinv4 = hinv * hinv * hinv / boxSize_Z;
#endif
                      u = r * hinv;
                      if(u < 0.5)
                        dwk_j = hinv4 * u * (KERNEL_COEFF_3 * u - 
      KERNEL_COEFF_4);
                      else
                        dwk_j = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                    }
                  else
                    {
                      dwk_j = 0;
                    }

                  if(soundspeed_i + soundspeed_j > maxSignalVel)
                    maxSignalVel = soundspeed_i + soundspeed_j;

                  if(vdotr2 < 0)        /* ... artificial viscosity */
                    {
                      mu_ij = fac_mu * vdotr2 / r;      /* note: this is
       negative! */

                      vsig = soundspeed_i + soundspeed_j - 3 * mu_ij;

                      if(vsig > maxSignalVel)
                        maxSignalVel = vsig;

                      rho_ij = 0.5 * (rho + SphP[j].Density);
                      f2 =
                        fabs(SphP[j].DivVel) / (fabs(SphP[j].DivVel) + SphP[j].
      CurlVel +
                                                0.0001 * soundspeed_j / fac_mu 
      / SphP[j].Hsml);

                      visc = 0.25 * All.ArtBulkViscConst * vsig * (-mu_ij) / 
      rho_ij * (f1 + f2);

                      /* .... end artificial viscosity evaluation */
#ifndef NOVISCOSITYLIMITER
                      /* make sure that viscous acceleration is not too large 
      */
                      dt = imax(timestep, (P[j].Ti_endstep - P[j].Ti_begstep)) 
      * All.Timebase_interval;
                      if(dt > 0 && (dwk_i + dwk_j) < 0)
                        {
                          visc = dmin(visc, 0.5 * fac_vsic_fix * vdotr2 /
                                      (0.5 * (mass + P[j].Mass) * (dwk_i + 
      dwk_j) * r * dt));
                        }
#endif
                    }
                  else
                    visc = 0;

                  p_over_rho2_j *= SphP[j].DhsmlDensityFactor;

                  hfc_visc = 0.5 * P[j].Mass * visc * (dwk_i + dwk_j) / r;

                  hfc = hfc_visc + P[j].Mass * (p_over_rho2_i * dwk_i + 
      p_over_rho2_j * dwk_j) / r;

                  acc[0] -= hfc * dx;
                  acc[1] -= hfc * dy;
                  acc[2] -= hfc * dz;
                  dtEntropy += 0.5 * hfc_visc * vdotr2;
                }
            }
        }
    }
  while(startnode >= 0);

  /* Now collect the result at the right place */
  if(mode == 0)
    {
      for(k = 0; k < 3; k++)
        SphP[target].HydroAccel[k] = acc[k];
      SphP[target].DtEntropy = dtEntropy;
      SphP[target].MaxSignalVel = maxSignalVel;
    }
  else
    {
      for(k = 0; k < 3; k++)
        HydroDataResult[target].Acc[k] = acc[k];
      HydroDataResult[target].DtEntropy = dtEntropy;
      HydroDataResult[target].MaxSignalVel = maxSignalVel;
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a818695254c9525e01bc9ddc95e8eaf7e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a6789381bce7d1c316df8ecf04b47a607}{\index{proto.\-h@{proto.\-h}!hydro\-\_\-force@{hydro\-\_\-force}}
\index{hydro\-\_\-force@{hydro\-\_\-force}!proto.h@{proto.\-h}}
\subsubsection[{hydro\-\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf hydro\-\_\-force} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a6789381bce7d1c316df8ecf04b47a607}
\-This function is the driver routine for the calculation of hydrodynamical force and rate of change of entropy due to shock heating for all active particles . $<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 

\-Definition at line 50 of file hydra.\-c.



\-References a3inv, \-All, atime, box\-Half, box\-Half\-\_\-\-X, box\-Half\-\_\-\-Y, box\-Half\-\_\-\-Z, box\-Size, box\-Size\-\_\-\-X, box\-Size\-\_\-\-Y, box\-Size\-\_\-\-Z, \-Exportflag, fac\-\_\-egy, fac\-\_\-mu, fac\-\_\-vsic\-\_\-fix, hubble\-\_\-a, hubble\-\_\-a2, hydro\-\_\-compare\-\_\-key(), hydro\-\_\-evaluate(), \-Hydro\-Data\-Get, \-Hydro\-Data\-In, \-Hydro\-Data\-Partial\-Result, \-Hydro\-Data\-Result, \-N\-\_\-gas, \-N\-Task, \-Num\-Sph\-Update, \-P, pow(), \-P\-Task, second(), \-Sph\-P, \-T\-A\-G\-\_\-\-H\-Y\-D\-R\-O\-\_\-\-A, \-T\-A\-G\-\_\-\-H\-Y\-D\-R\-O\-\_\-\-B, \-This\-Task, and timediff().



\-Referenced by compute\-\_\-accelerations().


\begin{DoxyCode}
{
  long long ntot, ntotleft;
  int i, j, k, n, ngrp, maxfill, source, ndone;
  int *nbuffer, *noffset, *nsend_local, *nsend, *numlist, *ndonelist;
  int level, sendTask, recvTask, nexport, place;
  double soundspeed_i;
  double tstart, tend, sumt, sumcomm;
  double timecomp = 0, timecommsumm = 0, timeimbalance = 0, sumimbalance;
  MPI_Status status;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif

  if(All.ComovingIntegrationOn)
    {
      /* Factors for comoving integration of hydro */
      hubble_a = All.Omega0 / (All.Time * All.Time * All.Time)
        + (1 - All.Omega0 - All.OmegaLambda) / (All.Time * All.Time) + All.
      OmegaLambda;

      hubble_a = All.Hubble * sqrt(hubble_a);
      hubble_a2 = All.Time * All.Time * hubble_a;

      fac_mu = pow(All.Time, 3 * (GAMMA - 1) / 2) / All.Time;

      fac_egy = pow(All.Time, 3 * (GAMMA - 1));

      fac_vsic_fix = hubble_a * pow(All.Time, 3 * GAMMA_MINUS1);

      a3inv = 1 / (All.Time * All.Time * All.Time);
      atime = All.Time;
    }
  else
    hubble_a = hubble_a2 = atime = fac_mu = fac_vsic_fix = a3inv = fac_egy = 1.
      0;


  /* `NumSphUpdate' gives the number of particles on this processor that want a
       force update */
  for(n = 0, NumSphUpdate = 0; n < N_gas; n++)
    {
      if(P[n].Ti_endstep == All.Ti_Current)
        NumSphUpdate++;
    }

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumSphUpdate, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD)
      ;
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);


  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common
       list */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);


  i = 0;                        /* first particle for this task */
  ntotleft = ntot;              /* particles left for all tasks together */

  while(ntotleft > 0)
    {
      for(j = 0; j < NTask; j++)
        nsend_local[j] = 0;

      /* do local particles and prepare export list */
      tstart = second();
      for(nexport = 0, ndone = 0; i < N_gas && nexport < All.BunchSizeHydro - 
      NTask; i++)
        if(P[i].Ti_endstep == All.Ti_Current)
          {
            ndone++;

            for(j = 0; j < NTask; j++)
              Exportflag[j] = 0;

            hydro_evaluate(i, 0);

            for(j = 0; j < NTask; j++)
              {
                if(Exportflag[j])
                  {
                    for(k = 0; k < 3; k++)
                      {
                        HydroDataIn[nexport].Pos[k] = P[i].Pos[k];
                        HydroDataIn[nexport].Vel[k] = SphP[i].VelPred[k];
                      }
                    HydroDataIn[nexport].Hsml = SphP[i].Hsml;
                    HydroDataIn[nexport].Mass = P[i].Mass;
                    HydroDataIn[nexport].DhsmlDensityFactor = SphP[i].
      DhsmlDensityFactor;
                    HydroDataIn[nexport].Density = SphP[i].Density;
                    HydroDataIn[nexport].Pressure = SphP[i].Pressure;
                    HydroDataIn[nexport].Timestep = P[i].Ti_endstep - P[i].
      Ti_begstep;

                    /* calculation of F1 */
                    soundspeed_i = sqrt(GAMMA * SphP[i].Pressure / SphP[i].
      Density);
                    HydroDataIn[nexport].F1 = fabs(SphP[i].DivVel) /
                      (fabs(SphP[i].DivVel) + SphP[i].CurlVel +
                       0.0001 * soundspeed_i / SphP[i].Hsml / fac_mu);

                    HydroDataIn[nexport].Index = i;
                    HydroDataIn[nexport].Task = j;
                    nexport++;
                    nsend_local[j]++;
                  }
              }
          }
      tend = second();
      timecomp += timediff(tstart, tend);

      qsort(HydroDataIn, nexport, sizeof(struct hydrodata_in), hydro_compare_key
      );

      for(j = 1, noffset[0] = 0; j < NTask; j++)
        noffset[j] = noffset[j - 1] + nsend_local[j - 1];

      tstart = second();

      MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, 
      MPI_COMM_WORLD);

      tend = second();
      timeimbalance += timediff(tstart, tend);



      /* now do the particles that need to be exported */

      for(level = 1; level < (1 << PTask); level++)
        {
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeHydro)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* get the particles */
                      MPI_Sendrecv(&HydroDataIn[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      hydrodata_in), MPI_BYTE,
                                   recvTask, TAG_HYDRO_A,
                                   &HydroDataGet[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct hydrodata_in), MPI_BYTE,
                                   recvTask, TAG_HYDRO_A, MPI_COMM_WORLD, &
      status);
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);

          /* now do the imported particles */
          tstart = second();
          for(j = 0; j < nbuffer[ThisTask]; j++)
            hydro_evaluate(j, 1);
          tend = second();
          timecomp += timediff(tstart, tend);

          /* do a block to measure imbalance */
          tstart = second();
          MPI_Barrier(MPI_COMM_WORLD);
          tend = second();
          timeimbalance += timediff(tstart, tend);

          /* get the result */
          tstart = second();
          for(j = 0; j < NTask; j++)
            nbuffer[j] = 0;
          for(ngrp = level; ngrp < (1 << PTask); ngrp++)
            {
              maxfill = 0;
              for(j = 0; j < NTask; j++)
                {
                  if((j ^ ngrp) < NTask)
                    if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                      maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                }
              if(maxfill >= All.BunchSizeHydro)
                break;

              sendTask = ThisTask;
              recvTask = ThisTask ^ ngrp;

              if(recvTask < NTask)
                {
                  if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask *
       NTask + ThisTask] > 0)
                    {
                      /* send the results */
                      MPI_Sendrecv(&HydroDataResult[nbuffer[ThisTask]],
                                   nsend[recvTask * NTask + ThisTask] * sizeof(
      struct hydrodata_out),
                                   MPI_BYTE, recvTask, TAG_HYDRO_B,
                                   &HydroDataPartialResult[noffset[recvTask]],
                                   nsend_local[recvTask] * sizeof(struct 
      hydrodata_out),
                                   MPI_BYTE, recvTask, TAG_HYDRO_B, 
      MPI_COMM_WORLD, &status);

                      /* add the result to the particles */
                      for(j = 0; j < nsend_local[recvTask]; j++)
                        {
                          source = j + noffset[recvTask];
                          place = HydroDataIn[source].Index;

                          for(k = 0; k < 3; k++)
                            SphP[place].HydroAccel[k] += HydroDataPartialResult
      [source].Acc[k];

                          SphP[place].DtEntropy += HydroDataPartialResult[
      source].DtEntropy;

                          if(SphP[place].MaxSignalVel < HydroDataPartialResult[
      source].MaxSignalVel)
                            SphP[place].MaxSignalVel = HydroDataPartialResult[
      source].MaxSignalVel;
                        }
                    }
                }

              for(j = 0; j < NTask; j++)
                if((j ^ ngrp) < NTask)
                  nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
            }
          tend = second();
          timecommsumm += timediff(tstart, tend);

          level = ngrp - 1;
        }

      MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD);
      for(j = 0; j < NTask; j++)
        ntotleft -= ndonelist[j];
    }

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);



  /* do final operations on results */
  tstart = second();

  for(i = 0; i < N_gas; i++)
    if(P[i].Ti_endstep == All.Ti_Current)
      {
        SphP[i].DtEntropy *= GAMMA_MINUS1 / (hubble_a2 * pow(SphP[i].Density, 
      GAMMA_MINUS1));
#ifdef SPH_BND_PARTICLES
        if(P[i].ID == 0)
          {
            SphP[i].DtEntropy = 0;
            for(k = 0; k < 3; k++)
              SphP[i].HydroAccel[k] = 0;
          }
#endif
      }

  tend = second();
  timecomp += timediff(tstart, tend);

  /* collect some timing information */

  MPI_Reduce(&timecomp, &sumt, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecommsumm, &sumcomm, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD
      );
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, 
      MPI_COMM_WORLD);

  if(ThisTask == 0)
    {
      All.CPU_HydCompWalk += sumt / NTask;
      All.CPU_HydCommSumm += sumcomm / NTask;
      All.CPU_HydImbalance += sumimbalance / NTask;
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a6789381bce7d1c316df8ecf04b47a607_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a6789381bce7d1c316df8ecf04b47a607_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d}{\index{proto.\-h@{proto.\-h}!hydrokick\-\_\-integ@{hydrokick\-\_\-integ}}
\index{hydrokick\-\_\-integ@{hydrokick\-\_\-integ}!proto.h@{proto.\-h}}
\subsubsection[{hydrokick\-\_\-integ}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf hydrokick\-\_\-integ} (
\begin{DoxyParamCaption}
\item[{double}]{a, }
\item[{void $\ast$}]{param}
\end{DoxyParamCaption}
)}}\label{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d}
\-Integration kernel for hydrodynamical kick factor computation. $<$ adiabatic index of simulated gas 

\-Definition at line 204 of file driftfac.\-c.



\-References \-All, and pow().



\-Referenced by init\-\_\-drift\-\_\-table().


\begin{DoxyCode}
{
  double h;

  h = All.Omega0 / (a * a * a) + (1 - All.Omega0 - All.OmegaLambda) / (a * a) +
       All.OmegaLambda;
  h = All.Hubble * sqrt(h);

  return 1 / (h * pow(a, 3 * GAMMA_MINUS1) * a);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=244pt]{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5ebdee2c7332bed6c1a8994ac3c38c0d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a05ba897ffe0dfe737254a09c91c50d10}{\index{proto.\-h@{proto.\-h}!imax@{imax}}
\index{imax@{imax}!proto.h@{proto.\-h}}
\subsubsection[{imax}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf imax} (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y}
\end{DoxyParamCaption}
)}}\label{proto_8h_a05ba897ffe0dfe737254a09c91c50d10}
returns the maximum of two integers 

\-Definition at line 111 of file system.\-c.



\-Referenced by hydro\-\_\-evaluate(), and pm\-\_\-init\-\_\-periodic\-\_\-allocate().


\begin{DoxyCode}
{
  if(x > y)
    return x;
  else
    return y;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a05ba897ffe0dfe737254a09c91c50d10_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af52841aeeb1b5bf6787e1e2036088644}{\index{proto.\-h@{proto.\-h}!imin@{imin}}
\index{imin@{imin}!proto.h@{proto.\-h}}
\subsubsection[{imin}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf imin} (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y}
\end{DoxyParamCaption}
)}}\label{proto_8h_af52841aeeb1b5bf6787e1e2036088644}
returns the minimum of two integers 

\-Definition at line 121 of file system.\-c.



\-Referenced by domain\-\_\-find\-Exchange\-Numbers().


\begin{DoxyCode}
{
  if(x < y)
    return x;
  else
    return y;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af52841aeeb1b5bf6787e1e2036088644_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a2858154e2009b0e6e616f313177762bc}{\index{proto.\-h@{proto.\-h}!init@{init}}
\index{init@{init}!proto.h@{proto.\-h}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf init} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a2858154e2009b0e6e616f313177762bc}
\-This function reads the initial conditions, and allocates storage for the tree. \-Various variables of the particle data are initialised and \-An intial domain decomposition is performed. \-If \-S\-P\-H particles are present, the inial \-S\-P\-H smoothing lengths are determined. $<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ defines maximum length of neighbour list

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas 

\-Definition at line 20 of file init.\-c.



\-References \-All, check\-\_\-omega(), domain\-\_\-\-Decomposition(), endrun(), \-Flag\-\_\-\-Full\-Step, force\-\_\-treeallocate(), get\-\_\-random\-\_\-number(), header, \-N\-\_\-gas, ngb\-\_\-treeallocate(), ngb\-\_\-treebuild(), \-Num\-Part, \-P, pow(), read\-\_\-ic(), \-Restart\-Flag, seed\-\_\-glass(), set\-\_\-softenings(), setup\-\_\-smoothinglengths(), \-Sph\-P, \-This\-Task, and \-Tree\-Reconstruct\-Flag.



\-Referenced by begrun().


\begin{DoxyCode}
{
  int i, j;
  double a3;

  All.Time = All.TimeBegin;

  switch (All.ICFormat)
    {
    case 1:
#if (MAKEGLASS > 1)
      seed_glass();
#else
      read_ic(All.InitCondFile);
#endif
      break;
    case 2:
    case 3:
      read_ic(All.InitCondFile);
      break;
    default:
      if(ThisTask == 0)
        printf("ICFormat=%d not supported.\n", All.ICFormat);
      endrun(0);
    }

  All.Time = All.TimeBegin;
  All.Ti_Current = 0;

  if(All.ComovingIntegrationOn)
    {
      All.Timebase_interval = (log(All.TimeMax) - log(All.TimeBegin)) / 
      TIMEBASE;
      a3 = All.Time * All.Time * All.Time;
    }
  else
    {
      All.Timebase_interval = (All.TimeMax - All.TimeBegin) / TIMEBASE;
      a3 = 1;
    }

  set_softenings();

  All.NumCurrentTiStep = 0;     /* setup some counters */
  All.SnapshotFileCount = 0;

  if(RestartFlag == 2)
    All.SnapshotFileCount = atoi(All.InitCondFile + strlen(All.InitCondFile) - 
      3) + 1;

  All.TotNumOfForces = 0;
  All.NumForcesSinceLastDomainDecomp = 0;

  if(All.ComovingIntegrationOn)
    if(All.PeriodicBoundariesOn == 1)
      check_omega();

  All.TimeLastStatistics = All.TimeBegin - All.TimeBetStatistics;

  if(All.ComovingIntegrationOn) /*  change to new velocity variable */
    {
      for(i = 0; i < NumPart; i++)
        for(j = 0; j < 3; j++)
          P[i].Vel[j] *= sqrt(All.Time) * All.Time;
    }

  for(i = 0; i < NumPart; i++)  /*  start-up initialization */
    {
      for(j = 0; j < 3; j++)
        P[i].GravAccel[j] = 0;
#ifdef PMGRID
      for(j = 0; j < 3; j++)
        P[i].GravPM[j] = 0;
#endif
      P[i].Ti_endstep = 0;
      P[i].Ti_begstep = 0;

      P[i].OldAcc = 0;
      P[i].GravCost = 1;
      P[i].Potential = 0;
    }

#ifdef PMGRID
  All.PM_Ti_endstep = All.PM_Ti_begstep = 0;
#endif

#ifdef FLEXSTEPS
  All.PresentMinStep = TIMEBASE;
  for(i = 0; i < NumPart; i++)  /*  start-up initialization */
    {
      P[i].FlexStepGrp = (int) (TIMEBASE * get_random_number(P[i].ID));
    }
#endif


  for(i = 0; i < N_gas; i++)    /* initialize sph_properties */
    {
      for(j = 0; j < 3; j++)
        {
          SphP[i].VelPred[j] = P[i].Vel[j];
          SphP[i].HydroAccel[j] = 0;
        }

      SphP[i].DtEntropy = 0;

      if(RestartFlag == 0)
        {
          SphP[i].Hsml = 0;
          SphP[i].Density = -1;
        }
    }

  ngb_treeallocate(MAX_NGB);

  force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);

  All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;

  Flag_FullStep = 1;            /* to ensure that Peano-Hilber order is done */

  domain_Decomposition();       /* do initial domain decomposition (gives equal
       numbers of particles) */

  ngb_treebuild();              /* will build tree */

  setup_smoothinglengths();

  TreeReconstructFlag = 1;

  /* at this point, the entropy variable normally contains the 
   * internal energy, read in from the initial conditions file, unless the file
   * explicitly signals that the initial conditions contain the entropy
       directly. 
   * Once the density has been computed, we can convert thermal energy to
       entropy.
   */
#ifndef ISOTHERM_EQS
  if(header.flag_entropy_instead_u == 0)
    for(i = 0; i < N_gas; i++)
      SphP[i].Entropy = GAMMA_MINUS1 * SphP[i].Entropy / pow(SphP[i].Density / 
      a3, GAMMA_MINUS1);
#endif
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{proto_8h_a2858154e2009b0e6e616f313177762bc_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=276pt]{proto_8h_a2858154e2009b0e6e616f313177762bc_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aea1f81063199abb9d89802b444098018}{\index{proto.\-h@{proto.\-h}!init\-\_\-drift\-\_\-table@{init\-\_\-drift\-\_\-table}}
\index{init\-\_\-drift\-\_\-table@{init\-\_\-drift\-\_\-table}!proto.h@{proto.\-h}}
\subsubsection[{init\-\_\-drift\-\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf init\-\_\-drift\-\_\-table} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aea1f81063199abb9d89802b444098018}
\-This function computes look-\/up tables for factors needed in cosmological integrations. \-The (simple) integrations are carried out with the \-G\-S\-L library. \-Separate factors are computed for the \char`\"{}drift\char`\"{}, and the gravitational and hydrodynamical \char`\"{}kicks\char`\"{}. \-The lookup-\/table is used for reasons of speed. $<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors

$<$ length of the lookup table used to hold the drift and kick factors 

\-Definition at line 26 of file driftfac.\-c.



\-References \-All, drift\-\_\-integ(), \-Drift\-Table, gravkick\-\_\-integ(), \-Grav\-Kick\-Table, hydrokick\-\_\-integ(), \-Hydro\-Kick\-Table, log\-Time\-Begin, log\-Time\-Max, \-W\-O\-R\-K\-S\-I\-Z\-E, and workspace.



\-Referenced by begrun().


\begin{DoxyCode}
{
#define WORKSIZE 100000
  int i;
  double result, abserr;
  gsl_function F;
  gsl_integration_workspace *workspace;

  logTimeBegin = log(All.TimeBegin);
  logTimeMax = log(All.TimeMax);

  workspace = gsl_integration_workspace_alloc(WORKSIZE);

  for(i = 0; i < DRIFT_TABLE_LENGTH; i++)
    {
      F.function = &drift_integ;
      gsl_integration_qag(&F, exp(logTimeBegin), exp(logTimeBegin + ((logTimeMax
       - logTimeBegin) / DRIFT_TABLE_LENGTH) * (i + 1)), 0,
                          1.0e-8, WORKSIZE, GSL_INTEG_GAUSS41, workspace, &
      result, &abserr);
      DriftTable[i] = result;


      F.function = &gravkick_integ;
      gsl_integration_qag(&F, exp(logTimeBegin), exp(logTimeBegin + ((logTimeMax
       - logTimeBegin) / DRIFT_TABLE_LENGTH) * (i + 1)), 0,
                          1.0e-8, WORKSIZE, GSL_INTEG_GAUSS41, workspace, &
      result, &abserr);
      GravKickTable[i] = result;


      F.function = &hydrokick_integ;
      gsl_integration_qag(&F, exp(logTimeBegin), exp(logTimeBegin + ((logTimeMax
       - logTimeBegin) / DRIFT_TABLE_LENGTH) * (i + 1)), 0,
                          1.0e-8, WORKSIZE, GSL_INTEG_GAUSS41, workspace, &
      result, &abserr);
      HydroKickTable[i] = result;
    }

  gsl_integration_workspace_free(workspace);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aea1f81063199abb9d89802b444098018_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{proto_8h_aea1f81063199abb9d89802b444098018_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a5052a0489feb425d7d910e57d7ad8102}{\index{proto.\-h@{proto.\-h}!init\-\_\-peano\-\_\-map@{init\-\_\-peano\-\_\-map}}
\index{init\-\_\-peano\-\_\-map@{init\-\_\-peano\-\_\-map}!proto.h@{proto.\-h}}
\subsubsection[{init\-\_\-peano\-\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf init\-\_\-peano\-\_\-map} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a5052a0489feb425d7d910e57d7ad8102}
\hypertarget{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25}{\index{proto.\-h@{proto.\-h}!long\-\_\-range\-\_\-force@{long\-\_\-range\-\_\-force}}
\index{long\-\_\-range\-\_\-force@{long\-\_\-range\-\_\-force}!proto.h@{proto.\-h}}
\subsubsection[{long\-\_\-range\-\_\-force}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf long\-\_\-range\-\_\-force} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25}
\-This function is a driver routine for the long-\/range \-P\-M force computation. \-It calls periodic and/or non-\/periodic \-F\-F\-T routines as needed for the present simulation set-\/up. 

\-Definition at line 56 of file longrange.\-c.



\-References \-All, endrun(), \-Num\-Part, \-P, pm\-\_\-init\-\_\-regionsize(), pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel(), pmforce\-\_\-nonperiodic(), and pmforce\-\_\-periodic().



\-Referenced by compute\-\_\-accelerations().


\begin{DoxyCode}
{
  int i;

#ifndef PERIODIC
  int j;
  double fac;
#endif


  for(i = 0; i < NumPart; i++)
    P[i].GravPM[0] = P[i].GravPM[1] = P[i].GravPM[2] = 0;

#ifdef NOGRAVITY
  return;
#endif


#ifdef PERIODIC
  pmforce_periodic();
#ifdef PLACEHIGHRESREGION
  i = pmforce_nonperiodic(1);
  if(i == 1)                    /* this is returned if a particle lied outside
       allowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmforce_nonperiodic(1);       /* try again */
    }
  if(i == 1)
    endrun(68686);
#endif
#else
  i = pmforce_nonperiodic(0);
  if(i == 1)                    /* this is returned if a particle lied outside
       allowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();
      i = pmforce_nonperiodic(0);       /* try again */
    }
  if(i == 1)
    endrun(68687);
#ifdef PLACEHIGHRESREGION
  i = pmforce_nonperiodic(1);
  if(i == 1)                    /* this is returned if a particle lied outside
       allowed range */
    {
      pm_init_regionsize();
      pm_setup_nonperiodic_kernel();

      /* try again */

      for(i = 0; i < NumPart; i++)
        P[i].GravPM[0] = P[i].GravPM[1] = P[i].GravPM[2] = 0;

      i = pmforce_nonperiodic(0) + pmforce_nonperiodic(1);
    }
  if(i != 0)
    endrun(68688);
#endif
#endif


#ifndef PERIODIC
  if(All.ComovingIntegrationOn)
    {
      fac = 0.5 * All.Hubble * All.Hubble * All.Omega0;

      for(i = 0; i < NumPart; i++)
        for(j = 0; j < 3; j++)
          P[i].GravPM[j] += fac * P[i].Pos[j];
    }


  /* Finally, the following factor allows a computation of cosmological
       simulation 
     with vacuum energy in physical coordinates */

  if(All.ComovingIntegrationOn == 0)
    {
      fac = All.OmegaLambda * All.Hubble * All.Hubble;

      for(i = 0; i < NumPart; i++)
        for(j = 0; j < 3; j++)
          P[i].GravPM[j] += fac * P[i].Pos[j];
    }
#endif

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a5989a3f57c7d6dfdef205dc6b72a1d25_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af52079f2c63002aca9463ba0b13727df}{\index{proto.\-h@{proto.\-h}!long\-\_\-range\-\_\-init@{long\-\_\-range\-\_\-init}}
\index{long\-\_\-range\-\_\-init@{long\-\_\-range\-\_\-init}!proto.h@{proto.\-h}}
\subsubsection[{long\-\_\-range\-\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf long\-\_\-range\-\_\-init} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_af52079f2c63002aca9463ba0b13727df}
\-Calls initializiation routines of periodic or/and non-\/periodic \-F\-F\-T routines. 

\-Definition at line 20 of file longrange.\-c.



\-References pm\-\_\-init\-\_\-nonperiodic(), and pm\-\_\-init\-\_\-periodic().



\-Referenced by begrun().


\begin{DoxyCode}
{
#ifdef PERIODIC
  pm_init_periodic();
#ifdef PLACEHIGHRESREGION
  pm_init_nonperiodic();
#endif
#else
  pm_init_nonperiodic();
#endif
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_af52079f2c63002aca9463ba0b13727df_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=334pt]{proto_8h_af52079f2c63002aca9463ba0b13727df_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad295b3023b3d8fad337637a640362262}{\index{proto.\-h@{proto.\-h}!long\-\_\-range\-\_\-init\-\_\-regionsize@{long\-\_\-range\-\_\-init\-\_\-regionsize}}
\index{long\-\_\-range\-\_\-init\-\_\-regionsize@{long\-\_\-range\-\_\-init\-\_\-regionsize}!proto.h@{proto.\-h}}
\subsubsection[{long\-\_\-range\-\_\-init\-\_\-regionsize}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf long\-\_\-range\-\_\-init\-\_\-regionsize} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad295b3023b3d8fad337637a640362262}
\-This function calls subroutines that determine the spatial region covered by the \-P\-M mesh. 

\-Definition at line 36 of file longrange.\-c.



\-References pm\-\_\-init\-\_\-regionsize(), pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel(), and \-Restart\-Flag.



\-Referenced by begrun().


\begin{DoxyCode}
{
#ifdef PERIODIC
#ifdef PLACEHIGHRESREGION
  if(RestartFlag != 1)
    pm_init_regionsize();
  pm_setup_nonperiodic_kernel();
#endif
#else
  if(RestartFlag != 1)
    pm_init_regionsize();
  pm_setup_nonperiodic_kernel();
#endif
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad295b3023b3d8fad337637a640362262_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad295b3023b3d8fad337637a640362262_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31}{\index{proto.\-h@{proto.\-h}!move\-\_\-particles@{move\-\_\-particles}}
\index{move\-\_\-particles@{move\-\_\-particles}!proto.h@{proto.\-h}}
\subsubsection[{move\-\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf move\-\_\-particles} (
\begin{DoxyParamCaption}
\item[{int}]{time0, }
\item[{int}]{time1}
\end{DoxyParamCaption}
)}}\label{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31}
\-This function drifts all particles from the current time to the future\-: time0 -\/ $>$ time1

\-If there is no explicit tree construction in the following timestep, the tree nodes are also drifted and updated accordingly. \-Note\-: \-For periodic boundary conditions, the mapping of coordinates onto the interval \mbox{[}0,\-All.\-Box\-Size\mbox{]} is only done before the domain decomposition, or for outputs to snapshot files. \-This simplifies dynamic tree updates, and allows the domain decomposition to be carried out only every once in a while. $<$ adiabatic index of simulated gas 

\-Definition at line 31 of file predict.\-c.



\-References \-All, \-Extnodes, force\-\_\-update\-\_\-len(), force\-\_\-update\-\_\-pseudoparticles(), get\-\_\-drift\-\_\-factor(), get\-\_\-gravkick\-\_\-factor(), get\-\_\-hydrokick\-\_\-factor(), \-Nodes, \-Numnodestree, \-Num\-Part, \-P, pow(), second(), \-Sph\-P, and timediff().



\-Referenced by find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift().


\begin{DoxyCode}
{
  int i, j;
  double dt_drift, dt_gravkick, dt_hydrokick, dt_entr;
  double t0, t1;


  t0 = second();

  if(All.ComovingIntegrationOn)
    {
      dt_drift = get_drift_factor(time0, time1);
      dt_gravkick = get_gravkick_factor(time0, time1);
      dt_hydrokick = get_hydrokick_factor(time0, time1);
    }
  else
    {
      dt_drift = dt_gravkick = dt_hydrokick = (time1 - time0) * All.
      Timebase_interval;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        P[i].Pos[j] += P[i].Vel[j] * dt_drift;

      if(P[i].Type == 0)
        {
#ifdef PMGRID
          for(j = 0; j < 3; j++)
            SphP[i].VelPred[j] +=
              (P[i].GravAccel[j] + P[i].GravPM[j]) * dt_gravkick + SphP[i].
      HydroAccel[j] * dt_hydrokick;
#else
          for(j = 0; j < 3; j++)
            SphP[i].VelPred[j] += P[i].GravAccel[j] * dt_gravkick + SphP[i].
      HydroAccel[j] * dt_hydrokick;
#endif
          SphP[i].Density *= exp(-SphP[i].DivVel * dt_drift);
          SphP[i].Hsml *= exp(0.333333333333 * SphP[i].DivVel * dt_drift);

          if(SphP[i].Hsml < All.MinGasHsml)
            SphP[i].Hsml = All.MinGasHsml;

          dt_entr = (time1 - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * All.
      Timebase_interval;

          SphP[i].Pressure = (SphP[i].Entropy + SphP[i].DtEntropy * dt_entr) * 
      pow(SphP[i].Density, GAMMA);
        }
    }

  /* if domain-decomp and tree are not going to be reconstructed, update
       dynamically.  */
  if(All.NumForcesSinceLastDomainDecomp < All.TotNumPart * All.
      TreeDomainUpdateFrequency)
    {
      for(i = 0; i < Numnodestree; i++)
        for(j = 0; j < 3; j++)
          Nodes[All.MaxPart + i].u.d.s[j] += Extnodes[All.MaxPart + i].vs[j] * 
      dt_drift;

      force_update_len();

      force_update_pseudoparticles();
    }

  t1 = second();

  All.CPU_Predict += timediff(t0, t1);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a02a8a27a7a75ce5cd6c2a27b4d641e31_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a1609620c03f6b0068601735c42e3c660}{\index{proto.\-h@{proto.\-h}!my\-\_\-fread@{my\-\_\-fread}}
\index{my\-\_\-fread@{my\-\_\-fread}!proto.h@{proto.\-h}}
\subsubsection[{my\-\_\-fread}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf my\-\_\-fread} (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ptr, }
\item[{size\-\_\-t}]{size, }
\item[{size\-\_\-t}]{nmemb, }
\item[{\-F\-I\-L\-E $\ast$}]{stream}
\end{DoxyParamCaption}
)}}\label{proto_8h_a1609620c03f6b0068601735c42e3c660}
\-This catches \-I/\-O errors occuring for fread(). \-In this case we better stop. 

\-Definition at line 1139 of file io.\-c.



\-References endrun(), and \-This\-Task.



\-Referenced by byten(), ewald\-\_\-init(), in(), and read\-\_\-file().


\begin{DoxyCode}
{
  size_t nread;

  if((nread = fread(ptr, size, nmemb, stream)) != nmemb)
    {
      printf("I/O error (fread) on task=%d has occured: %s\n", ThisTask, 
      strerror(errno));
      fflush(stdout);
      endrun(778);
    }
  return nread;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a1609620c03f6b0068601735c42e3c660_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a1609620c03f6b0068601735c42e3c660_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21}{\index{proto.\-h@{proto.\-h}!my\-\_\-fwrite@{my\-\_\-fwrite}}
\index{my\-\_\-fwrite@{my\-\_\-fwrite}!proto.h@{proto.\-h}}
\subsubsection[{my\-\_\-fwrite}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf my\-\_\-fwrite} (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ptr, }
\item[{size\-\_\-t}]{size, }
\item[{size\-\_\-t}]{nmemb, }
\item[{\-F\-I\-L\-E $\ast$}]{stream}
\end{DoxyParamCaption}
)}}\label{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21}
\-This catches \-I/\-O errors occuring for \hyperlink{io_8c_aab1e6568bf14b3a23c66f70c94aabd21}{my\-\_\-fwrite()}. \-In this case we better stop. 

\-Definition at line 1122 of file io.\-c.



\-References endrun(), and \-This\-Task.



\-Referenced by byten(), dump\-\_\-particles(), ewald\-\_\-init(), in(), and write\-\_\-file().


\begin{DoxyCode}
{
  size_t nwritten;

  if((nwritten = fwrite(ptr, size, nmemb, stream)) != nmemb)
    {
      printf("I/O error (fwrite) on task=%d has occured: %s\n", ThisTask, 
      strerror(errno));
      fflush(stdout);
      endrun(777);
    }
  return nwritten;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aab1e6568bf14b3a23c66f70c94aabd21_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a72ee1196e73c7c6e8683d35e4692d840}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-clear\-\_\-buf@{ngb\-\_\-clear\-\_\-buf}}
\index{ngb\-\_\-clear\-\_\-buf@{ngb\-\_\-clear\-\_\-buf}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-clear\-\_\-buf}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ngb\-\_\-clear\-\_\-buf} (
\begin{DoxyParamCaption}
\item[{float}]{searchcenter\mbox{[}3\mbox{]}, }
\item[{float}]{hsml, }
\item[{int}]{numngb}
\end{DoxyParamCaption}
)}}\label{proto_8h_a72ee1196e73c7c6e8683d35e4692d840}
\-The buffer for the neighbour list has a finite length \-M\-A\-X\-\_\-\-N\-G\-B. \-For a large search region, this buffer can get full, in which case this routine can be called to eliminate some of the superfluous particles in the \char`\"{}corners\char`\"{} of the search box -\/ only the ones in the inscribed sphere need to be kept. 

\-Definition at line 320 of file ngb.\-c.



\-References \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-X, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-Y, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-Z, \-Ngblist, and \-P.



\-Referenced by ngb\-\_\-treefind\-\_\-variable().


\begin{DoxyCode}
{
  int i, p;
  FLOAT dx, dy, dz, r2;

#ifdef PERIODIC
  double xtmp;
#endif

  for(i = 0; i < numngb; i++)
    {
      p = Ngblist[i];
#ifdef PERIODIC
      dx = NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]);
      dy = NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]);
      dz = NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]);
#else
      dx = P[p].Pos[0] - searchcenter[0];
      dy = P[p].Pos[1] - searchcenter[1];
      dz = P[p].Pos[2] - searchcenter[2];
#endif
      r2 = dx * dx + dy * dy + dz * dz;

      if(r2 > hsml * hsml)
        {
          Ngblist[i] = Ngblist[numngb - 1];
          i--;
          numngb--;
        }
    }

  return numngb;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a72ee1196e73c7c6e8683d35e4692d840_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treeallocate@{ngb\-\_\-treeallocate}}
\index{ngb\-\_\-treeallocate@{ngb\-\_\-treeallocate}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treeallocate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ngb\-\_\-treeallocate} (
\begin{DoxyParamCaption}
\item[{int}]{npart}
\end{DoxyParamCaption}
)}}\label{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55}
\-Allocates memory for the neighbour list buffer. 

\-Definition at line 358 of file ngb.\-c.



\-References \-All, box\-Half, box\-Half\-\_\-\-X, box\-Half\-\_\-\-Y, box\-Half\-\_\-\-Z, box\-Size, box\-Size\-\_\-\-X, box\-Size\-\_\-\-Y, box\-Size\-\_\-\-Z, endrun(), \-Ngblist, and \-This\-Task.



\-Referenced by init(), and restart().


\begin{DoxyCode}
{
  double totbytes = 0;
  size_t bytes;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif

  if(!(Ngblist = malloc(bytes = npart * (long) sizeof(int))))
    {
      printf("Failed to allocate %g MB for ngblist array\n", bytes / (1024.0 * 
      1024.0));
      endrun(78);
    }
  totbytes += bytes;

  if(ThisTask == 0)
    printf("allocated %g Mbyte for ngb search.\n", totbytes / (1024.0 * 1024.0)
      );
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a6f7a3b85f10701b9067f012cc9a30f55_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac56af97a1dbbbbb07db8207246852f79}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treebuild@{ngb\-\_\-treebuild}}
\index{ngb\-\_\-treebuild@{ngb\-\_\-treebuild}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treebuild}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ngb\-\_\-treebuild} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ac56af97a1dbbbbb07db8207246852f79}
\-This function constructs the neighbour tree. \-To this end, we actually need to construct the gravitational tree, because we use it now for the neighbour search. 

\-Definition at line 403 of file ngb.\-c.



\-References force\-\_\-treebuild(), \-N\-\_\-gas, and \-This\-Task.



\-Referenced by init().


\begin{DoxyCode}
{
  if(ThisTask == 0)
    printf("Begin Ngb-tree construction.\n");

  force_treebuild(N_gas);

  if(ThisTask == 0)
    printf("Ngb-Tree contruction finished \n");
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac56af97a1dbbbbb07db8207246852f79_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ac56af97a1dbbbbb07db8207246852f79_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treefind\-\_\-pairs@{ngb\-\_\-treefind\-\_\-pairs}}
\index{ngb\-\_\-treefind\-\_\-pairs@{ngb\-\_\-treefind\-\_\-pairs}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treefind\-\_\-pairs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ngb\-\_\-treefind\-\_\-pairs} (
\begin{DoxyParamCaption}
\item[{float}]{searchcenter\mbox{[}3\mbox{]}, }
\item[{float}]{hsml, }
\item[{int $\ast$}]{startnode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd}
\-This routine finds all neighbours `j' that can interact with the particle `i' in the communication buffer.

\-Note that an interaction can take place if $ r_{ij} < h_i $ \-O\-R if $ r_{ij} < h_j $.

\-In the range-\/search this is taken into account, i.\-e. it is guaranteed that all particles are found that fulfil this condition, including the (more difficult) second part of it. \-For this purpose, each node knows the maximum h occuring among the particles it represents. $<$ defines maximum length of neighbour list 

\-Definition at line 64 of file ngb.\-c.



\-References \-All, \-Domain\-Task, \-Exportflag, \-Extnodes, \-Max\-Nodes, \-Nextnode, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-X, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-Y, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-Z, \-Ngblist, \-Nodes, \-P, \-Sph\-P, and \-This\-Task.



\-Referenced by hydro\-\_\-evaluate().


\begin{DoxyCode}
{
  int k, no, p, numngb;
  FLOAT hdiff;
  FLOAT searchmin[3], searchmax[3];
  struct NODE *this;

#ifdef PERIODIC
  double xtmp;
#endif

  for(k = 0; k < 3; k++)        /* cube-box window */
    {
      searchmin[k] = searchcenter[k] - hsml;
      searchmax[k] = searchcenter[k] + hsml;
    }

  numngb = 0;
  no = *startnode;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          p = no;
          no = Nextnode[no];

          if(P[p].Type > 0)
            continue;

          hdiff = SphP[p].Hsml - hsml;
          if(hdiff < 0)
            hdiff = 0;

#ifdef PERIODIC
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) < (-hsml - hdiff))
            continue;
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) > (hsml + hdiff))
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) < (-hsml - hdiff))
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) > (hsml + hdiff))
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) < (-hsml - hdiff))
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) > (hsml + hdiff))
            continue;
#else
          if(P[p].Pos[0] < (searchmin[0] - hdiff))
            continue;
          if(P[p].Pos[0] > (searchmax[0] + hdiff))
            continue;
          if(P[p].Pos[1] < (searchmin[1] - hdiff))
            continue;
          if(P[p].Pos[1] > (searchmax[1] + hdiff))
            continue;
          if(P[p].Pos[2] < (searchmin[2] - hdiff))
            continue;
          if(P[p].Pos[2] > (searchmax[2] + hdiff))
            continue;
#endif
          Ngblist[numngb++] = p;

          if(numngb == MAX_NGB)
            {
              printf
                ("ThisTask=%d: Need to do a second neighbour loop in
       hydro-force for (%g|%g|%g) hsml=%g no=%d\n",
                 ThisTask, searchcenter[0], searchcenter[1], searchcenter[2], 
      hsml, no);
              *startnode = no;
              return numngb;
            }
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
              no = Nextnode[no - MaxNodes];
              continue;
            }

          this = &Nodes[no];
          hdiff = Extnodes[no].hmax - hsml;
          if(hdiff < 0)
            hdiff = 0;

          no = this->u.d.sibling;       /* in case the node can be discarded */

#ifdef PERIODIC
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) + 0.5 * this->
      len) < (-hsml - hdiff))
            continue;
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) - 0.5 * this->
      len) > (hsml + hdiff))
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) + 0.5 * this->
      len) < (-hsml - hdiff))
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) - 0.5 * this->
      len) > (hsml + hdiff))
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) + 0.5 * this->
      len) < (-hsml - hdiff))
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) - 0.5 * this->
      len) > (hsml + hdiff))
            continue;
#else
          if((this->center[0] + 0.5 * this->len) < (searchmin[0] - hdiff))
            continue;
          if((this->center[0] - 0.5 * this->len) > (searchmax[0] + hdiff))
            continue;
          if((this->center[1] + 0.5 * this->len) < (searchmin[1] - hdiff))
            continue;
          if((this->center[1] - 0.5 * this->len) > (searchmax[1] + hdiff))
            continue;
          if((this->center[2] + 0.5 * this->len) < (searchmin[2] - hdiff))
            continue;
          if((this->center[2] - 0.5 * this->len) > (searchmax[2] + hdiff))
            continue;
#endif
          no = this->u.d.nextnode;      /* ok, we need to open the node */
        }
    }

  *startnode = -1;
  return numngb;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a96ec7acfa3c046abc6902ca77ee4bddd_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treefind\-\_\-variable@{ngb\-\_\-treefind\-\_\-variable}}
\index{ngb\-\_\-treefind\-\_\-variable@{ngb\-\_\-treefind\-\_\-variable}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treefind\-\_\-variable}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ngb\-\_\-treefind\-\_\-variable} (
\begin{DoxyParamCaption}
\item[{float}]{searchcenter\mbox{[}3\mbox{]}, }
\item[{float}]{hsml, }
\item[{int $\ast$}]{startnode}
\end{DoxyParamCaption}
)}}\label{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8}
\-This function returns neighbours with distance $<$= hsml and returns them in \-Ngblist. \-Actually, particles in a box of half side length hsml are returned, i.\-e. the reduction to a sphere still needs to be done in the calling routine. $<$ defines maximum length of neighbour list

$<$ defines maximum length of neighbour list 

\-Definition at line 194 of file ngb.\-c.



\-References \-All, \-Domain\-Task, \-Exportflag, \-Max\-Nodes, \-Nextnode, ngb\-\_\-clear\-\_\-buf(), \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-X, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-Y, \-N\-G\-B\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-Z, \-Ngblist, \-Nodes, \-P, and \-This\-Task.



\-Referenced by density\-\_\-evaluate().


\begin{DoxyCode}
{
  int k, numngb;
  int no, p;
  struct NODE *this;
  FLOAT searchmin[3], searchmax[3];

#ifdef PERIODIC
  double xtmp;
#endif

  for(k = 0; k < 3; k++)        /* cube-box window */
    {
      searchmin[k] = searchcenter[k] - hsml;
      searchmax[k] = searchcenter[k] + hsml;
    }

  numngb = 0;
  no = *startnode;

  while(no >= 0)
    {
      if(no < All.MaxPart)      /* single particle */
        {
          p = no;
          no = Nextnode[no];

          if(P[p].Type > 0)
            continue;

#ifdef PERIODIC
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) < -hsml)
            continue;
          if(NGB_PERIODIC_X(P[p].Pos[0] - searchcenter[0]) > hsml)
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) < -hsml)
            continue;
          if(NGB_PERIODIC_Y(P[p].Pos[1] - searchcenter[1]) > hsml)
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) < -hsml)
            continue;
          if(NGB_PERIODIC_Z(P[p].Pos[2] - searchcenter[2]) > hsml)
            continue;
#else
          if(P[p].Pos[0] < searchmin[0])
            continue;
          if(P[p].Pos[0] > searchmax[0])
            continue;
          if(P[p].Pos[1] < searchmin[1])
            continue;
          if(P[p].Pos[1] > searchmax[1])
            continue;
          if(P[p].Pos[2] < searchmin[2])
            continue;
          if(P[p].Pos[2] > searchmax[2])
            continue;
#endif
          Ngblist[numngb++] = p;

          if(numngb == MAX_NGB)
            {
              numngb = ngb_clear_buf(searchcenter, hsml, numngb);
              if(numngb == MAX_NGB)
                {
                  printf("ThisTask=%d: Need to do a second neighbour loop for
       (%g|%g|%g) hsml=%g no=%d\n",
                         ThisTask, searchcenter[0], searchcenter[1], 
      searchcenter[2], hsml, no);
                  *startnode = no;
                  return numngb;
                }
            }
        }
      else
        {
          if(no >= All.MaxPart + MaxNodes)      /* pseudo particle */
            {
              Exportflag[DomainTask[no - (All.MaxPart + MaxNodes)]] = 1;
              no = Nextnode[no - MaxNodes];
              continue;
            }

          this = &Nodes[no];

          no = this->u.d.sibling;       /* in case the node can be discarded */
#ifdef PERIODIC
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) + 0.5 * this->
      len) < -hsml)
            continue;
          if((NGB_PERIODIC_X(this->center[0] - searchcenter[0]) - 0.5 * this->
      len) > hsml)
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) + 0.5 * this->
      len) < -hsml)
            continue;
          if((NGB_PERIODIC_Y(this->center[1] - searchcenter[1]) - 0.5 * this->
      len) > hsml)
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) + 0.5 * this->
      len) < -hsml)
            continue;
          if((NGB_PERIODIC_Z(this->center[2] - searchcenter[2]) - 0.5 * this->
      len) > hsml)
            continue;
#else
          if((this->center[0] + 0.5 * this->len) < (searchmin[0]))
            continue;
          if((this->center[0] - 0.5 * this->len) > (searchmax[0]))
            continue;
          if((this->center[1] + 0.5 * this->len) < (searchmin[1]))
            continue;
          if((this->center[1] - 0.5 * this->len) > (searchmax[1]))
            continue;
          if((this->center[2] + 0.5 * this->len) < (searchmin[2]))
            continue;
          if((this->center[2] - 0.5 * this->len) > (searchmax[2]))
            continue;
#endif
          no = this->u.d.nextnode;      /* ok, we need to open the node */
        }
    }

  *startnode = -1;
  return numngb;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a008284f92570d4d1fa6e3dadb5902cf8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aab22cf240079ef5846d83729e4565f97}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treefree@{ngb\-\_\-treefree}}
\index{ngb\-\_\-treefree@{ngb\-\_\-treefree}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treefree}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ngb\-\_\-treefree} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aab22cf240079ef5846d83729e4565f97}
free memory allocated for neighbour list buffer. 

\-Definition at line 394 of file ngb.\-c.



\-References \-Ngblist.


\begin{DoxyCode}
{
  free(Ngblist);
}
\end{DoxyCode}
\hypertarget{proto_8h_ab68e970cf33f44c3ff421fc2ea6e9290}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treesearch@{ngb\-\_\-treesearch}}
\index{ngb\-\_\-treesearch@{ngb\-\_\-treesearch}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treesearch}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ngb\-\_\-treesearch} (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ab68e970cf33f44c3ff421fc2ea6e9290}
\hypertarget{proto_8h_ad387916b04773b495483e10f3d24e9d6}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-treesearch\-\_\-pairs@{ngb\-\_\-treesearch\-\_\-pairs}}
\index{ngb\-\_\-treesearch\-\_\-pairs@{ngb\-\_\-treesearch\-\_\-pairs}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-treesearch\-\_\-pairs}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ngb\-\_\-treesearch\-\_\-pairs} (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad387916b04773b495483e10f3d24e9d6}
\hypertarget{proto_8h_a6895b316b66ff5f9f78910d65823bf00}{\index{proto.\-h@{proto.\-h}!ngb\-\_\-update\-\_\-nodes@{ngb\-\_\-update\-\_\-nodes}}
\index{ngb\-\_\-update\-\_\-nodes@{ngb\-\_\-update\-\_\-nodes}!proto.h@{proto.\-h}}
\subsubsection[{ngb\-\_\-update\-\_\-nodes}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf ngb\-\_\-update\-\_\-nodes} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a6895b316b66ff5f9f78910d65823bf00}
\hypertarget{proto_8h_a6f629274f7b036874c743fb81d58ce68}{\index{proto.\-h@{proto.\-h}!open\-\_\-outputfiles@{open\-\_\-outputfiles}}
\index{open\-\_\-outputfiles@{open\-\_\-outputfiles}!proto.h@{proto.\-h}}
\subsubsection[{open\-\_\-outputfiles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf open\-\_\-outputfiles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a6f629274f7b036874c743fb81d58ce68}
\-This function opens various log-\/files that report on the status and performance of the simulstion. \-On restart from restart-\/files (start-\/option 1), the code will append to these files. 

\-Definition at line 207 of file begrun.\-c.



\-References \-All, endrun(), \-Fd\-C\-P\-U, \-Fd\-Energy, \-Fd\-Force\-Test, \-Fd\-Info, \-Fd\-Timings, \-Restart\-Flag, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  char mode[2], buf[200];

  if(ThisTask != 0)             /* only the root processor writes to the log
       files */
    return;

  if(RestartFlag == 0)
    strcpy(mode, "w");
  else
    strcpy(mode, "a");


  sprintf(buf, "%s%s", All.OutputDir, All.CpuFile);
  if(!(FdCPU = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.InfoFile);
  if(!(FdInfo = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.EnergyFile);
  if(!(FdEnergy = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.TimingsFile);
  if(!(FdTimings = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

#ifdef FORCETEST
  if(RestartFlag == 0)
    {
      sprintf(buf, "%s%s", All.OutputDir, "forcetest.txt");
      if(!(FdForceTest = fopen(buf, "w")))
        {
          printf("error in opening file '%s'\n", buf);
          endrun(1);
        }
      fclose(FdForceTest);
    }
#endif
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a6f629274f7b036874c743fb81d58ce68_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{proto_8h_a6f629274f7b036874c743fb81d58ce68_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df}{\index{proto.\-h@{proto.\-h}!peano\-\_\-hilbert\-\_\-key@{peano\-\_\-hilbert\-\_\-key}}
\index{peano\-\_\-hilbert\-\_\-key@{peano\-\_\-hilbert\-\_\-key}!proto.h@{proto.\-h}}
\subsubsection[{peano\-\_\-hilbert\-\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}peanokey {\bf peano\-\_\-hilbert\-\_\-key} (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y, }
\item[{int}]{z, }
\item[{int}]{bits}
\end{DoxyParamCaption}
)}}\label{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df}
\-This function computes a \-Peano-\/\-Hilbert key for an integer triplet (x,y,z), with x,y,z in the range between 0 and 2$^\wedge$bits-\/1. 

\-Definition at line 263 of file peano.\-c.



\-References quadrants, rotx\-\_\-table, rotxmap\-\_\-table, roty\-\_\-table, rotymap\-\_\-table, and sense\-\_\-table.



\-Referenced by domain\-\_\-determine\-Top\-Tree(), force\-\_\-create\-\_\-empty\-\_\-nodes(), and force\-\_\-treebuild\-\_\-single().


\begin{DoxyCode}
{
  int i, quad, bitx, bity, bitz;
  int mask, rotation, rotx, roty, sense;
  peanokey key;


  mask = 1 << (bits - 1);
  key = 0;
  rotation = 0;
  sense = 1;


  for(i = 0; i < bits; i++, mask >>= 1)
    {
      bitx = (x & mask) ? 1 : 0;
      bity = (y & mask) ? 1 : 0;
      bitz = (z & mask) ? 1 : 0;

      quad = quadrants[rotation][bitx][bity][bitz];

      key <<= 3;
      key += (sense == 1) ? (quad) : (7 - quad);

      rotx = rotx_table[quad];
      roty = roty_table[quad];
      sense *= sense_table[quad];

      while(rotx > 0)
        {
          rotation = rotxmap_table[rotation];
          rotx--;
        }

      while(roty > 0)
        {
          rotation = rotymap_table[rotation];
          roty--;
        }
    }

  return key;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a9eec17b80ae63eb79e98064f2d4f25df_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af3e45a4293584b3fe28e83af75c6ed71}{\index{proto.\-h@{proto.\-h}!peano\-\_\-hilbert\-\_\-order@{peano\-\_\-hilbert\-\_\-order}}
\index{peano\-\_\-hilbert\-\_\-order@{peano\-\_\-hilbert\-\_\-order}!proto.h@{proto.\-h}}
\subsubsection[{peano\-\_\-hilbert\-\_\-order}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf peano\-\_\-hilbert\-\_\-order} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_af3e45a4293584b3fe28e83af75c6ed71}
\-This function puts the particles into \-Peano-\/\-Hilbert order by sorting them according to their keys. \-The latter half already been computed in the domain decomposition. \-Since gas particles need to stay at the beginning of the particle list, they are sorted as a separate block. 

\-Definition at line 34 of file peano.\-c.



\-References compare\-\_\-key(), \-Id, peano\-\_\-hilbert\-\_\-data\-::index, peano\-\_\-hilbert\-\_\-data\-::key, \-Key, mp, \-N\-\_\-gas, \-Num\-Part, reorder\-\_\-gas(), reorder\-\_\-particles(), and \-This\-Task.



\-Referenced by domain\-\_\-\-Decomposition().


\begin{DoxyCode}
{
  int i;

  if(ThisTask == 0)
    printf("begin Peano-Hilbert order...\n");

  if(N_gas)
    {
      mp = malloc(sizeof(struct peano_hilbert_data) * N_gas);
      Id = malloc(sizeof(int) * N_gas);

      for(i = 0; i < N_gas; i++)
        {
          mp[i].index = i;
          mp[i].key = Key[i];
        }

      qsort(mp, N_gas, sizeof(struct peano_hilbert_data), compare_key);

      for(i = 0; i < N_gas; i++)
        Id[mp[i].index] = i;

      reorder_gas();

      free(Id);
      free(mp);
    }


  if(NumPart - N_gas > 0)
    {
      mp = malloc(sizeof(struct peano_hilbert_data) * (NumPart - N_gas));
      mp -= (N_gas);

      Id = malloc(sizeof(int) * (NumPart - N_gas));
      Id -= (N_gas);

      for(i = N_gas; i < NumPart; i++)
        {
          mp[i].index = i;
          mp[i].key = Key[i];
        }

      qsort(mp + N_gas, NumPart - N_gas, sizeof(struct peano_hilbert_data), 
      compare_key);

      for(i = N_gas; i < NumPart; i++)
        Id[mp[i].index] = i;

      reorder_particles();

      Id += N_gas;
      free(Id);
      mp += N_gas;
      free(mp);
    }

  if(ThisTask == 0)
    printf("Peano-Hilbert done.\n");
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{proto_8h_af3e45a4293584b3fe28e83af75c6ed71_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af3e45a4293584b3fe28e83af75c6ed71_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-nonperiodic@{pm\-\_\-init\-\_\-nonperiodic}}
\index{pm\-\_\-init\-\_\-nonperiodic@{pm\-\_\-init\-\_\-nonperiodic}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-nonperiodic}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-nonperiodic} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0}


\-Referenced by long\-\_\-range\-\_\-init().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a0784ca56372f6ce3cf46e8b6623e4ea0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ac8030592010e755c61e6ee358ee0895d}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate@{pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate}}
\index{pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate@{pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-nonperiodic\-\_\-allocate} (
\begin{DoxyParamCaption}
\item[{int}]{dimprod}
\end{DoxyParamCaption}
)}}\label{proto_8h_ac8030592010e755c61e6ee358ee0895d}
\hypertarget{proto_8h_afd73e48ecc5be43d057dd718f78d187d}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-nonperiodic\-\_\-free@{pm\-\_\-init\-\_\-nonperiodic\-\_\-free}}
\index{pm\-\_\-init\-\_\-nonperiodic\-\_\-free@{pm\-\_\-init\-\_\-nonperiodic\-\_\-free}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-nonperiodic\-\_\-free}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-nonperiodic\-\_\-free} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_afd73e48ecc5be43d057dd718f78d187d}
\hypertarget{proto_8h_a13e381f05efdb739cf5026384e908409}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-periodic@{pm\-\_\-init\-\_\-periodic}}
\index{pm\-\_\-init\-\_\-periodic@{pm\-\_\-init\-\_\-periodic}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-periodic}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-periodic} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a13e381f05efdb739cf5026384e908409}
\-This routines generates the \-F\-F\-T\-W-\/plans to carry out the parallel \-F\-F\-Ts later on. \-Some auxiliary variables are also initialized. $<$ \-A\-S\-M\-T\-H gives the scale of the short-\/range/long-\/range force split in units of \-F\-F\-T-\/mesh cells

$<$ \-R\-C\-U\-T gives the maximum distance (in units of the scale used for the force split) out to which short-\/range forces are evaluated in the short-\/range tree walk. 

\-Definition at line 55 of file pm\-\_\-periodic.\-c.



\-References \-All, fft\-\_\-forward\-\_\-plan, fft\-\_\-inverse\-\_\-plan, fftsize, first\-\_\-slab\-\_\-of\-\_\-task, maxfftsize, meshmax\-\_\-list, meshmin\-\_\-list, nslab\-\_\-x, nslab\-\_\-y, \-N\-Task, slab\-\_\-to\-\_\-task, slabs\-\_\-per\-\_\-task, slabstart\-\_\-x, slabstart\-\_\-y, smallest\-\_\-slab, \-This\-Task, and to\-\_\-slab\-\_\-fac.



\-Referenced by long\-\_\-range\-\_\-init().


\begin{DoxyCode}
{
  int i;
  int slab_to_task_local[PMGRID];

  All.Asmth[0] = ASMTH * All.BoxSize / PMGRID;
  All.Rcut[0] = RCUT * All.Asmth[0];

  /* Set up the FFTW plan files. */

  fft_forward_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, PMGRID, PMGRID, 
      PMGRID,
                                             FFTW_REAL_TO_COMPLEX, 
      FFTW_ESTIMATE | FFTW_IN_PLACE);
  fft_inverse_plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD, PMGRID, PMGRID, 
      PMGRID,
                                             FFTW_COMPLEX_TO_REAL, 
      FFTW_ESTIMATE | FFTW_IN_PLACE);

  /* Workspace out the ranges on each processor. */

  rfftwnd_mpi_local_sizes(fft_forward_plan, &nslab_x, &slabstart_x, &nslab_y, &
      slabstart_y, &fftsize);

  for(i = 0; i < PMGRID; i++)
    slab_to_task_local[i] = 0;

  for(i = 0; i < nslab_x; i++)
    slab_to_task_local[slabstart_x + i] = ThisTask;

  MPI_Allreduce(slab_to_task_local, slab_to_task, PMGRID, MPI_INT, MPI_SUM, 
      MPI_COMM_WORLD);

  MPI_Allreduce(&nslab_x, &smallest_slab, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);

  slabs_per_task = malloc(NTask * sizeof(int));
  MPI_Allgather(&nslab_x, 1, MPI_INT, slabs_per_task, 1, MPI_INT, 
      MPI_COMM_WORLD);

  if(ThisTask == 0)
    {
      for(i = 0; i < NTask; i++)
        printf("Task=%d  FFT-Slabs=%d\n", i, slabs_per_task[i]);
    }

  first_slab_of_task = malloc(NTask * sizeof(int));
  MPI_Allgather(&slabstart_x, 1, MPI_INT, first_slab_of_task, 1, MPI_INT, 
      MPI_COMM_WORLD);

  meshmin_list = malloc(3 * NTask * sizeof(int));
  meshmax_list = malloc(3 * NTask * sizeof(int));


  to_slab_fac = PMGRID / All.BoxSize;

  MPI_Allreduce(&fftsize, &maxfftsize, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a13e381f05efdb739cf5026384e908409_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-periodic\-\_\-allocate@{pm\-\_\-init\-\_\-periodic\-\_\-allocate}}
\index{pm\-\_\-init\-\_\-periodic\-\_\-allocate@{pm\-\_\-init\-\_\-periodic\-\_\-allocate}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-periodic\-\_\-allocate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-periodic\-\_\-allocate} (
\begin{DoxyParamCaption}
\item[{int}]{dimprod}
\end{DoxyParamCaption}
)}}\label{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e}
\-This function allocates the memory neeed to compute the long-\/range \-P\-M force. \-Three fields are used, one to hold the density (and its \-F\-F\-T, and then the real-\/space potential), one to hold the force field obtained by finite differencing, and finally a workspace field, which is used both as workspace for the parallel \-F\-F\-T, and as buffer for the communication algorithm used in the force computation. 

\-Definition at line 113 of file pm\-\_\-periodic.\-c.



\-References endrun(), fft\-\_\-of\-\_\-rhogrid, fftsize, forcegrid, imax(), maxfftsize, rhogrid, \-This\-Task, and workspace.



\-Referenced by pmforce\-\_\-periodic(), and pmpotential\-\_\-periodic().


\begin{DoxyCode}
{
  static int first_alloc = 1;
  int dimprodmax;
  double bytes_tot = 0;
  size_t bytes;

  MPI_Allreduce(&dimprod, &dimprodmax, 1, MPI_INT, MPI_MAX, MPI_COMM_WORLD);

  /* allocate the memory to hold the FFT fields */

  if(!(rhogrid = (fftw_real *) malloc(bytes = fftsize * sizeof(fftw_real))))
    {
      printf("failed to allocate memory for `FFT-rhogrid' (%g MB).\n", bytes / 
      (1024.0 * 1024.0));
      endrun(1);
    }
  bytes_tot += bytes;


  if(!(forcegrid = (fftw_real *) malloc(bytes = imax(fftsize, dimprodmax) * 
      sizeof(fftw_real))))
    {
      printf("failed to allocate memory for `FFT-forcegrid' (%g MB).\n", bytes 
      / (1024.0 * 1024.0));
      endrun(1);
    }
  bytes_tot += bytes;

  if(!(workspace = (fftw_real *) malloc(bytes = imax(maxfftsize, dimprodmax) * 
      sizeof(fftw_real))))
    {
      printf("failed to allocate memory for `FFT-workspace' (%g MB).\n", bytes 
      / (1024.0 * 1024.0));
      endrun(1);
    }
  bytes_tot += bytes;

  if(first_alloc == 1)
    {
      first_alloc = 0;
      if(ThisTask == 0)
        printf("\nAllocated %g MByte for FFT data.\n\n", bytes_tot / (1024.0 * 
      1024.0));
    }

  fft_of_rhogrid = (fftw_complex *) & rhogrid[0];
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_acb5c64377fad9e1a34bad88fb7c61a3e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a259e6f8400ee889c64bc667334060742}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-periodic\-\_\-free@{pm\-\_\-init\-\_\-periodic\-\_\-free}}
\index{pm\-\_\-init\-\_\-periodic\-\_\-free@{pm\-\_\-init\-\_\-periodic\-\_\-free}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-periodic\-\_\-free}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-periodic\-\_\-free} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a259e6f8400ee889c64bc667334060742}
\-This routine frees the space allocated for the parallel \-F\-F\-T algorithm. 

\-Definition at line 160 of file pm\-\_\-periodic.\-c.



\-References forcegrid, rhogrid, and workspace.



\-Referenced by pmforce\-\_\-periodic(), and pmpotential\-\_\-periodic().


\begin{DoxyCode}
{
  /* allocate the memory to hold the FFT fields */
  free(workspace);
  free(forcegrid);
  free(rhogrid);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a259e6f8400ee889c64bc667334060742_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a57f2f415791cd83ace42bff59b2feb97}{\index{proto.\-h@{proto.\-h}!pm\-\_\-init\-\_\-regionsize@{pm\-\_\-init\-\_\-regionsize}}
\index{pm\-\_\-init\-\_\-regionsize@{pm\-\_\-init\-\_\-regionsize}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-init\-\_\-regionsize}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-init\-\_\-regionsize} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a57f2f415791cd83ace42bff59b2feb97}


\-Referenced by compute\-\_\-potential(), long\-\_\-range\-\_\-force(), and long\-\_\-range\-\_\-init\-\_\-regionsize().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a57f2f415791cd83ace42bff59b2feb97_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ae3950c19708f6a2886dd32897efa10c4}{\index{proto.\-h@{proto.\-h}!pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel@{pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel}}
\index{pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel@{pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel}!proto.h@{proto.\-h}}
\subsubsection[{pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pm\-\_\-setup\-\_\-nonperiodic\-\_\-kernel} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ae3950c19708f6a2886dd32897efa10c4}


\-Referenced by compute\-\_\-potential(), long\-\_\-range\-\_\-force(), and long\-\_\-range\-\_\-init\-\_\-regionsize().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ae3950c19708f6a2886dd32897efa10c4_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a8821224474d8690f0db99b8cfab3a8fc}{\index{proto.\-h@{proto.\-h}!pmforce\-\_\-nonperiodic@{pmforce\-\_\-nonperiodic}}
\index{pmforce\-\_\-nonperiodic@{pmforce\-\_\-nonperiodic}!proto.h@{proto.\-h}}
\subsubsection[{pmforce\-\_\-nonperiodic}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf pmforce\-\_\-nonperiodic} (
\begin{DoxyParamCaption}
\item[{int}]{grnr}
\end{DoxyParamCaption}
)}}\label{proto_8h_a8821224474d8690f0db99b8cfab3a8fc}


\-Referenced by long\-\_\-range\-\_\-force().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a8821224474d8690f0db99b8cfab3a8fc_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b}{\index{proto.\-h@{proto.\-h}!pmforce\-\_\-periodic@{pmforce\-\_\-periodic}}
\index{pmforce\-\_\-periodic@{pmforce\-\_\-periodic}!proto.h@{proto.\-h}}
\subsubsection[{pmforce\-\_\-periodic}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pmforce\-\_\-periodic} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b}
\-Calculates the long-\/range periodic force given the particle positions using the \-P\-M method. \-The force is \-Gaussian filtered with \-Asmth, given in mesh-\/cell units. \-We carry out a \-C\-I\-C charge assignment, and compute the potenial by \-Fourier transform methods. \-The potential is finite differenced using a 4-\/point finite differencing formula, and the forces are interpolated tri-\/linearly to the particle positions. \-The \-C\-I\-C kernel is deconvolved. \-Note that the particle distribution is not in the slab decomposition that is used for the \-F\-F\-T. \-Instead, overlapping patches between local domains and \-F\-F\-T slabs are communicated as needed. 

\-Definition at line 180 of file pm\-\_\-periodic.\-c.



\-References \-All, fft\-\_\-forward\-\_\-plan, fft\-\_\-inverse\-\_\-plan, fft\-\_\-of\-\_\-rhogrid, fftsize, first\-\_\-slab\-\_\-of\-\_\-task, force\-\_\-treeallocate(), force\-\_\-treefree(), forcegrid, meshmax\-\_\-list, meshmin\-\_\-list, nslab\-\_\-y, \-N\-Task, \-Num\-Part, \-P, pm\-\_\-init\-\_\-periodic\-\_\-allocate(), pm\-\_\-init\-\_\-periodic\-\_\-free(), \-P\-M\-G\-R\-I\-D2, \-P\-Task, rhogrid, slab\-\_\-to\-\_\-task, slabs\-\_\-per\-\_\-task, slabstart\-\_\-y, \-T\-A\-G\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-A, \-T\-A\-G\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-B, \-This\-Task, to\-\_\-slab\-\_\-fac, and workspace.



\-Referenced by long\-\_\-range\-\_\-force().


\begin{DoxyCode}
{
  double k2, kx, ky, kz, smth;
  double dx, dy, dz;
  double fx, fy, fz, ff;
  double asmth2, fac, acc_dim;
  int i, j, slab, level, sendTask, recvTask;
  int x, y, z, xl, yl, zl, xr, yr, zr, xll, yll, zll, xrr, yrr, zrr, ip, dim;
  int slab_x, slab_y, slab_z;
  int slab_xx, slab_yy, slab_zz;
  int meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
  int rep, ncont, cont_sendmin[2], cont_sendmax[2], cont_recvmin[2], 
      cont_recvmax[2];
  int dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
  MPI_Status status;


  if(ThisTask == 0)
    {
      printf("Starting periodic PM calculation.\n");
      fflush(stdout);
    }


  force_treefree();


  asmth2 = (2 * M_PI) * All.Asmth[0] / All.BoxSize;
  asmth2 *= asmth2;

  fac = All.G / (M_PI * All.BoxSize);   /* to get potential */
  fac *= 1 / (2 * All.BoxSize / PMGRID);        /* for finite differencing */

  /* first, establish the extension of the local patch in the PMGRID  */

  for(j = 0; j < 3; j++)
    {
      meshmin[j] = PMGRID;
      meshmax[j] = 0;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          slab = to_slab_fac * P[i].Pos[j];
          if(slab >= PMGRID)
            slab = PMGRID - 1;

          if(slab < meshmin[j])
            meshmin[j] = slab;

          if(slab > meshmax[j])
            meshmax[j] = slab;
        }
    }

  MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
  MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);

  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  pm_init_periodic_allocate((dimx + 4) * (dimy + 4) * (dimz + 4));

  for(i = 0; i < dimx * dimy * dimz; i++)
    workspace[i] = 0;

  for(i = 0; i < NumPart; i++)
    {
      slab_x = to_slab_fac * P[i].Pos[0];
      if(slab_x >= PMGRID)
        slab_x = PMGRID - 1;
      dx = to_slab_fac * P[i].Pos[0] - slab_x;
      slab_x -= meshmin[0];
      slab_xx = slab_x + 1;

      slab_y = to_slab_fac * P[i].Pos[1];
      if(slab_y >= PMGRID)
        slab_y = PMGRID - 1;
      dy = to_slab_fac * P[i].Pos[1] - slab_y;
      slab_y -= meshmin[1];
      slab_yy = slab_y + 1;

      slab_z = to_slab_fac * P[i].Pos[2];
      if(slab_z >= PMGRID)
        slab_z = PMGRID - 1;
      dz = to_slab_fac * P[i].Pos[2] - slab_z;
      slab_z -= meshmin[2];
      slab_zz = slab_z + 1;

      workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (1.0 -
       dx) * (1.0 - dy) * (1.0 - dz);
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (1.0 
      - dx) * dy * (1.0 - dz);
      workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (1.0 
      - dx) * (1.0 - dy) * dz;
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (1.0
       - dx) * dy * dz;

      workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (dx) 
      * (1.0 - dy) * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (dx)
       * dy * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (dx)
       * (1.0 - dy) * dz;
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (dx
      ) * dy * dz;
    }


  for(i = 0; i < fftsize; i++)  /* clear local density field */
    rhogrid[i] = 0;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is
       the same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;
      if(recvTask < NTask)
        {
          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -1;
          for(slab_x = meshmin[0]; slab_x < meshmax[0] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == recvTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -1)
            sendmin = 0;

          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -1;
          for(slab_x = meshmin_list[3 * recvTask]; slab_x < meshmax_list[3 * 
      recvTask] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == sendTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -1)
            recvmin = 0;


          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok,
       we have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * 
      recvTask + 0] + 2;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * 
      recvTask + 1] + 2;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * 
      recvTask + 2] + 2;

              if(level > 0)
                {
                  MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz
      ,
                               (sendmax - sendmin + 1) * dimy * dimz * sizeof(
      fftw_real), MPI_BYTE, recvTask,
                               TAG_PERIODIC_A, forcegrid,
                               (recvmax - recvmin + 1) * recv_dimy * recv_dimz 
      * sizeof(fftw_real), MPI_BYTE,
                               recvTask, TAG_PERIODIC_A, MPI_COMM_WORLD, &
      status);
                }
              else
                {
                  memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy *
       dimz,
                         (sendmax - sendmin + 1) * dimy * dimz * sizeof(
      fftw_real));
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  slab_xx = (slab_x % PMGRID) - first_slab_of_task[ThisTask];

                  if(slab_xx >= 0 && slab_xx < slabs_per_task[ThisTask])
                    {
                      for(slab_y = meshmin_list[3 * recvTask + 1];
                          slab_y <= meshmax_list[3 * recvTask + 1] + 1; slab_y+
      +)
                        {
                          slab_yy = slab_y;
                          if(slab_yy >= PMGRID)
                            slab_yy -= PMGRID;

                          for(slab_z = meshmin_list[3 * recvTask + 2];
                              slab_z <= meshmax_list[3 * recvTask + 2] + 1; 
      slab_z++)
                            {
                              slab_zz = slab_z;
                              if(slab_zz >= PMGRID)
                                slab_zz -= PMGRID;

                              rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2 * 
      slab_yy + slab_zz] +=
                                forcegrid[((slab_x - recvmin) * recv_dimy +
                                           (slab_y - meshmin_list[3 * recvTask 
      + 1])) * recv_dimz +
                                          (slab_z - meshmin_list[3 * recvTask +
       2])];
                            }
                        }
                    }
                }
            }
        }
    }

  /* Do the FFT of the density field */

  rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* multiply with Green's function for the potential */

  for(y = slabstart_y; y < slabstart_y + nslab_y; y++)
    for(x = 0; x < PMGRID; x++)
      for(z = 0; z < PMGRID / 2 + 1; z++)
        {
          if(x > PMGRID / 2)
            kx = x - PMGRID;
          else
            kx = x;
          if(y > PMGRID / 2)
            ky = y - PMGRID;
          else
            ky = y;
          if(z > PMGRID / 2)
            kz = z - PMGRID;
          else
            kz = z;

          k2 = kx * kx + ky * ky + kz * kz;

          if(k2 > 0)
            {
              smth = -exp(-k2 * asmth2) / k2;

              /* do deconvolution */

              fx = fy = fz = 1;
              if(kx != 0)
                {
                  fx = (M_PI * kx) / PMGRID;
                  fx = sin(fx) / fx;
                }
              if(ky != 0)
                {
                  fy = (M_PI * ky) / PMGRID;
                  fy = sin(fy) / fy;
                }
              if(kz != 0)
                {
                  fz = (M_PI * kz) / PMGRID;
                  fz = sin(fz) / fz;
                }
              ff = 1 / (fx * fy * fz);
              smth *= ff * ff * ff * ff;

              /* end deconvolution */

              ip = PMGRID * (PMGRID / 2 + 1) * (y - slabstart_y) + (PMGRID / 2 
      + 1) * x + z;
              fft_of_rhogrid[ip].re *= smth;
              fft_of_rhogrid[ip].im *= smth;
            }
        }

  if(slabstart_y == 0)
    fft_of_rhogrid[0].re = fft_of_rhogrid[0].im = 0.0;

  /* Do the FFT to get the potential */

  rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* Now rhogrid holds the potential */
  /* construct the potential for the local patch */


  dimx = meshmax[0] - meshmin[0] + 6;
  dimy = meshmax[1] - meshmin[1] + 6;
  dimz = meshmax[2] - meshmin[2] + 6;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is
       the same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        {

          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -PMGRID;
          for(slab_x = meshmin_list[3 * recvTask] - 2; slab_x < meshmax_list[3 
      * recvTask] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == sendTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -PMGRID)
            sendmin = sendmax + 1;


          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -PMGRID;
          for(slab_x = meshmin[0] - 2; slab_x < meshmax[0] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == recvTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -PMGRID)
            recvmin = recvmax + 1;

          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok,
       we have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * 
      recvTask + 0] + 6;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * 
      recvTask + 1] + 6;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * 
      recvTask + 2] + 6;

              ncont = 1;
              cont_sendmin[0] = sendmin;
              cont_sendmax[0] = sendmax;
              cont_sendmin[1] = sendmax + 1;
              cont_sendmax[1] = sendmax;

              cont_recvmin[0] = recvmin;
              cont_recvmax[0] = recvmax;
              cont_recvmin[1] = recvmax + 1;
              cont_recvmax[1] = recvmax;

              for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
                    {
                      /* non-contiguous */
                      cont_sendmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask
      )
                        slab_x++;
                      cont_sendmin[1] = slab_x;
                      ncont++;
                    }
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
                    {
                      /* non-contiguous */
                      cont_recvmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != 
      recvTask)
                        slab_x++;
                      cont_recvmin[1] = slab_x;
                      if(ncont == 1)
                        ncont++;
                    }
                }


              for(rep = 0; rep < ncont; rep++)
                {
                  sendmin = cont_sendmin[rep];
                  sendmax = cont_sendmax[rep];
                  recvmin = cont_recvmin[rep];
                  recvmax = cont_recvmax[rep];

                  /* prepare what we want to send */
                  if(sendmax - sendmin >= 0)
                    {
                      for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                        {
                          slab_xx = ((slab_x + PMGRID) % PMGRID) - 
      first_slab_of_task[ThisTask];

                          for(slab_y = meshmin_list[3 * recvTask + 1] - 2;
                              slab_y < meshmax_list[3 * recvTask + 1] + 4; 
      slab_y++)
                            {
                              slab_yy = (slab_y + PMGRID) % PMGRID;

                              for(slab_z = meshmin_list[3 * recvTask + 2] - 2;
                                  slab_z < meshmax_list[3 * recvTask + 2] + 4; 
      slab_z++)
                                {
                                  slab_zz = (slab_z + PMGRID) % PMGRID;

                                  forcegrid[((slab_x - sendmin) * recv_dimy +
                                             (slab_y - (meshmin_list[3 * 
      recvTask + 1] - 2))) * recv_dimz +
                                            slab_z - (meshmin_list[3 * recvTask
       + 2] - 2)] =
                                    rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2
       * slab_yy + slab_zz];
                                }
                            }
                        }
                    }

                  if(level > 0)
                    {
                      MPI_Sendrecv(forcegrid,
                                   (sendmax - sendmin + 1) * recv_dimy * 
      recv_dimz * sizeof(fftw_real),
                                   MPI_BYTE, recvTask, TAG_PERIODIC_B,
                                   workspace + (recvmin - (meshmin[0] - 2)) * 
      dimy * dimz,
                                   (recvmax - recvmin + 1) * dimy * dimz * 
      sizeof(fftw_real), MPI_BYTE,
                                   recvTask, TAG_PERIODIC_B, MPI_COMM_WORLD, &
      status);
                    }
                  else
                    {
                      memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * 
      dimz,
                             forcegrid, (recvmax - recvmin + 1) * dimy * dimz *
       sizeof(fftw_real));
                    }
                }
            }
        }
    }


  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  recv_dimx = meshmax[0] - meshmin[0] + 6;
  recv_dimy = meshmax[1] - meshmin[1] + 6;
  recv_dimz = meshmax[2] - meshmin[2] + 6;


  for(dim = 0; dim < 3; dim++)  /* Calculate each component of the force. */
    {
      /* get the force component by finite differencing the potential */
      /* note: "workspace" now contains the potential for the local patch, plus
       a suffiently large buffer region */

      for(x = 0; x < meshmax[0] - meshmin[0] + 2; x++)
        for(y = 0; y < meshmax[1] - meshmin[1] + 2; y++)
          for(z = 0; z < meshmax[2] - meshmin[2] + 2; z++)
            {
              xrr = xll = xr = xl = x;
              yrr = yll = yr = yl = y;
              zrr = zll = zr = zl = z;

              switch (dim)
                {
                case 0:
                  xr = x + 1;
                  xrr = x + 2;
                  xl = x - 1;
                  xll = x - 2;
                  break;
                case 1:
                  yr = y + 1;
                  yl = y - 1;
                  yrr = y + 2;
                  yll = y - 2;
                  break;
                case 2:
                  zr = z + 1;
                  zl = z - 1;
                  zrr = z + 2;
                  zll = z - 2;
                  break;
                }

              forcegrid[(x * dimy + y) * dimz + z]
                =
                fac * ((4.0 / 3) *
                       (workspace[((xl + 2) * recv_dimy + (yl + 2)) * recv_dimz
       + (zl + 2)]
                        - workspace[((xr + 2) * recv_dimy + (yr + 2)) * 
      recv_dimz + (zr + 2)]) -
                       (1.0 / 6) *
                       (workspace[((xll + 2) * recv_dimy + (yll + 2)) * 
      recv_dimz + (zll + 2)] -
                        workspace[((xrr + 2) * recv_dimy + (yrr + 2)) * 
      recv_dimz + (zrr + 2)]));
            }

      /* read out the forces */

      for(i = 0; i < NumPart; i++)
        {
          slab_x = to_slab_fac * P[i].Pos[0];
          if(slab_x >= PMGRID)
            slab_x = PMGRID - 1;
          dx = to_slab_fac * P[i].Pos[0] - slab_x;
          slab_x -= meshmin[0];
          slab_xx = slab_x + 1;

          slab_y = to_slab_fac * P[i].Pos[1];
          if(slab_y >= PMGRID)
            slab_y = PMGRID - 1;
          dy = to_slab_fac * P[i].Pos[1] - slab_y;
          slab_y -= meshmin[1];
          slab_yy = slab_y + 1;

          slab_z = to_slab_fac * P[i].Pos[2];
          if(slab_z >= PMGRID)
            slab_z = PMGRID - 1;
          dz = to_slab_fac * P[i].Pos[2] - slab_z;
          slab_z -= meshmin[2];
          slab_zz = slab_z + 1;

          acc_dim =
            forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * 
      (1.0 - dy) * (1.0 - dz);
          acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * (1.
      0 - dx) * dy * (1.0 - dz);
          acc_dim += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * (1.
      0 - dx) * (1.0 - dy) * dz;
          acc_dim += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] * (1
      .0 - dx) * dy * dz;

          acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * (dx
      ) * (1.0 - dy) * (1.0 - dz);
          acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] * (
      dx) * dy * (1.0 - dz);
          acc_dim += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] * (
      dx) * (1.0 - dy) * dz;
          acc_dim += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] * (
      dx) * dy * dz;

          P[i].GravPM[dim] = acc_dim;
        }
    }

  pm_init_periodic_free();
  force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);

  All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;

  if(ThisTask == 0)
    {
      printf("done PM.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af8dfaf42f3b513118ad6aa3ab5cd3c1b_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9}{\index{proto.\-h@{proto.\-h}!pmpotential\-\_\-nonperiodic@{pmpotential\-\_\-nonperiodic}}
\index{pmpotential\-\_\-nonperiodic@{pmpotential\-\_\-nonperiodic}!proto.h@{proto.\-h}}
\subsubsection[{pmpotential\-\_\-nonperiodic}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf pmpotential\-\_\-nonperiodic} (
\begin{DoxyParamCaption}
\item[{int}]{grnr}
\end{DoxyParamCaption}
)}}\label{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9}


\-Referenced by compute\-\_\-potential().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a480e7cb454d4e690653cc0db2bb9ebf9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a7938f2181f23d56ac46f3625d1a855a0}{\index{proto.\-h@{proto.\-h}!pmpotential\-\_\-periodic@{pmpotential\-\_\-periodic}}
\index{pmpotential\-\_\-periodic@{pmpotential\-\_\-periodic}!proto.h@{proto.\-h}}
\subsubsection[{pmpotential\-\_\-periodic}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf pmpotential\-\_\-periodic} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a7938f2181f23d56ac46f3625d1a855a0}
\-Calculates the long-\/range potential using the \-P\-M method. \-The potential is \-Gaussian filtered with \-Asmth, given in mesh-\/cell units. \-We carry out a \-C\-I\-C charge assignment, and compute the potenial by \-Fourier transform methods. \-The \-C\-I\-C kernel is deconvolved. 

\-Definition at line 693 of file pm\-\_\-periodic.\-c.



\-References \-All, fft\-\_\-forward\-\_\-plan, fft\-\_\-inverse\-\_\-plan, fft\-\_\-of\-\_\-rhogrid, fftsize, first\-\_\-slab\-\_\-of\-\_\-task, force\-\_\-treeallocate(), force\-\_\-treefree(), forcegrid, meshmax\-\_\-list, meshmin\-\_\-list, nslab\-\_\-y, \-N\-Task, \-Num\-Part, \-P, pm\-\_\-init\-\_\-periodic\-\_\-allocate(), pm\-\_\-init\-\_\-periodic\-\_\-free(), \-P\-M\-G\-R\-I\-D2, \-P\-Task, rhogrid, slab\-\_\-to\-\_\-task, slabs\-\_\-per\-\_\-task, slabstart\-\_\-y, \-T\-A\-G\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-C, \-T\-A\-G\-\_\-\-P\-E\-R\-I\-O\-D\-I\-C\-\_\-\-D, \-This\-Task, to\-\_\-slab\-\_\-fac, and workspace.



\-Referenced by compute\-\_\-potential().


\begin{DoxyCode}
{
  double k2, kx, ky, kz, smth;
  double dx, dy, dz;
  double fx, fy, fz, ff;
  double asmth2, fac;
  int i, j, slab, level, sendTask, recvTask;
  int x, y, z, ip;
  int slab_x, slab_y, slab_z;
  int slab_xx, slab_yy, slab_zz;
  int meshmin[3], meshmax[3], sendmin, sendmax, recvmin, recvmax;
  int rep, ncont, cont_sendmin[2], cont_sendmax[2], cont_recvmin[2], 
      cont_recvmax[2];
  int dimx, dimy, dimz, recv_dimx, recv_dimy, recv_dimz;
  MPI_Status status;

  if(ThisTask == 0)
    {
      printf("Starting periodic PM calculation.\n");
      fflush(stdout);
    }

  asmth2 = (2 * M_PI) * All.Asmth[0] / All.BoxSize;
  asmth2 *= asmth2;

  fac = All.G / (M_PI * All.BoxSize);   /* to get potential */

  force_treefree();

  /* first, establish the extension of the local patch in the PMGRID  */

  for(j = 0; j < 3; j++)
    {
      meshmin[j] = PMGRID;
      meshmax[j] = 0;
    }

  for(i = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          slab = to_slab_fac * P[i].Pos[j];
          if(slab >= PMGRID)
            slab = PMGRID - 1;

          if(slab < meshmin[j])
            meshmin[j] = slab;

          if(slab > meshmax[j])
            meshmax[j] = slab;
        }
    }

  MPI_Allgather(meshmin, 3, MPI_INT, meshmin_list, 3, MPI_INT, MPI_COMM_WORLD);
  MPI_Allgather(meshmax, 3, MPI_INT, meshmax_list, 3, MPI_INT, MPI_COMM_WORLD);

  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  pm_init_periodic_allocate((dimx + 4) * (dimy + 4) * (dimz + 4));

  for(i = 0; i < dimx * dimy * dimz; i++)
    workspace[i] = 0;

  for(i = 0; i < NumPart; i++)
    {
      slab_x = to_slab_fac * P[i].Pos[0];
      if(slab_x >= PMGRID)
        slab_x = PMGRID - 1;
      dx = to_slab_fac * P[i].Pos[0] - slab_x;
      slab_x -= meshmin[0];
      slab_xx = slab_x + 1;

      slab_y = to_slab_fac * P[i].Pos[1];
      if(slab_y >= PMGRID)
        slab_y = PMGRID - 1;
      dy = to_slab_fac * P[i].Pos[1] - slab_y;
      slab_y -= meshmin[1];
      slab_yy = slab_y + 1;

      slab_z = to_slab_fac * P[i].Pos[2];
      if(slab_z >= PMGRID)
        slab_z = PMGRID - 1;
      dz = to_slab_fac * P[i].Pos[2] - slab_z;
      slab_z -= meshmin[2];
      slab_zz = slab_z + 1;

      workspace[(slab_x * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (1.0 -
       dx) * (1.0 - dy) * (1.0 - dz);
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (1.0 
      - dx) * dy * (1.0 - dz);
      workspace[(slab_x * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (1.0 
      - dx) * (1.0 - dy) * dz;
      workspace[(slab_x * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (1.0
       - dx) * dy * dz;

      workspace[(slab_xx * dimy + slab_y) * dimz + slab_z] += P[i].Mass * (dx) 
      * (1.0 - dy) * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_z] += P[i].Mass * (dx)
       * dy * (1.0 - dz);
      workspace[(slab_xx * dimy + slab_y) * dimz + slab_zz] += P[i].Mass * (dx)
       * (1.0 - dy) * dz;
      workspace[(slab_xx * dimy + slab_yy) * dimz + slab_zz] += P[i].Mass * (dx
      ) * dy * dz;
    }


  for(i = 0; i < fftsize; i++)  /* clear local density field */
    rhogrid[i] = 0;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is
       the same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;
      if(recvTask < NTask)
        {
          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -1;
          for(slab_x = meshmin[0]; slab_x < meshmax[0] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == recvTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -1)
            sendmin = 0;

          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -1;
          for(slab_x = meshmin_list[3 * recvTask]; slab_x < meshmax_list[3 * 
      recvTask] + 2; slab_x++)
            if(slab_to_task[slab_x % PMGRID] == sendTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -1)
            recvmin = 0;


          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok,
       we have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * 
      recvTask + 0] + 2;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * 
      recvTask + 1] + 2;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * 
      recvTask + 2] + 2;

              if(level > 0)
                {
                  MPI_Sendrecv(workspace + (sendmin - meshmin[0]) * dimy * dimz
      ,
                               (sendmax - sendmin + 1) * dimy * dimz * sizeof(
      fftw_real), MPI_BYTE, recvTask,
                               TAG_PERIODIC_C, forcegrid,
                               (recvmax - recvmin + 1) * recv_dimy * recv_dimz 
      * sizeof(fftw_real), MPI_BYTE,
                               recvTask, TAG_PERIODIC_C, MPI_COMM_WORLD, &
      status);
                }
              else
                {
                  memcpy(forcegrid, workspace + (sendmin - meshmin[0]) * dimy *
       dimz,
                         (sendmax - sendmin + 1) * dimy * dimz * sizeof(
      fftw_real));
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  slab_xx = (slab_x % PMGRID) - first_slab_of_task[ThisTask];

                  if(slab_xx >= 0 && slab_xx < slabs_per_task[ThisTask])
                    {
                      for(slab_y = meshmin_list[3 * recvTask + 1];
                          slab_y <= meshmax_list[3 * recvTask + 1] + 1; slab_y+
      +)
                        {
                          slab_yy = slab_y;
                          if(slab_yy >= PMGRID)
                            slab_yy -= PMGRID;

                          for(slab_z = meshmin_list[3 * recvTask + 2];
                              slab_z <= meshmax_list[3 * recvTask + 2] + 1; 
      slab_z++)
                            {
                              slab_zz = slab_z;
                              if(slab_zz >= PMGRID)
                                slab_zz -= PMGRID;

                              rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2 * 
      slab_yy + slab_zz] +=
                                forcegrid[((slab_x - recvmin) * recv_dimy +
                                           (slab_y - meshmin_list[3 * recvTask 
      + 1])) * recv_dimz +
                                          (slab_z - meshmin_list[3 * recvTask +
       2])];
                            }
                        }
                    }
                }
            }
        }
    }



  /* Do the FFT of the density field */

  rfftwnd_mpi(fft_forward_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* multiply with Green's function for the potential */

  for(y = slabstart_y; y < slabstart_y + nslab_y; y++)
    for(x = 0; x < PMGRID; x++)
      for(z = 0; z < PMGRID / 2 + 1; z++)
        {
          if(x > PMGRID / 2)
            kx = x - PMGRID;
          else
            kx = x;
          if(y > PMGRID / 2)
            ky = y - PMGRID;
          else
            ky = y;
          if(z > PMGRID / 2)
            kz = z - PMGRID;
          else
            kz = z;

          k2 = kx * kx + ky * ky + kz * kz;

          if(k2 > 0)
            {
              smth = -exp(-k2 * asmth2) / k2 * fac;
              /* do deconvolution */
              fx = fy = fz = 1;
              if(kx != 0)
                {
                  fx = (M_PI * kx) / PMGRID;
                  fx = sin(fx) / fx;
                }
              if(ky != 0)
                {
                  fy = (M_PI * ky) / PMGRID;
                  fy = sin(fy) / fy;
                }
              if(kz != 0)
                {
                  fz = (M_PI * kz) / PMGRID;
                  fz = sin(fz) / fz;
                }
              ff = 1 / (fx * fy * fz);
              smth *= ff * ff * ff * ff;
              /* end deconvolution */

              ip = PMGRID * (PMGRID / 2 + 1) * (y - slabstart_y) + (PMGRID / 2 
      + 1) * x + z;
              fft_of_rhogrid[ip].re *= smth;
              fft_of_rhogrid[ip].im *= smth;
            }
        }

  if(slabstart_y == 0)
    fft_of_rhogrid[0].re = fft_of_rhogrid[0].im = 0.0;

  /* Do the FFT to get the potential */

  rfftwnd_mpi(fft_inverse_plan, 1, rhogrid, workspace, FFTW_TRANSPOSED_ORDER);

  /* note: "rhogrid" now contains the potential */



  dimx = meshmax[0] - meshmin[0] + 6;
  dimy = meshmax[1] - meshmin[1] + 6;
  dimz = meshmax[2] - meshmin[2] + 6;

  for(level = 0; level < (1 << PTask); level++) /* note: for level=0, target is
       the same task */
    {
      sendTask = ThisTask;
      recvTask = ThisTask ^ level;

      if(recvTask < NTask)
        {

          /* check how much we have to send */
          sendmin = 2 * PMGRID;
          sendmax = -PMGRID;
          for(slab_x = meshmin_list[3 * recvTask] - 2; slab_x < meshmax_list[3 
      * recvTask] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == sendTask)
              {
                if(slab_x < sendmin)
                  sendmin = slab_x;
                if(slab_x > sendmax)
                  sendmax = slab_x;
              }
          if(sendmax == -PMGRID)
            sendmin = sendmax + 1;


          /* check how much we have to receive */
          recvmin = 2 * PMGRID;
          recvmax = -PMGRID;
          for(slab_x = meshmin[0] - 2; slab_x < meshmax[0] + 4; slab_x++)
            if(slab_to_task[(slab_x + PMGRID) % PMGRID] == recvTask)
              {
                if(slab_x < recvmin)
                  recvmin = slab_x;
                if(slab_x > recvmax)
                  recvmax = slab_x;
              }
          if(recvmax == -PMGRID)
            recvmin = recvmax + 1;

          if((recvmax - recvmin) >= 0 || (sendmax - sendmin) >= 0)      /* ok,
       we have a contribution to the slab */
            {
              recv_dimx = meshmax_list[3 * recvTask + 0] - meshmin_list[3 * 
      recvTask + 0] + 6;
              recv_dimy = meshmax_list[3 * recvTask + 1] - meshmin_list[3 * 
      recvTask + 1] + 6;
              recv_dimz = meshmax_list[3 * recvTask + 2] - meshmin_list[3 * 
      recvTask + 2] + 6;

              ncont = 1;
              cont_sendmin[0] = sendmin;
              cont_sendmax[0] = sendmax;
              cont_sendmin[1] = sendmax + 1;
              cont_sendmax[1] = sendmax;

              cont_recvmin[0] = recvmin;
              cont_recvmax[0] = recvmax;
              cont_recvmin[1] = recvmax + 1;
              cont_recvmax[1] = recvmax;

              for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask)
                    {
                      /* non-contiguous */
                      cont_sendmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != ThisTask
      )
                        slab_x++;
                      cont_sendmin[1] = slab_x;
                      ncont++;
                    }
                }

              for(slab_x = recvmin; slab_x <= recvmax; slab_x++)
                {
                  if(slab_to_task[(slab_x + PMGRID) % PMGRID] != recvTask)
                    {
                      /* non-contiguous */
                      cont_recvmax[0] = slab_x - 1;
                      while(slab_to_task[(slab_x + PMGRID) % PMGRID] != 
      recvTask)
                        slab_x++;
                      cont_recvmin[1] = slab_x;
                      if(ncont == 1)
                        ncont++;
                    }
                }


              for(rep = 0; rep < ncont; rep++)
                {
                  sendmin = cont_sendmin[rep];
                  sendmax = cont_sendmax[rep];
                  recvmin = cont_recvmin[rep];
                  recvmax = cont_recvmax[rep];

                  /* prepare what we want to send */
                  if(sendmax - sendmin >= 0)
                    {
                      for(slab_x = sendmin; slab_x <= sendmax; slab_x++)
                        {
                          slab_xx = ((slab_x + PMGRID) % PMGRID) - 
      first_slab_of_task[ThisTask];

                          for(slab_y = meshmin_list[3 * recvTask + 1] - 2;
                              slab_y < meshmax_list[3 * recvTask + 1] + 4; 
      slab_y++)
                            {
                              slab_yy = (slab_y + PMGRID) % PMGRID;

                              for(slab_z = meshmin_list[3 * recvTask + 2] - 2;
                                  slab_z < meshmax_list[3 * recvTask + 2] + 4; 
      slab_z++)
                                {
                                  slab_zz = (slab_z + PMGRID) % PMGRID;

                                  forcegrid[((slab_x - sendmin) * recv_dimy +
                                             (slab_y - (meshmin_list[3 * 
      recvTask + 1] - 2))) * recv_dimz +
                                            slab_z - (meshmin_list[3 * recvTask
       + 2] - 2)] =
                                    rhogrid[PMGRID * PMGRID2 * slab_xx + PMGRID2
       * slab_yy + slab_zz];
                                }
                            }
                        }
                    }

                  if(level > 0)
                    {
                      MPI_Sendrecv(forcegrid,
                                   (sendmax - sendmin + 1) * recv_dimy * 
      recv_dimz * sizeof(fftw_real),
                                   MPI_BYTE, recvTask, TAG_PERIODIC_D,
                                   workspace + (recvmin - (meshmin[0] - 2)) * 
      dimy * dimz,
                                   (recvmax - recvmin + 1) * dimy * dimz * 
      sizeof(fftw_real), MPI_BYTE,
                                   recvTask, TAG_PERIODIC_D, MPI_COMM_WORLD, &
      status);
                    }
                  else
                    {
                      memcpy(workspace + (recvmin - (meshmin[0] - 2)) * dimy * 
      dimz,
                             forcegrid, (recvmax - recvmin + 1) * dimy * dimz *
       sizeof(fftw_real));
                    }
                }
            }
        }
    }


  dimx = meshmax[0] - meshmin[0] + 2;
  dimy = meshmax[1] - meshmin[1] + 2;
  dimz = meshmax[2] - meshmin[2] + 2;

  recv_dimx = meshmax[0] - meshmin[0] + 6;
  recv_dimy = meshmax[1] - meshmin[1] + 6;
  recv_dimz = meshmax[2] - meshmin[2] + 6;



  for(x = 0; x < meshmax[0] - meshmin[0] + 2; x++)
    for(y = 0; y < meshmax[1] - meshmin[1] + 2; y++)
      for(z = 0; z < meshmax[2] - meshmin[2] + 2; z++)
        {
          forcegrid[(x * dimy + y) * dimz + z] =
            workspace[((x + 2) * recv_dimy + (y + 2)) * recv_dimz + (z + 2)];
        }


  /* read out the potential */

  for(i = 0; i < NumPart; i++)
    {
      slab_x = to_slab_fac * P[i].Pos[0];
      if(slab_x >= PMGRID)
        slab_x = PMGRID - 1;
      dx = to_slab_fac * P[i].Pos[0] - slab_x;
      slab_x -= meshmin[0];
      slab_xx = slab_x + 1;

      slab_y = to_slab_fac * P[i].Pos[1];
      if(slab_y >= PMGRID)
        slab_y = PMGRID - 1;
      dy = to_slab_fac * P[i].Pos[1] - slab_y;
      slab_y -= meshmin[1];
      slab_yy = slab_y + 1;

      slab_z = to_slab_fac * P[i].Pos[2];
      if(slab_z >= PMGRID)
        slab_z = PMGRID - 1;
      dz = to_slab_fac * P[i].Pos[2] - slab_z;
      slab_z -= meshmin[2];
      slab_zz = slab_z + 1;

      P[i].Potential +=
        forcegrid[(slab_x * dimy + slab_y) * dimz + slab_z] * (1.0 - dx) * (1.0
       - dy) * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_z] * 
      (1.0 - dx) * dy * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_x * dimy + slab_y) * dimz + slab_zz] * 
      (1.0 - dx) * (1.0 - dy) * dz;
      P[i].Potential += forcegrid[(slab_x * dimy + slab_yy) * dimz + slab_zz] *
       (1.0 - dx) * dy * dz;

      P[i].Potential += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_z] * 
      (dx) * (1.0 - dy) * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_z] *
       (dx) * dy * (1.0 - dz);
      P[i].Potential += forcegrid[(slab_xx * dimy + slab_y) * dimz + slab_zz] *
       (dx) * (1.0 - dy) * dz;
      P[i].Potential += forcegrid[(slab_xx * dimy + slab_yy) * dimz + slab_zz] 
      * (dx) * dy * dz;
    }

  pm_init_periodic_free();
  force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart);

  All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;

  if(ThisTask == 0)
    {
      printf("done PM-Potential.\n");
      fflush(stdout);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a7938f2181f23d56ac46f3625d1a855a0_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a7938f2181f23d56ac46f3625d1a855a0_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e}{\index{proto.\-h@{proto.\-h}!pow@{pow}}
\index{pow@{pow}!proto.h@{proto.\-h}}
\subsubsection[{pow}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf pow} (
\begin{DoxyParamCaption}
\item[{double}]{, }
\item[{double}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e}


\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps(), compute\-\_\-global\-\_\-quantities\-\_\-of\-\_\-system(), compute\-\_\-potential(), density(), fill\-\_\-write\-\_\-buffer(), find\-\_\-dt\-\_\-displacement\-\_\-constraint(), growthfactor\-\_\-integ(), hydro\-\_\-force(), hydrokick\-\_\-integ(), init(), move\-\_\-particles(), set\-\_\-units(), setup\-\_\-smoothinglengths(), and timediff().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a96ae9abed439401fd6dd28a1e2c2f94e_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1}{\index{proto.\-h@{proto.\-h}!read\-\_\-file@{read\-\_\-file}}
\index{read\-\_\-file@{read\-\_\-file}!proto.h@{proto.\-h}}
\subsubsection[{read\-\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf read\-\_\-file} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname, }
\item[{int}]{read\-Task, }
\item[{int}]{last\-Task}
\end{DoxyParamCaption}
)}}\label{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1}
\-This function reads a snapshot file and distributes the data it contains to tasks 'read\-Task' to 'last\-Task'. $<$ total number of defined information blocks for snapshot files. \-Must be equal to the number of entries in \char`\"{}enum iofields\char`\"{} 

\-Definition at line 244 of file read\-\_\-ic.\-c.



\-References \-All, allocate\-\_\-memory(), blockpresent(), \-Comm\-Buffer, empty\-\_\-read\-\_\-buffer(), endrun(), fd, get\-\_\-bytes\-\_\-per\-\_\-blockelement(), get\-\_\-dataset\-\_\-name(), get\-\_\-datatype\-\_\-in\-\_\-block(), get\-\_\-particles\-\_\-in\-\_\-block(), get\-\_\-values\-\_\-per\-\_\-blockelement(), header, my\-\_\-fread(), \-N\-\_\-gas, \-N\-Task, \-Num\-Part, \-P, read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5(), \-Restart\-Flag, \-S\-K\-I\-P, \-S\-K\-I\-P2, \-Tab\-\_\-\-I\-O\-\_\-\-Labels, \-T\-A\-G\-\_\-\-H\-E\-A\-D\-E\-R, \-T\-A\-G\-\_\-\-P\-D\-A\-T\-A, and \-This\-Task.



\-Referenced by read\-\_\-ic().


\begin{DoxyCode}
{
  int blockmaxlen;
  int i, n_in_file, n_for_this_task, ntask, pc, offset = 0, task;
  int blksize1, blksize2;
  MPI_Status status;
  FILE *fd = 0;
  int nall;
  int type;
  char label[4];
  int nstart, bytes_per_blockelement, npart, nextblock, typelist[6];
  enum iofields blocknr;

#ifdef HAVE_HDF5
  char buf[500];
  int rank, pcsum;
  hid_t hdf5_file, hdf5_grp[6], hdf5_dataspace_in_file;
  hid_t hdf5_datatype, hdf5_dataspace_in_memory, hdf5_dataset;
  hsize_t dims[2], count[2], start[2];
#endif

#define SKIP  {my_fread(&blksize1,sizeof(int),1,fd);}
#define SKIP2  {my_fread(&blksize2,sizeof(int),1,fd);}

  if(ThisTask == readTask)
    {
      if(All.ICFormat == 1 || All.ICFormat == 2)
        {
          if(!(fd = fopen(fname, "r")))
            {
              printf("can't open file `%s' for reading initial conditions.\n", 
      fname);
              endrun(123);
            }

          if(All.ICFormat == 2)
            {
              SKIP;
              my_fread(&label, sizeof(char), 4, fd);
              my_fread(&nextblock, sizeof(int), 1, fd);
              printf("Reading header => '%c%c%c%c' (%d byte)\n", label[0], 
      label[1], label[2], label[3],
                     nextblock);
              SKIP2;
            }

          SKIP;
          my_fread(&header, sizeof(header), 1, fd);
          SKIP2;

          if(blksize1 != 256 || blksize2 != 256)
            {
              printf("incorrect header format\n");
              fflush(stdout);
              endrun(890);
            }
        }


#ifdef HAVE_HDF5
      if(All.ICFormat == 3)
        {
          read_header_attributes_in_hdf5(fname);

          hdf5_file = H5Fopen(fname, H5F_ACC_RDONLY, H5P_DEFAULT);

          for(type = 0; type < 6; type++)
            {
              if(header.npart[type] > 0)
                {
                  sprintf(buf, "/PartType%d", type);
                  hdf5_grp[type] = H5Gopen(hdf5_file, buf);
                }
            }
        }
#endif

      for(task = readTask + 1; task <= lastTask; task++)
        MPI_Ssend(&header, sizeof(header), MPI_BYTE, task, TAG_HEADER, 
      MPI_COMM_WORLD);
    }
  else
    MPI_Recv(&header, sizeof(header), MPI_BYTE, readTask, TAG_HEADER, 
      MPI_COMM_WORLD, &status);


  if(All.TotNumPart == 0)
    {
      if(header.num_files <= 1)
        for(i = 0; i < 6; i++)
          header.npartTotal[i] = header.npart[i];

      All.TotN_gas = header.npartTotal[0] + (((long long) header.
      npartTotalHighWord[0]) << 32);

      for(i = 0, All.TotNumPart = 0; i < 6; i++)
        {
          All.TotNumPart += header.npartTotal[i];
          All.TotNumPart += (((long long) header.npartTotalHighWord[i]) << 32);
        }


      for(i = 0; i < 6; i++)
        All.MassTable[i] = header.mass[i];

      All.MaxPart = All.PartAllocFactor * (All.TotNumPart / NTask);     /* sets
       the maximum number of particles that may */
      All.MaxPartSph = All.PartAllocFactor * (All.TotN_gas / NTask);    /* sets
       the maximum number of particles that may 
                                                                          
       reside on a processor */
      allocate_memory();

      if(RestartFlag == 2)
        All.Time = All.TimeBegin = header.time;
    }

  if(ThisTask == readTask)
    {
      for(i = 0, n_in_file = 0; i < 6; i++)
        n_in_file += header.npart[i];

      printf("\nreading file `%s' on task=%d (contains %d particles.)\n"
             "distributing this file to tasks %d-%d\n"
             "Type 0 (gas):   %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 1 (halo):  %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 2 (disk):  %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 3 (bulge): %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 4 (stars): %8d  (tot=%6d%09d) masstab=%g\n"
             "Type 5 (bndry): %8d  (tot=%6d%09d) masstab=%g\n\n", fname, 
      ThisTask, n_in_file, readTask,
             lastTask, header.npart[0], (int) (header.npartTotal[0] / 100000000
      0),
             (int) (header.npartTotal[0] % 1000000000), All.MassTable[0], header
      .npart[1],
             (int) (header.npartTotal[1] / 1000000000), (int) (header.
      npartTotal[1] % 1000000000),
             All.MassTable[1], header.npart[2], (int) (header.npartTotal[2] / 1
      000000000),
             (int) (header.npartTotal[2] % 1000000000), All.MassTable[2], header
      .npart[3],
             (int) (header.npartTotal[3] / 1000000000), (int) (header.
      npartTotal[3] % 1000000000),
             All.MassTable[3], header.npart[4], (int) (header.npartTotal[4] / 1
      000000000),
             (int) (header.npartTotal[4] % 1000000000), All.MassTable[4], header
      .npart[5],
             (int) (header.npartTotal[5] / 1000000000), (int) (header.
      npartTotal[5] % 1000000000),
             All.MassTable[5]);
      fflush(stdout);
    }


  ntask = lastTask - readTask + 1;


  /* to collect the gas particles all at the beginning (in case several
     snapshot files are read on the current CPU) we move the collisionless
     particles such that a gap of the right size is created */

  for(type = 0, nall = 0; type < 6; type++)
    {
      n_in_file = header.npart[type];

      n_for_this_task = n_in_file / ntask;
      if((ThisTask - readTask) < (n_in_file % ntask))
        n_for_this_task++;

      nall += n_for_this_task;
    }

  memmove(&P[N_gas + nall], &P[N_gas], (NumPart - N_gas) * sizeof(struct 
      particle_data));
  nstart = N_gas;



  for(blocknr = 0; blocknr < IO_NBLOCKS; blocknr++)
    {
      if(blockpresent(blocknr))
        {
          if(RestartFlag == 0 && blocknr > IO_U)
            continue;           /* ignore all other blocks in initial
       conditions */

          bytes_per_blockelement = get_bytes_per_blockelement(blocknr);

          blockmaxlen = ((int) (All.BufferSize * 1024 * 1024)) / 
      bytes_per_blockelement;

          npart = get_particles_in_block(blocknr, &typelist[0]);

          if(npart > 0)
            {
              if(ThisTask == readTask)
                {
                  if(All.ICFormat == 2)
                    {
                      SKIP;
                      my_fread(&label, sizeof(char), 4, fd);
                      my_fread(&nextblock, sizeof(int), 1, fd);
                      printf("Reading header => '%c%c%c%c' (%d byte)\n", label[
      0], label[1], label[2],
                             label[3], nextblock);
                      SKIP2;

                      if(strncmp(label, Tab_IO_Labels[blocknr], 4) != 0)
                        {
                          printf("incorrect block-structure!\n");
                          printf("expected '%c%c%c%c' but found '%c%c%c%c'\n",
                                 label[0], label[1], label[2], label[3],
                                 Tab_IO_Labels[blocknr][0], Tab_IO_Labels[
      blocknr][1],
                                 Tab_IO_Labels[blocknr][2], Tab_IO_Labels[
      blocknr][3]);
                          fflush(stdout);
                          endrun(1890);
                        }
                    }

                  if(All.ICFormat == 1 || All.ICFormat == 2)
                    SKIP;
                }

              for(type = 0, offset = 0; type < 6; type++)
                {
                  n_in_file = header.npart[type];
#ifdef HAVE_HDF5
                  pcsum = 0;
#endif
                  if(typelist[type] == 0)
                    {
                      n_for_this_task = n_in_file / ntask;
                      if((ThisTask - readTask) < (n_in_file % ntask))
                        n_for_this_task++;

                      offset += n_for_this_task;
                    }
                  else
                    {
                      for(task = readTask; task <= lastTask; task++)
                        {
                          n_for_this_task = n_in_file / ntask;
                          if((task - readTask) < (n_in_file % ntask))
                            n_for_this_task++;

                          if(task == ThisTask)
                            if(NumPart + n_for_this_task > All.MaxPart)
                              {
                                printf("too many particles\n");
                                endrun(1313);
                              }


                          do
                            {
                              pc = n_for_this_task;

                              if(pc > blockmaxlen)
                                pc = blockmaxlen;

                              if(ThisTask == readTask)
                                {
                                  if(All.ICFormat == 1 || All.ICFormat == 2)
                                    my_fread(CommBuffer, bytes_per_blockelement
      , pc, fd);
#ifdef HAVE_HDF5
                                  if(All.ICFormat == 3)
                                    {
                                      get_dataset_name(blocknr, buf);
                                      hdf5_dataset = H5Dopen(hdf5_grp[type], 
      buf);

                                      dims[0] = header.npart[type];
                                      dims[1] = get_values_per_blockelement(
      blocknr);
                                      if(dims[1] == 1)
                                        rank = 1;
                                      else
                                        rank = 2;

                                      hdf5_dataspace_in_file = H5Screate_simple
      (rank, dims, NULL);

                                      dims[0] = pc;
                                      hdf5_dataspace_in_memory = 
      H5Screate_simple(rank, dims, NULL);

                                      start[0] = pcsum;
                                      start[1] = 0;

                                      count[0] = pc;
                                      count[1] = get_values_per_blockelement(
      blocknr);
                                      pcsum += pc;

                                      H5Sselect_hyperslab(
      hdf5_dataspace_in_file, H5S_SELECT_SET,
                                                          start, NULL, count, 
      NULL);

                                      switch (get_datatype_in_block(blocknr))
                                        {
                                        case 0:
                                          hdf5_datatype = H5Tcopy(
      H5T_NATIVE_UINT);
                                          break;
                                        case 1:
                                          hdf5_datatype = H5Tcopy(
      H5T_NATIVE_FLOAT);
                                          break;
                                        case 2:
                                          hdf5_datatype = H5Tcopy(
      H5T_NATIVE_UINT64);
                                          break;
                                        }

                                      H5Dread(hdf5_dataset, hdf5_datatype, 
      hdf5_dataspace_in_memory,
                                              hdf5_dataspace_in_file, 
      H5P_DEFAULT, CommBuffer);

                                      H5Tclose(hdf5_datatype);
                                      H5Sclose(hdf5_dataspace_in_memory);
                                      H5Sclose(hdf5_dataspace_in_file);
                                      H5Dclose(hdf5_dataset);
                                    }
#endif
                                }

                              if(ThisTask == readTask && task != readTask)
                                MPI_Ssend(CommBuffer, bytes_per_blockelement * 
      pc, MPI_BYTE, task, TAG_PDATA,
                                          MPI_COMM_WORLD);

                              if(ThisTask != readTask && task == ThisTask)
                                MPI_Recv(CommBuffer, bytes_per_blockelement * 
      pc, MPI_BYTE, readTask,
                                         TAG_PDATA, MPI_COMM_WORLD, &status);

                              if(ThisTask == task)
                                {
                                  empty_read_buffer(blocknr, nstart + offset, 
      pc, type);

                                  offset += pc;
                                }

                              n_for_this_task -= pc;
                            }
                          while(n_for_this_task > 0);
                        }
                    }
                }
              if(ThisTask == readTask)
                {
                  if(All.ICFormat == 1 || All.ICFormat == 2)
                    {
                      SKIP2;
                      if(blksize1 != blksize2)
                        {
                          printf("incorrect block-sizes detected!\n");
                          printf("Task=%d   blocknr=%d  blksize1=%d 
       blksize2=%d\n", ThisTask, blocknr,
                                 blksize1, blksize2);
                          fflush(stdout);
                          endrun(1889);
                        }
                    }
                }
            }
        }
    }


  for(type = 0; type < 6; type++)
    {
      n_in_file = header.npart[type];

      n_for_this_task = n_in_file / ntask;
      if((ThisTask - readTask) < (n_in_file % ntask))
        n_for_this_task++;

      NumPart += n_for_this_task;

      if(type == 0)
        N_gas += n_for_this_task;
    }

  if(ThisTask == readTask)
    {
      if(All.ICFormat == 1 || All.ICFormat == 2)
        fclose(fd);
#ifdef HAVE_HDF5
      if(All.ICFormat == 3)
        {
          for(type = 5; type >= 0; type--)
            if(header.npart[type] > 0)
              H5Gclose(hdf5_grp[type]);
          H5Fclose(hdf5_file);
        }
#endif
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_affd0f4e6b7bcdabf7d6f8191145f78d1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9}{\index{proto.\-h@{proto.\-h}!read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5@{read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5}}
\index{read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5@{read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5}!proto.h@{proto.\-h}}
\subsubsection[{read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf read\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9}
\-This function reads the header information in case the \-H\-D\-F5 file format is used. 

\-Definition at line 764 of file read\-\_\-ic.\-c.



\-References header.



\-Referenced by find\-\_\-files(), and read\-\_\-file().


\begin{DoxyCode}
{
  hid_t hdf5_file, hdf5_headergrp, hdf5_attribute;


  hdf5_file = H5Fopen(fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  hdf5_headergrp = H5Gopen(hdf5_file, "/Header");


  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumPart_ThisFile");
  H5Aread(hdf5_attribute, H5T_NATIVE_INT, header.npart);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumPart_Total");
  H5Aread(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotal);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumPart_Total_HighWord");
  H5Aread(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotalHighWord);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "MassTable");
  H5Aread(hdf5_attribute, H5T_NATIVE_DOUBLE, header.mass);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "Time");
  H5Aread(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.time);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "NumFilesPerSnapshot");
  H5Aread(hdf5_attribute, H5T_NATIVE_INT, &header.num_files);
  H5Aclose(hdf5_attribute);

  hdf5_attribute = H5Aopen_name(hdf5_headergrp, "Flag_Entropy_ICs");
  H5Aread(hdf5_attribute, H5T_NATIVE_INT, &header.flag_entropy_instead_u);
  H5Aclose(hdf5_attribute);

  H5Gclose(hdf5_headergrp);
  H5Fclose(hdf5_file);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af87c21a0c70ac5e7d5f769b952d08fe9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a150344fdc0c6e132aecdb6c646529df1}{\index{proto.\-h@{proto.\-h}!read\-\_\-ic@{read\-\_\-ic}}
\index{read\-\_\-ic@{read\-\_\-ic}!proto.h@{proto.\-h}}
\subsubsection[{read\-\_\-ic}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf read\-\_\-ic} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{proto_8h_a150344fdc0c6e132aecdb6c646529df1}
\-This function reads initial conditions, in one of the three possible file formats currently supported by \-Gadget. \-Note\-: \-When a snapshot file is started from initial conditions (start-\/option 0), not all the information in the header is used, in particular, the \-S\-T\-A\-R\-T\-I\-N\-G \-T\-I\-M\-E needs to be set in the parameterfile. \-Also, for gas particles, only the internal energy is read, the density and mean molecular weight will be recomputed by the code. \-When \-Init\-Gas\-Temp$>$0 is given, the gas temperature will be initialzed to this value assuming a mean colecular weight either corresponding to complete neutrality, or full ionization.

\-However, when the code is started with start-\/option 2, then all the this data in the snapshot files is preserved, i.\-e. this is also the way to resume a simulation from a snapshot file in case a regular restart file is not available. $<$ adiabatic index of simulated gas

$<$ mass fraction of hydrogen, relevant only for radiative cooling

$<$ mass fraction of hydrogen, relevant only for radiative cooling 

\-Definition at line 31 of file read\-\_\-ic.\-c.



\-References \-All, distribute\-\_\-file(), dmax(), fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels(), find\-\_\-files(), \-N\-\_\-gas, \-N\-Task, \-Num\-Part, \-P, read\-\_\-file(), \-Restart\-Flag, \-Sph\-P, and \-This\-Task.



\-Referenced by init().


\begin{DoxyCode}
{
  int i, num_files, rest_files, ngroups, gr, filenr, masterTask, lastTask, 
      groupMaster;
  double u_init;
  char buf[500];

#ifndef ISOTHERM_EQS
  double molecular_weight;
#endif
#ifdef SFR
  double original_gas_mass, mass, masstot;
#endif

  NumPart = 0;
  N_gas = 0;
  All.TotNumPart = 0;

  num_files = find_files(fname);

  rest_files = num_files;

  fill_Tab_IO_Labels();

  while(rest_files > NTask)
    {
      sprintf(buf, "%s.%d", fname, ThisTask + (rest_files - NTask));
      if(All.ICFormat == 3)
        sprintf(buf, "%s.%d.hdf5", fname, ThisTask + (rest_files - NTask));

      ngroups = NTask / All.NumFilesWrittenInParallel;
      if((NTask % All.NumFilesWrittenInParallel))
        ngroups++;
      groupMaster = (ThisTask / ngroups) * ngroups;

      for(gr = 0; gr < ngroups; gr++)
        {
          if(ThisTask == (groupMaster + gr))    /* ok, it's this processor's
       turn */
            read_file(buf, ThisTask, ThisTask);
          MPI_Barrier(MPI_COMM_WORLD);
        }

      rest_files -= NTask;
    }


  if(rest_files > 0)
    {
      distribute_file(rest_files, 0, 0, NTask - 1, &filenr, &masterTask, &
      lastTask);

      if(num_files > 1)
        {
          sprintf(buf, "%s.%d", fname, filenr);
          if(All.ICFormat == 3)
            sprintf(buf, "%s.%d.hdf5", fname, filenr);
        }
      else
        {
          sprintf(buf, "%s", fname);
          if(All.ICFormat == 3)
            sprintf(buf, "%s.hdf5", fname);
        }

      ngroups = rest_files / All.NumFilesWrittenInParallel;
      if((rest_files % All.NumFilesWrittenInParallel))
        ngroups++;

      for(gr = 0; gr < ngroups; gr++)
        {
          if((filenr / All.NumFilesWrittenInParallel) == gr)    /* ok, it's
       this processor's turn */
            read_file(buf, masterTask, lastTask);
          MPI_Barrier(MPI_COMM_WORLD);
        }
    }


  /* this makes sure that masses are initialized in the case that the
       mass-block
     is completely empty */
  for(i = 0; i < NumPart; i++)
    {
      if(All.MassTable[P[i].Type] != 0)
        P[i].Mass = All.MassTable[P[i].Type];
    }

  if(RestartFlag == 0)
    {
      if(All.InitGasTemp > 0)
        {
          u_init = (BOLTZMANN / PROTONMASS) * All.InitGasTemp;
          u_init *= All.UnitMass_in_g / All.UnitEnergy_in_cgs;  /* unit
       conversion */

#ifdef ISOTHERM_EQS
          u_init *= 1.0;
#else
          u_init *= (1.0 / GAMMA_MINUS1);

          if(All.InitGasTemp > 1.0e4)   /* assuming FULL ionization */
            molecular_weight = 4 / (8 - 5 * (1 - HYDROGEN_MASSFRAC));
          else                  /* assuming NEUTRAL GAS */
            molecular_weight = 4 / (1 + 3 * HYDROGEN_MASSFRAC);

          u_init /= molecular_weight;
#endif

          for(i = 0; i < N_gas; i++)
            {
              if(SphP[i].Entropy == 0)
                SphP[i].Entropy = u_init;

              /* Note: the coversion to entropy will be done in the function
       init(),
                 after the densities have been computed */
            }
        }
    }

  for(i = 0; i < N_gas; i++)
    SphP[i].Entropy = dmax(All.MinEgySpec, SphP[i].Entropy);

  MPI_Barrier(MPI_COMM_WORLD);

  if(ThisTask == 0)
    {
      printf("reading done.\n");
      fflush(stdout);
    }

  if(ThisTask == 0)
    {
      printf("Total number of particles :  %d%09d\n\n",
             (int) (All.TotNumPart / 1000000000), (int) (All.TotNumPart % 10000
      00000));
      fflush(stdout);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a150344fdc0c6e132aecdb6c646529df1_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a150344fdc0c6e132aecdb6c646529df1_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a849a294ac908c933ffb82dc4319af513}{\index{proto.\-h@{proto.\-h}!read\-\_\-outputlist@{read\-\_\-outputlist}}
\index{read\-\_\-outputlist@{read\-\_\-outputlist}!proto.h@{proto.\-h}}
\subsubsection[{read\-\_\-outputlist}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf read\-\_\-outputlist} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{proto_8h_a849a294ac908c933ffb82dc4319af513}
this function reads a table with a list of desired output times. \-The table does not have to be ordered in any way, but may not contain more than \-M\-A\-X\-L\-E\-N\-\_\-\-O\-U\-T\-P\-U\-T\-L\-I\-S\-T entries. $<$ maxmimum number of entries in list of snapshot output times 

\-Definition at line 777 of file begrun.\-c.



\-References \-All, and fd.



\-Referenced by read\-\_\-parameter\-\_\-file().


\begin{DoxyCode}
{
  FILE *fd;

  if(!(fd = fopen(fname, "r")))
    {
      printf("can't read output list in file '%s'\n", fname);
      return 1;
    }

  All.OutputListLength = 0;
  do
    {
      if(fscanf(fd, " %lg ", &All.OutputListTimes[All.OutputListLength]) == 1)
        All.OutputListLength++;
      else
        break;
    }
  while(All.OutputListLength < MAXLEN_OUTPUTLIST);

  fclose(fd);

  printf("\nfound %d times in output-list.\n", All.OutputListLength);

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a849a294ac908c933ffb82dc4319af513_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a952eae1977b498c4fdfabed1742a3ba2}{\index{proto.\-h@{proto.\-h}!read\-\_\-parameter\-\_\-file@{read\-\_\-parameter\-\_\-file}}
\index{read\-\_\-parameter\-\_\-file@{read\-\_\-parameter\-\_\-file}!proto.h@{proto.\-h}}
\subsubsection[{read\-\_\-parameter\-\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf read\-\_\-parameter\-\_\-file} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{proto_8h_a952eae1977b498c4fdfabed1742a3ba2}
\-This function parses the parameterfile in a simple way. \-Each paramater is defined by a keyword (`tag'), and can be either of type double, int, or character string. \-The routine makes sure that each parameter appears exactly once in the parameterfile, otherwise error messages are produced that complain about the missing parameters. 

\-Definition at line 288 of file begrun.\-c.



\-References \-All, \-D\-O\-U\-B\-L\-E, endrun(), fd, \-I\-N\-T, \-M\-A\-X\-T\-A\-G\-S, \-N\-Task, read\-\_\-outputlist(), \-S\-T\-R\-I\-N\-G, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
#define DOUBLE 1
#define STRING 2
#define INT 3
#define MAXTAGS 300

  FILE *fd, *fdout;
  char buf[200], buf1[200], buf2[200], buf3[400];
  int i, j, nt;
  int id[MAXTAGS];
  void *addr[MAXTAGS];
  char tag[MAXTAGS][50];
  int  errorFlag = 0;


  if(sizeof(long long) != 8)
    {
      if(ThisTask == 0)
        printf("\nType `long long' is not 64 bit on this platform. Stopping.\n
      \n");
      endrun(0);
    }

  if(sizeof(int) != 4)
    {
      if(ThisTask == 0)
        printf("\nType `int' is not 32 bit on this platform. Stopping.\n\n");
      endrun(0);
    }

  if(sizeof(float) != 4)
    {
      if(ThisTask == 0)
        printf("\nType `float' is not 32 bit on this platform. Stopping.\n\n");
      endrun(0);
    }

  if(sizeof(double) != 8)
    {
      if(ThisTask == 0)
        printf("\nType `double' is not 64 bit on this platform. Stopping.\n\n")
      ;
      endrun(0);
    }


  if(ThisTask == 0)             /* read parameter file on process 0 */
    {
      nt = 0;

      strcpy(tag[nt], "InitCondFile");
      addr[nt] = All.InitCondFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputDir");
      addr[nt] = All.OutputDir;
      id[nt++] = STRING;

      strcpy(tag[nt], "SnapshotFileBase");
      addr[nt] = All.SnapshotFileBase;
      id[nt++] = STRING;

      strcpy(tag[nt], "EnergyFile");
      addr[nt] = All.EnergyFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "CpuFile");
      addr[nt] = All.CpuFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "InfoFile");
      addr[nt] = All.InfoFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "TimingsFile");
      addr[nt] = All.TimingsFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "RestartFile");
      addr[nt] = All.RestartFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "ResubmitCommand");
      addr[nt] = All.ResubmitCommand;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputListFilename");
      addr[nt] = All.OutputListFilename;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputListOn");
      addr[nt] = &All.OutputListOn;
      id[nt++] = INT;

      strcpy(tag[nt], "Omega0");
      addr[nt] = &All.Omega0;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "OmegaBaryon");
      addr[nt] = &All.OmegaBaryon;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "OmegaLambda");
      addr[nt] = &All.OmegaLambda;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "HubbleParam");
      addr[nt] = &All.HubbleParam;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "BoxSize");
      addr[nt] = &All.BoxSize;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "PeriodicBoundariesOn");
      addr[nt] = &All.PeriodicBoundariesOn;
      id[nt++] = INT;

      strcpy(tag[nt], "TimeOfFirstSnapshot");
      addr[nt] = &All.TimeOfFirstSnapshot;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "CpuTimeBetRestartFile");
      addr[nt] = &All.CpuTimeBetRestartFile;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBetStatistics");
      addr[nt] = &All.TimeBetStatistics;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBegin");
      addr[nt] = &All.TimeBegin;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeMax");
      addr[nt] = &All.TimeMax;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBetSnapshot");
      addr[nt] = &All.TimeBetSnapshot;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitVelocity_in_cm_per_s");
      addr[nt] = &All.UnitVelocity_in_cm_per_s;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitLength_in_cm");
      addr[nt] = &All.UnitLength_in_cm;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitMass_in_g");
      addr[nt] = &All.UnitMass_in_g;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TreeDomainUpdateFrequency");
      addr[nt] = &All.TreeDomainUpdateFrequency;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolIntAccuracy");
      addr[nt] = &All.ErrTolIntAccuracy;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolTheta");
      addr[nt] = &All.ErrTolTheta;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolForceAcc");
      addr[nt] = &All.ErrTolForceAcc;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinGasHsmlFractional");
      addr[nt] = &All.MinGasHsmlFractional;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxSizeTimestep");
      addr[nt] = &All.MaxSizeTimestep;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinSizeTimestep");
      addr[nt] = &All.MinSizeTimestep;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxRMSDisplacementFac");
      addr[nt] = &All.MaxRMSDisplacementFac;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ArtBulkViscConst");
      addr[nt] = &All.ArtBulkViscConst;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "CourantFac");
      addr[nt] = &All.CourantFac;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "DesNumNgb");
      addr[nt] = &All.DesNumNgb;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxNumNgbDeviation");
      addr[nt] = &All.MaxNumNgbDeviation;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ComovingIntegrationOn");
      addr[nt] = &All.ComovingIntegrationOn;
      id[nt++] = INT;

      strcpy(tag[nt], "ICFormat");
      addr[nt] = &All.ICFormat;
      id[nt++] = INT;

      strcpy(tag[nt], "SnapFormat");
      addr[nt] = &All.SnapFormat;
      id[nt++] = INT;

      strcpy(tag[nt], "NumFilesPerSnapshot");
      addr[nt] = &All.NumFilesPerSnapshot;
      id[nt++] = INT;

      strcpy(tag[nt], "NumFilesWrittenInParallel");
      addr[nt] = &All.NumFilesWrittenInParallel;
      id[nt++] = INT;

      strcpy(tag[nt], "ResubmitOn");
      addr[nt] = &All.ResubmitOn;
      id[nt++] = INT;

      strcpy(tag[nt], "TypeOfTimestepCriterion");
      addr[nt] = &All.TypeOfTimestepCriterion;
      id[nt++] = INT;

      strcpy(tag[nt], "TypeOfOpeningCriterion");
      addr[nt] = &All.TypeOfOpeningCriterion;
      id[nt++] = INT;

      strcpy(tag[nt], "TimeLimitCPU");
      addr[nt] = &All.TimeLimitCPU;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningHalo");
      addr[nt] = &All.SofteningHalo;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningDisk");
      addr[nt] = &All.SofteningDisk;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBulge");
      addr[nt] = &All.SofteningBulge;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningGas");
      addr[nt] = &All.SofteningGas;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningStars");
      addr[nt] = &All.SofteningStars;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBndry");
      addr[nt] = &All.SofteningBndry;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningHaloMaxPhys");
      addr[nt] = &All.SofteningHaloMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningDiskMaxPhys");
      addr[nt] = &All.SofteningDiskMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBulgeMaxPhys");
      addr[nt] = &All.SofteningBulgeMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningGasMaxPhys");
      addr[nt] = &All.SofteningGasMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningStarsMaxPhys");
      addr[nt] = &All.SofteningStarsMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBndryMaxPhys");
      addr[nt] = &All.SofteningBndryMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "BufferSize");
      addr[nt] = &All.BufferSize;
      id[nt++] = INT;

      strcpy(tag[nt], "PartAllocFactor");
      addr[nt] = &All.PartAllocFactor;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TreeAllocFactor");
      addr[nt] = &All.TreeAllocFactor;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "GravityConstantInternal");
      addr[nt] = &All.GravityConstantInternal;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "InitGasTemp");
      addr[nt] = &All.InitGasTemp;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinGasTemp");
      addr[nt] = &All.MinGasTemp;
      id[nt++] = DOUBLE;

#ifdef COMPUTE_SELFINTERACTION_FORDARK 
      strcpy(tag[nt], "InteractionCrossSection");
      addr[nt] = &All.InteractionCrossSection;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SIDMSmoothingFactor");
      addr[nt] = &All.SIDMSmoothingFactor;
      id[nt++] = DOUBLE;
#endif

      if((fd = fopen(fname, "r")))
        {
          sprintf(buf, "%s%s", fname, "-usedvalues");
          if(!(fdout = fopen(buf, "w")))
            {
              printf("error opening file '%s' \n", buf);
              errorFlag = 1;
            }
          else
            {
              while(!feof(fd))
                {
                  *buf = 0;
                  fgets(buf, 200, fd);
                  if(sscanf(buf, "%s%s%s", buf1, buf2, buf3) < 2)
                    continue;

                  if(buf1[0] == '%')
                    continue;

                  for(i = 0, j = -1; i < nt; i++)
                    if(strcmp(buf1, tag[i]) == 0)
                      {
                        j = i;
                        tag[i][0] = 0;
                        break;
                      }

                  if(j >= 0)
                    {
                      switch (id[j])
                        {
                        case DOUBLE:
                          *((double *) addr[j]) = atof(buf2);
                          fprintf(fdout, "%-35s%g\n", buf1, *((double *) addr[j
      ]));
                          break;
                        case STRING:
                          strcpy(addr[j], buf2);
                          fprintf(fdout, "%-35s%s\n", buf1, buf2);
                          break;
                        case INT:
                          *((int *) addr[j]) = atoi(buf2);
                          fprintf(fdout, "%-35s%d\n", buf1, *((int *) addr[j]))
      ;
                          break;
                        }
                    }
                  else
                    {
                      fprintf(stdout, "Error in file %s:   Tag '%s' not allowed
       or multiple defined.\n",
                              fname, buf1);
                      errorFlag = 1;
                    }
                }
              fclose(fd);
              fclose(fdout);

              i = strlen(All.OutputDir);
              if(i > 0)
                if(All.OutputDir[i - 1] != '/')
                  strcat(All.OutputDir, "/");

              sprintf(buf1, "%s%s", fname, "-usedvalues");
              sprintf(buf2, "%s%s", All.OutputDir, "parameters-usedvalues");
              sprintf(buf3, "cp %s %s", buf1, buf2);
              system(buf3);
            }
        }
      else
        {
          printf("\nParameter file %s not found.\n\n", fname);
          errorFlag = 2;
        }

      if(errorFlag != 2)
        for(i = 0; i < nt; i++)
          {
            if(*tag[i])
              {
                printf("Error. I miss a value for tag '%s' in parameter file
       '%s'.\n", tag[i], fname);
                errorFlag = 1;
              }
          }

      if(All.OutputListOn && errorFlag == 0)
        errorFlag += read_outputlist(All.OutputListFilename);
      else
        All.OutputListLength = 0;
    }

  MPI_Bcast(&errorFlag, 1, MPI_INT, 0, MPI_COMM_WORLD);

  if(errorFlag)
    {
      MPI_Finalize();
      exit(0);
    }

  /* now communicate the relevant parameters to the other processes */
  MPI_Bcast(&All, sizeof(struct global_data_all_processes), MPI_BYTE, 0, 
      MPI_COMM_WORLD);


  if(All.NumFilesWrittenInParallel < 1)
    {
      if(ThisTask == 0)
        printf("NumFilesWrittenInParallel MUST be at least 1\n");
      endrun(0);
    }

  if(All.NumFilesWrittenInParallel > NTask)
    {
      if(ThisTask == 0)
        printf("NumFilesWrittenInParallel MUST be smaller than number of
       processors\n");
      endrun(0);
    }

#ifdef PERIODIC
  if(All.PeriodicBoundariesOn == 0)
    {
      if(ThisTask == 0)
        {
          printf("Code was compiled with periodic boundary conditions switched
       on.\n");
          printf("You must set `PeriodicBoundariesOn=1', or recompile the code.
      \n");
        }
      endrun(0);
    }
#else
  if(All.PeriodicBoundariesOn == 1)
    {
      if(ThisTask == 0)
        {
          printf("Code was compiled with periodic boundary conditions switched
       off.\n");
          printf("You must set `PeriodicBoundariesOn=0', or recompile the code.
      \n");
        }
      endrun(0);
    }
#endif


  if(All.TypeOfTimestepCriterion >= 1)
    {
      if(ThisTask == 0)
        {
          printf("The specified timestep criterion\n");
          printf("is not valid\n");
        }
      endrun(0);
    }

#if defined(LONG_X) ||  defined(LONG_Y) || defined(LONG_Z)
#ifndef NOGRAVITY
  if(ThisTask == 0)
    {
      printf("Code was compiled with LONG_X/Y/Z, but not with NOGRAVITY.\n");
      printf("Stretched periodic boxes are not implemented for gravity yet.\n")
      ;
    }
  endrun(0);
#endif
#endif

#undef DOUBLE
#undef STRING
#undef INT
#undef MAXTAGS
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a952eae1977b498c4fdfabed1742a3ba2_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a952eae1977b498c4fdfabed1742a3ba2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98}{\index{proto.\-h@{proto.\-h}!readjust\-\_\-timebase@{readjust\-\_\-timebase}}
\index{readjust\-\_\-timebase@{readjust\-\_\-timebase}!proto.h@{proto.\-h}}
\subsubsection[{readjust\-\_\-timebase}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf readjust\-\_\-timebase} (
\begin{DoxyParamCaption}
\item[{double}]{\-Time\-Max\-\_\-old, }
\item[{double}]{\-Time\-Max\-\_\-new}
\end{DoxyParamCaption}
)}}\label{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98}
\-If a restart from restart-\/files is carried out where the \-Time\-Max variable is increased, then the integer timeline needs to be adjusted. \-The approach taken here is to reduce the resolution of the integer timeline by factors of 2 until the new final time can be reached within \-T\-I\-M\-E\-B\-A\-S\-E. $<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29 

\-Definition at line 811 of file begrun.\-c.



\-References \-All, endrun(), \-Num\-Part, \-P, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  int i;
  long long ti_end;

  if(ThisTask == 0)
    {
      printf("\nAll.TimeMax has been changed in the parameterfile\n");
      printf("Need to adjust integer timeline\n\n\n");
    }

  if(TimeMax_new < TimeMax_old)
    {
      if(ThisTask == 0)
        printf("\nIt is not allowed to reduce All.TimeMax\n\n");
      endrun(556);
    }

  if(All.ComovingIntegrationOn)
    ti_end = log(TimeMax_new / All.TimeBegin) / All.Timebase_interval;
  else
    ti_end = (TimeMax_new - All.TimeBegin) / All.Timebase_interval;

  while(ti_end > TIMEBASE)
    {
      All.Timebase_interval *= 2.0;

      ti_end /= 2;
      All.Ti_Current /= 2;

#ifdef PMGRID
      All.PM_Ti_begstep /= 2;
      All.PM_Ti_endstep /= 2;
#endif

      for(i = 0; i < NumPart; i++)
        {
          P[i].Ti_begstep /= 2;
          P[i].Ti_endstep /= 2;
        }
    }

  All.TimeMax = TimeMax_new;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_acc4d1f5e4e51140090a7ce25ea263b98_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af744cef873e3093ba2924da8265d1711}{\index{proto.\-h@{proto.\-h}!reorder\-\_\-gas@{reorder\-\_\-gas}}
\index{reorder\-\_\-gas@{reorder\-\_\-gas}!proto.h@{proto.\-h}}
\subsubsection[{reorder\-\_\-gas}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf reorder\-\_\-gas} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_af744cef873e3093ba2924da8265d1711}
\-This function brings the gas particles into the same order as the sorted keys. (\-The sort is first done only on the keys themselves and done directly on the gas particles in order to reduce the amount of data that needs to be moved in memory. \-Only once the order is established, the gas particles are rearranged, such that each particle has to be moved at most once.) 

\-Definition at line 117 of file peano.\-c.



\-References \-Id, \-N\-\_\-gas, \-P, and \-Sph\-P.



\-Referenced by peano\-\_\-hilbert\-\_\-order().


\begin{DoxyCode}
{
  int i;
  struct particle_data Psave, Psource;
  struct sph_particle_data SphPsave, SphPsource;
  int idsource, idsave, dest;

  for(i = 0; i < N_gas; i++)
    {
      if(Id[i] != i)
        {
          Psource = P[i];
          SphPsource = SphP[i];

          idsource = Id[i];
          dest = Id[i];

          do
            {
              Psave = P[dest];
              SphPsave = SphP[dest];
              idsave = Id[dest];

              P[dest] = Psource;
              SphP[dest] = SphPsource;
              Id[dest] = idsource;

              if(dest == i)
                break;

              Psource = Psave;
              SphPsource = SphPsave;
              idsource = idsave;

              dest = idsource;
            }
          while(1);
        }
    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af744cef873e3093ba2924da8265d1711_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba}{\index{proto.\-h@{proto.\-h}!reorder\-\_\-particles@{reorder\-\_\-particles}}
\index{reorder\-\_\-particles@{reorder\-\_\-particles}!proto.h@{proto.\-h}}
\subsubsection[{reorder\-\_\-particles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf reorder\-\_\-particles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba}
\-This function brings the collisionless particles into the same order as the sorted keys. (\-The sort is first done only on the keys themselves and done directly on the particles in order to reduce the amount of data that needs to be moved in memory. \-Only once the order is established, the particles are rearranged, such that each particle has to be moved at most once.) 

\-Definition at line 166 of file peano.\-c.



\-References \-Id, \-N\-\_\-gas, \-Num\-Part, and \-P.



\-Referenced by peano\-\_\-hilbert\-\_\-order().


\begin{DoxyCode}
{
  int i;
  struct particle_data Psave, Psource;
  int idsource, idsave, dest;

  for(i = N_gas; i < NumPart; i++)
    {
      if(Id[i] != i)
        {
          Psource = P[i];
          idsource = Id[i];

          dest = Id[i];

          do
            {
              Psave = P[dest];
              idsave = Id[dest];

              P[dest] = Psource;
              Id[dest] = idsource;

              if(dest == i)
                break;

              Psource = Psave;
              idsource = idsave;

              dest = idsource;
            }
          while(1);
        }
    }
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_afcb358154dd7fd5de8b4156f417fb0ba_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}{\index{proto.\-h@{proto.\-h}!restart@{restart}}
\index{restart@{restart}!proto.h@{proto.\-h}}
\subsubsection[{restart}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf restart} (
\begin{DoxyParamCaption}
\item[{int}]{modus}
\end{DoxyParamCaption}
)}}\label{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}
\-This function reads or writes the restart files. \-Each processor writes its own restart file, with the \-I/\-O being done in parallel. \-To avoid congestion of the disks you can tell the program to restrict the number of files that are simultaneously written to \-Num\-Files\-Written\-In\-Parallel.

\-If modus$>$0 the \hyperlink{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9}{restart()}-\/routine reads, if modus==0 it writes a restart file. $<$ defines maximum length of neighbour list

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition

$<$ \-Maximum number of nodes in the top-\/level tree used for domain decomposition 

\-Definition at line 35 of file restart.\-c.



\-References \-All, allocate\-\_\-memory(), byten(), \-Domain\-Center, \-Domain\-Corner, \-Domain\-End\-List, \-Domain\-Fac, \-Domain\-Hmax, \-Domain\-Len, \-Domain\-Moment, \-Domain\-My\-Last, \-Domain\-My\-Start, \-Domain\-Node\-Index, \-Domain\-Start\-List, \-Domain\-Task, \-Domain\-Tree\-Node\-Len, endrun(), \-Extnodes\-\_\-base, \-Father, fd, force\-\_\-treeallocate(), in(), \-Max\-Nodes, \-N\-\_\-gas, \-Nextnode, ngb\-\_\-treeallocate(), \-Nodes\-\_\-base, \-N\-Task, \-Numnodestree, \-Num\-Part, \-P, random\-\_\-generator, \-Sph\-P, and \-This\-Task.



\-Referenced by begrun(), and run().


\begin{DoxyCode}
{
  char buf[200], buf_bak[200], buf_mv[500];
  double save_PartAllocFactor, save_TreeAllocFactor;
  int i, nprocgroup, masterTask, groupTask, old_MaxPart, old_MaxNodes;
  struct global_data_all_processes all_task0;


  sprintf(buf, "%s%s.%d", All.OutputDir, All.RestartFile, ThisTask);
  sprintf(buf_bak, "%s%s.%d.bak", All.OutputDir, All.RestartFile, ThisTask);
  sprintf(buf_mv, "mv %s %s", buf, buf_bak);


  if((NTask < All.NumFilesWrittenInParallel))
    {
      printf
        ("Fatal error.\nNumber of processors must be a smaller or equal than
       `NumFilesWrittenInParallel'.\n");
      endrun(2131);
    }

  nprocgroup = NTask / All.NumFilesWrittenInParallel;

  if((NTask % All.NumFilesWrittenInParallel))
    {
      nprocgroup++;
    }

  masterTask = (ThisTask / nprocgroup) * nprocgroup;

  for(groupTask = 0; groupTask < nprocgroup; groupTask++)
    {
      if(ThisTask == (masterTask + groupTask))  /* ok, it's this processor's
       turn */
        {
          if(modus)
            {
              if(!(fd = fopen(buf, "r")))
                {
                  printf("Restart file '%s' not found.\n", buf);
                  endrun(7870);
                }
            }
          else
            {
              system(buf_mv);   /* move old restart files to .bak files */

              if(!(fd = fopen(buf, "w")))
                {
                  printf("Restart file '%s' cannot be opened.\n", buf);
                  endrun(7878);
                }
            }


          save_PartAllocFactor = All.PartAllocFactor;
          save_TreeAllocFactor = All.TreeAllocFactor;

          /* common data  */
          byten(&All, sizeof(struct global_data_all_processes), modus);

          if(ThisTask == 0 && modus > 0)
            all_task0 = All;

          if(modus > 0 && groupTask == 0)       /* read */
            {
              MPI_Bcast(&all_task0, sizeof(struct global_data_all_processes), 
      MPI_BYTE, 0, MPI_COMM_WORLD);
            }

          old_MaxPart = All.MaxPart;
          old_MaxNodes = All.TreeAllocFactor * All.MaxPart;

          if(modus)             /* read */
            {
              if(All.PartAllocFactor != save_PartAllocFactor)
                {
                  All.PartAllocFactor = save_PartAllocFactor;
                  All.MaxPart = All.PartAllocFactor * (All.TotNumPart / NTask);
                  All.MaxPartSph = All.PartAllocFactor * (All.TotN_gas / NTask)
      ;
                  save_PartAllocFactor = -1;
                }

              if(All.TreeAllocFactor != save_TreeAllocFactor)
                {
                  All.TreeAllocFactor = save_TreeAllocFactor;
                  save_TreeAllocFactor = -1;
                }

              if(all_task0.Time != All.Time)
                {
                  printf("The restart file on task=%d is not consistent with
       the one on task=0\n", ThisTask);
                  fflush(stdout);
                  endrun(16);
                }

              allocate_memory();
            }

          in(&NumPart, modus);

          if(NumPart > All.MaxPart)
            {
              printf
                ("it seems you have reduced(!) 'PartAllocFactor' below the
       value of %g needed to load the restart file.\n",
                 NumPart / (((double) All.TotNumPart) / NTask));
              printf("fatal error\n");
              endrun(22);
            }

          /* Particle data  */
          byten(&P[0], NumPart * sizeof(struct particle_data), modus);

          in(&N_gas, modus);

          if(N_gas > 0)
            {
              if(N_gas > All.MaxPartSph)
                {
                  printf
                    ("SPH: it seems you have reduced(!) 'PartAllocFactor' below
       the value of %g needed to load the restart file.\n",
                     N_gas / (((double) All.TotN_gas) / NTask));
                  printf("fatal error\n");
                  endrun(222);
                }
              /* Sph-Particle data  */
              byten(&SphP[0], N_gas * sizeof(struct sph_particle_data), modus);
            }

          /* write state of random number generator */
          byten(gsl_rng_state(random_generator), gsl_rng_size(random_generator)
      , modus);


          /* now store relevant data for tree */

          if(modus)             /* read */
            {
              ngb_treeallocate(MAX_NGB);

              force_treeallocate(All.TreeAllocFactor * All.MaxPart, All.MaxPart
      );
            }


          in(&Numnodestree, modus);

          if(Numnodestree > MaxNodes)
            {
              printf
                ("Tree storage: it seems you have reduced(!) 'PartAllocFactor'
       below the value needed to load the restart file (task=%d). "
                 "Numnodestree=%d  MaxNodes=%d\n", ThisTask, Numnodestree, 
      MaxNodes);
              endrun(221);
            }

          byten(Nodes_base, Numnodestree * sizeof(struct NODE), modus);
          byten(Extnodes_base, Numnodestree * sizeof(struct extNODE), modus);

          byten(Father, NumPart * sizeof(int), modus);

          byten(Nextnode, NumPart * sizeof(int), modus);
          byten(Nextnode + All.MaxPart, MAXTOPNODES * sizeof(int), modus);

          byten(DomainStartList, NTask * sizeof(int), modus);
          byten(DomainEndList, NTask * sizeof(int), modus);
          byten(DomainTask, MAXTOPNODES * sizeof(int), modus);
          byten(DomainNodeIndex, MAXTOPNODES * sizeof(int), modus);
          byten(DomainTreeNodeLen, MAXTOPNODES * sizeof(FLOAT), modus);
          byten(DomainHmax, MAXTOPNODES * sizeof(FLOAT), modus);
          byten(DomainMoment, MAXTOPNODES * sizeof(struct DomainNODE), modus);

          byten(DomainCorner, 3 * sizeof(double), modus);
          byten(DomainCenter, 3 * sizeof(double), modus);
          byten(&DomainLen, sizeof(double), modus);
          byten(&DomainFac, sizeof(double), modus);
          byten(&DomainMyStart, sizeof(int), modus);
          byten(&DomainMyLast, sizeof(int), modus);

          if(modus)             /* read */
            if(All.PartAllocFactor != save_PartAllocFactor || All.
      TreeAllocFactor != save_TreeAllocFactor)
              {
                for(i = 0; i < NumPart; i++)
                  Father[i] += (All.MaxPart - old_MaxPart);

                for(i = 0; i < NumPart; i++)
                  if(Nextnode[i] >= old_MaxPart)
                    {
                      if(Nextnode[i] >= old_MaxPart + old_MaxNodes)
                        Nextnode[i] += (All.MaxPart - old_MaxPart) + (MaxNodes 
      - old_MaxPart);
                      else
                        Nextnode[i] += (All.MaxPart - old_MaxPart);
                    }

                for(i = 0; i < Numnodestree; i++)
                  {
                    if(Nodes_base[i].u.d.sibling >= old_MaxPart)
                      {
                        if(Nodes_base[i].u.d.sibling >= old_MaxPart + 
      old_MaxNodes)
                          Nodes_base[i].u.d.sibling +=
                            (All.MaxPart - old_MaxPart) + (MaxNodes - 
      old_MaxNodes);
                        else
                          Nodes_base[i].u.d.sibling += (All.MaxPart - 
      old_MaxPart);
                      }

                    if(Nodes_base[i].u.d.father >= old_MaxPart)
                      {
                        if(Nodes_base[i].u.d.father >= old_MaxPart + 
      old_MaxNodes)
                          Nodes_base[i].u.d.father += (All.MaxPart - 
      old_MaxPart) + (MaxNodes - old_MaxNodes);
                        else
                          Nodes_base[i].u.d.father += (All.MaxPart - 
      old_MaxPart);
                      }

                    if(Nodes_base[i].u.d.nextnode >= old_MaxPart)
                      {
                        if(Nodes_base[i].u.d.nextnode >= old_MaxPart + 
      old_MaxNodes)
                          Nodes_base[i].u.d.nextnode +=
                            (All.MaxPart - old_MaxPart) + (MaxNodes - 
      old_MaxNodes);
                        else
                          Nodes_base[i].u.d.nextnode += (All.MaxPart - 
      old_MaxPart);
                      }
                  }

                for(i = 0; i < MAXTOPNODES; i++)
                  if(Nextnode[i + All.MaxPart] >= old_MaxPart)
                    {
                      if(Nextnode[i + All.MaxPart] >= old_MaxPart + 
      old_MaxNodes)
                        Nextnode[i + All.MaxPart] += (All.MaxPart - old_MaxPart
      ) + (MaxNodes - old_MaxNodes);
                      else
                        Nextnode[i + All.MaxPart] += (All.MaxPart - old_MaxPart
      );
                    }

                for(i = 0; i < MAXTOPNODES; i++)
                  if(DomainNodeIndex[i] >= old_MaxPart)
                    {
                      if(DomainNodeIndex[i] >= old_MaxPart + old_MaxNodes)
                        DomainNodeIndex[i] += (All.MaxPart - old_MaxPart) + (
      MaxNodes - old_MaxNodes);
                      else
                        DomainNodeIndex[i] += (All.MaxPart - old_MaxPart);
                    }
              }

          fclose(fd);
        }
      else                      /* wait inside the group */
        {
          if(modus > 0 && groupTask == 0)       /* read */
            {
              MPI_Bcast(&all_task0, sizeof(struct global_data_all_processes), 
      MPI_BYTE, 0, MPI_COMM_WORLD);
            }
        }

      MPI_Barrier(MPI_COMM_WORLD);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=294pt]{proto_8h_af3e3dd8294f983f9ed9f75c81d149ec9_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2}{\index{proto.\-h@{proto.\-h}!run@{run}}
\index{run@{run}!proto.h@{proto.\-h}}
\subsubsection[{run}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf run} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2}
\-This routine contains the main simulation loop that iterates over single timesteps. \-The loop terminates when the cpu-\/time limit is reached, when a `stop' file is found in the output directory, or when the simulation ends because we arrived at \-Time\-Max. $<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29 

\-Definition at line 20 of file run.\-c.



\-References advance\-\_\-and\-\_\-find\-\_\-timesteps(), \-All, close\-\_\-outputfiles(), compute\-\_\-accelerations(), compute\-\_\-potential(), \-C\-P\-U\-This\-Run, domain\-\_\-\-Decomposition(), energy\-\_\-statistics(), every\-\_\-timestep\-\_\-stuff(), fd, find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift(), restart(), savepositions(), second(), \-This\-Task, and timediff().



\-Referenced by main().


\begin{DoxyCode}
{
  FILE *fd;
  int stopflag = 0;
  char stopfname[200], contfname[200];
  double t0, t1;


  sprintf(stopfname, "%sstop", All.OutputDir);
  sprintf(contfname, "%scont", All.OutputDir);
  unlink(contfname);

  do                            /* main loop */
    {
      t0 = second();

      find_next_sync_point_and_drift(); /* find next synchronization point and
       drift particles to this time.
                                         * If needed, this function will also
       write an output file
                                         * at the desired time.
                                         */

      every_timestep_stuff();   /* write some info to log-files */


      domain_Decomposition();   /* do domain decomposition if needed */


      compute_accelerations(0); /* compute accelerations for 
                                 * the particles that are to be advanced  
                                 */

      /* check whether we want a full energy statistics */
      if((All.Time - All.TimeLastStatistics) >= All.TimeBetStatistics)
        {
#ifdef COMPUTE_POTENTIAL_ENERGY
          compute_potential();
#endif
          energy_statistics();  /* compute and output energy statistics */
          All.TimeLastStatistics += All.TimeBetStatistics;
        }

      advance_and_find_timesteps();     /* 'kick' active particles in
                                         * momentum space and compute new
                                         * timesteps for them
                                         */
      All.NumCurrentTiStep++;

      /* Check whether we need to interrupt the run */
      if(ThisTask == 0)
        {
          /* Is the stop-file present? If yes, interrupt the run. */
          if((fd = fopen(stopfname, "r")))
            {
              fclose(fd);
              stopflag = 1;
              unlink(stopfname);
            }

          /* are we running out of CPU-time ? If yes, interrupt run. */
          if(CPUThisRun > 0.85 * All.TimeLimitCPU)
            {
              printf("reaching time-limit. stopping.\n");
              stopflag = 2;
            }
        }

      MPI_Bcast(&stopflag, 1, MPI_INT, 0, MPI_COMM_WORLD);

      if(stopflag)
        {
          restart(0);           /* write restart file */
          MPI_Barrier(MPI_COMM_WORLD);

          if(stopflag == 2 && ThisTask == 0)
            {
              if((fd = fopen(contfname, "w")))
                fclose(fd);
            }

          if(stopflag == 2 && All.ResubmitOn && ThisTask == 0)
            {
              close_outputfiles();
              system(All.ResubmitCommand);
            }
          return;
        }

      /* is it time to write a regular restart-file? (for security) */
      if(ThisTask == 0)
        {
          if((CPUThisRun - All.TimeLastRestartFile) >= All.
      CpuTimeBetRestartFile)
            {
              All.TimeLastRestartFile = CPUThisRun;
              stopflag = 3;
            }
          else
            stopflag = 0;
        }

      MPI_Bcast(&stopflag, 1, MPI_INT, 0, MPI_COMM_WORLD);

      if(stopflag == 3)
        {
          restart(0);           /* write an occasional restart file */
          stopflag = 0;
        }

      t1 = second();

      All.CPU_Total += timediff(t0, t1);
      CPUThisRun += timediff(t0, t1);
    }
  while(All.Ti_Current < TIMEBASE && All.Time <= All.TimeMax);

  restart(0);

  savepositions(All.SnapshotFileCount++);       /* write a last snapshot
                                                 * file at final time (will
                                                 * be overwritten if
                                                 * All.TimeMax is increased
                                                 * and the run is continued)
                                                 */
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=190pt]{proto_8h_a05e0ffe612d44e6d7f3a9ae5b9df56a2_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a523730833804b6d92aa7f4dd474805c5}{\index{proto.\-h@{proto.\-h}!savepositions@{savepositions}}
\index{savepositions@{savepositions}!proto.h@{proto.\-h}}
\subsubsection[{savepositions}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf savepositions} (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)}}\label{proto_8h_a523730833804b6d92aa7f4dd474805c5}
\-This function writes a snapshot of the particle distribution to one or several files using the selected file format. \-If \-Num\-Files\-Per\-Snapshot$>$1, the snapshot is distributed onto several files, several of them can be written simultaneously (up to \-Num\-Files\-Written\-In\-Parallel). \-Each file contains data from a group of processors. 

\-Definition at line 33 of file io.\-c.



\-References \-All, distribute\-\_\-file(), endrun(), fill\-\_\-\-Tab\-\_\-\-I\-O\-\_\-\-Labels(), n\-\_\-type, \-N\-Task, ntot\-\_\-type\-\_\-all, \-Num\-Part, \-P, second(), \-This\-Task, timediff(), and write\-\_\-file().



\-Referenced by find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift(), and run().


\begin{DoxyCode}
{
  double t0, t1;
  char buf[500];
  int i, j, *temp, n, filenr, gr, ngroups, masterTask, lastTask;

  t0 = second();

  if(ThisTask == 0)
    printf("\nwriting snapshot file... \n");

#if defined(SFR) || defined(BLACK_HOLES)
  rearrange_particle_sequence();
  /* ensures that new tree will be constructed */
  All.NumForcesSinceLastDomainDecomp = 1 + All.TreeDomainUpdateFrequency * All.
      TotNumPart;
#endif

  if(NTask < All.NumFilesPerSnapshot)
    {
      if(ThisTask == 0)
        printf("Fatal error.\nNumber of processors must be larger or equal than
       All.NumFilesPerSnapshot.\n");
      endrun(0);
    }
  if(All.SnapFormat < 1 || All.SnapFormat > 3)
    {
      if(ThisTask == 0)
        printf("Unsupported File-Format\n");
      endrun(0);
    }
#ifndef  HAVE_HDF5
  if(All.SnapFormat == 3)
    {
      if(ThisTask == 0)
        printf("Code wasn't compiled with HDF5 support enabled!\n");
      endrun(0);
    }
#endif


  /* determine global and local particle numbers */
  for(n = 0; n < 6; n++)
    n_type[n] = 0;

  for(n = 0; n < NumPart; n++)
    n_type[P[n].Type]++;

  /* because ntot_type_all[] is of type `long long', we cannot do a simple
   * MPI_Allreduce() to sum the total particle numbers 
   */
  temp = malloc(NTask * 6 * sizeof(int));
  MPI_Allgather(n_type, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
  for(i = 0; i < 6; i++)
    {
      ntot_type_all[i] = 0;
      for(j = 0; j < NTask; j++)
        ntot_type_all[i] += temp[j * 6 + i];
    }
  free(temp);


  /* assign processors to output files */
  distribute_file(All.NumFilesPerSnapshot, 0, 0, NTask - 1, &filenr, &
      masterTask, &lastTask);

  fill_Tab_IO_Labels();

  if(All.NumFilesPerSnapshot > 1)
    sprintf(buf, "%s%s_%03d.%d", All.OutputDir, All.SnapshotFileBase, num, 
      filenr);
  else
    sprintf(buf, "%s%s_%03d", All.OutputDir, All.SnapshotFileBase, num);

  ngroups = All.NumFilesPerSnapshot / All.NumFilesWrittenInParallel;
  if((All.NumFilesPerSnapshot % All.NumFilesWrittenInParallel))
    ngroups++;

  for(gr = 0; gr < ngroups; gr++)
    {
      if((filenr / All.NumFilesWrittenInParallel) == gr)        /* ok, it's
       this processor's turn */
        write_file(buf, masterTask, lastTask);
      MPI_Barrier(MPI_COMM_WORLD);
    }


  if(ThisTask == 0)
    printf("done with snapshot.\n");

  t1 = second();

  All.CPU_Snapshot += timediff(t0, t1);

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a523730833804b6d92aa7f4dd474805c5_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a523730833804b6d92aa7f4dd474805c5_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad24c35a2016ce428248988795c1d3174}{\index{proto.\-h@{proto.\-h}!second@{second}}
\index{second@{second}!proto.h@{proto.\-h}}
\subsubsection[{second}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf second} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad24c35a2016ce428248988795c1d3174}
returns the number of cpu-\/ticks in seconds that have elapsed, or the wall-\/clock time obtained with \-M\-P\-I\-\_\-\-Wtime(). 

\-Definition at line 49 of file system.\-c.



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps(), compute\-\_\-accelerations(), compute\-\_\-potential(), density(), domain\-\_\-\-Decomposition(), find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift(), gravity\-\_\-forcetest(), gravity\-\_\-tree(), hydro\-\_\-force(), main(), move\-\_\-particles(), run(), and savepositions().


\begin{DoxyCode}
{
#ifdef WALLCLOCK
  return MPI_Wtime();
#else
  return ((double) clock()) / CLOCKS_PER_SEC;
#endif
  
  /* note: on AIX and presumably many other 32bit systems, 
   * clock() has only a resolution of 10ms=0.01sec 
   */
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad24c35a2016ce428248988795c1d3174_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135}{\index{proto.\-h@{proto.\-h}!seed\-\_\-glass@{seed\-\_\-glass}}
\index{seed\-\_\-glass@{seed\-\_\-glass}!proto.h@{proto.\-h}}
\subsubsection[{seed\-\_\-glass}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf seed\-\_\-glass} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135}


\-Referenced by init().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aeb05544fcefa17dff1e34bf3c65a0135_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a9cb45ef22cae101906f021fb7a23afbe}{\index{proto.\-h@{proto.\-h}!set\-\_\-random\-\_\-numbers@{set\-\_\-random\-\_\-numbers}}
\index{set\-\_\-random\-\_\-numbers@{set\-\_\-random\-\_\-numbers}!proto.h@{proto.\-h}}
\subsubsection[{set\-\_\-random\-\_\-numbers}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf set\-\_\-random\-\_\-numbers} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a9cb45ef22cae101906f021fb7a23afbe}
\-This routine fills the random number table. $<$ gives the length of a table with random numbers, refreshed at every timestep. \-This is used to allow application of random numbers to a specific particle in a way that is independent of the number of processors used. 

\-Definition at line 37 of file system.\-c.



\-References random\-\_\-generator, and \-Rnd\-Table.



\-Referenced by begrun(), and every\-\_\-timestep\-\_\-stuff().


\begin{DoxyCode}
{
  int i;

  for(i = 0; i < RNDTABLE; i++)
    RndTable[i] = gsl_rng_uniform(random_generator);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a9cb45ef22cae101906f021fb7a23afbe_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91}{\index{proto.\-h@{proto.\-h}!set\-\_\-softenings@{set\-\_\-softenings}}
\index{set\-\_\-softenings@{set\-\_\-softenings}!proto.h@{proto.\-h}}
\subsubsection[{set\-\_\-softenings}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf set\-\_\-softenings} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91}
\-This function sets the (comoving) softening length of all particle types in the table \-All.\-Softening\-Table\mbox{[}...\mbox{]}. \-We check that the physical softening length is bounded by the \-Softening-\/\-Max\-Phys values. 

\-Definition at line 494 of file gravtree.\-c.



\-References \-All.



\-Referenced by compute\-\_\-potential(), gravity\-\_\-forcetest(), gravity\-\_\-tree(), and init().


\begin{DoxyCode}
{
  int i;

  if(All.ComovingIntegrationOn)
    {
      if(All.SofteningGas * All.Time > All.SofteningGasMaxPhys)
        All.SofteningTable[0] = All.SofteningGasMaxPhys / All.Time;
      else
        All.SofteningTable[0] = All.SofteningGas;
      
      if(All.SofteningHalo * All.Time > All.SofteningHaloMaxPhys)
        All.SofteningTable[1] = All.SofteningHaloMaxPhys / All.Time;
      else
        All.SofteningTable[1] = All.SofteningHalo;
      
      if(All.SofteningDisk * All.Time > All.SofteningDiskMaxPhys)
        All.SofteningTable[2] = All.SofteningDiskMaxPhys / All.Time;
      else
        All.SofteningTable[2] = All.SofteningDisk;
      
      if(All.SofteningBulge * All.Time > All.SofteningBulgeMaxPhys)
        All.SofteningTable[3] = All.SofteningBulgeMaxPhys / All.Time;
      else
        All.SofteningTable[3] = All.SofteningBulge;
      
      if(All.SofteningStars * All.Time > All.SofteningStarsMaxPhys)
        All.SofteningTable[4] = All.SofteningStarsMaxPhys / All.Time;
      else
        All.SofteningTable[4] = All.SofteningStars;
      
      if(All.SofteningBndry * All.Time > All.SofteningBndryMaxPhys)
        All.SofteningTable[5] = All.SofteningBndryMaxPhys / All.Time;
      else
        All.SofteningTable[5] = All.SofteningBndry;
    }
  else
    {
      All.SofteningTable[0] = All.SofteningGas;
      All.SofteningTable[1] = All.SofteningHalo;
      All.SofteningTable[2] = All.SofteningDisk;
      All.SofteningTable[3] = All.SofteningBulge;
      All.SofteningTable[4] = All.SofteningStars;
      All.SofteningTable[5] = All.SofteningBndry;
    }

  for(i = 0; i < 6; i++)
    All.ForceSoftening[i] = 2.8 * All.SofteningTable[i];

  All.MinGasHsml = All.MinGasHsmlFractional * All.ForceSoftening[0];
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_aab39b7857a85e95ef6f926ac82d4ff91_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_aba986f6be1d66945199c7ea43e5c9610}{\index{proto.\-h@{proto.\-h}!set\-\_\-units@{set\-\_\-units}}
\index{set\-\_\-units@{set\-\_\-units}!proto.h@{proto.\-h}}
\subsubsection[{set\-\_\-units}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf set\-\_\-units} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_aba986f6be1d66945199c7ea43e5c9610}
\-Computes conversion factors between internal code units and the cgs-\/system. $<$ \-Gravitational constant (in cgs units)

$<$ mass fraction of hydrogen, relevant only for radiative cooling

$<$ adiabatic index of simulated gas 

\-Definition at line 157 of file begrun.\-c.



\-References \-All, pow(), and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  double meanweight;

  All.UnitTime_in_s = All.UnitLength_in_cm / All.UnitVelocity_in_cm_per_s;
  All.UnitTime_in_Megayears = All.UnitTime_in_s / SEC_PER_MEGAYEAR;

  if(All.GravityConstantInternal == 0)
    All.G = GRAVITY / pow(All.UnitLength_in_cm, 3) * All.UnitMass_in_g * pow(All
      .UnitTime_in_s, 2);
  else
    All.G = All.GravityConstantInternal;

  All.UnitDensity_in_cgs = All.UnitMass_in_g / pow(All.UnitLength_in_cm, 3);
  All.UnitPressure_in_cgs = All.UnitMass_in_g / All.UnitLength_in_cm / pow(All.
      UnitTime_in_s, 2);
  All.UnitCoolingRate_in_cgs = All.UnitPressure_in_cgs / All.UnitTime_in_s;
  All.UnitEnergy_in_cgs = All.UnitMass_in_g * pow(All.UnitLength_in_cm, 2) / pow
      (All.UnitTime_in_s, 2);

  /* convert some physical input parameters to internal units */

  All.Hubble = HUBBLE * All.UnitTime_in_s;

  if(ThisTask == 0)
    {
      printf("\nHubble (internal units) = %g\n", All.Hubble);
      printf("G (internal units) = %g\n", All.G);
      printf("UnitMass_in_g = %g \n", All.UnitMass_in_g);
      printf("UnitTime_in_s = %g \n", All.UnitTime_in_s);
      printf("UnitVelocity_in_cm_per_s = %g \n", All.UnitVelocity_in_cm_per_s);
      printf("UnitDensity_in_cgs = %g \n", All.UnitDensity_in_cgs);
      printf("UnitEnergy_in_cgs = %g \n", All.UnitEnergy_in_cgs);
      printf("\n");
    }

  meanweight = 4.0 / (1 + 3 * HYDROGEN_MASSFRAC);       /* note: we assume
       neutral gas here */

#ifdef ISOTHERM_EQS
  All.MinEgySpec = 0;
#else
  All.MinEgySpec = 1 / meanweight * (1.0 / GAMMA_MINUS1) * (BOLTZMANN / 
      PROTONMASS) * All.MinGasTemp;
  All.MinEgySpec *= All.UnitMass_in_g / All.UnitEnergy_in_cgs;
#endif

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{proto_8h_aba986f6be1d66945199c7ea43e5c9610_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=304pt]{proto_8h_aba986f6be1d66945199c7ea43e5c9610_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_abca44f066552d38c44a1cd6020d349d5}{\index{proto.\-h@{proto.\-h}!setup\-\_\-smoothinglengths@{setup\-\_\-smoothinglengths}}
\index{setup\-\_\-smoothinglengths@{setup\-\_\-smoothinglengths}!proto.h@{proto.\-h}}
\subsubsection[{setup\-\_\-smoothinglengths}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf setup\-\_\-smoothinglengths} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_abca44f066552d38c44a1cd6020d349d5}
\-This function is used to find an initial smoothing length for each \-S\-P\-H particle. \-It guarantees that the number of neighbours will be between desired\-\_\-ngb-\/\-M\-A\-X\-D\-E\-V and desired\-\_\-ngb+\-M\-A\-X\-D\-E\-V. \-For simplicity, a first guess of the smoothing length is provided to the function \hyperlink{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density()}, which will then iterate if needed to find the right smoothing length. 

\-Definition at line 199 of file init.\-c.



\-References \-All, density(), \-Father, \-N\-\_\-gas, \-Nodes, \-P, pow(), \-Restart\-Flag, and \-Sph\-P.



\-Referenced by init().


\begin{DoxyCode}
{
  int i, no, p;

  if(RestartFlag == 0)
    {

      for(i = 0; i < N_gas; i++)
        {
          no = Father[i];

          while(10 * All.DesNumNgb * P[i].Mass > Nodes[no].u.d.mass)
            {
              p = Nodes[no].u.d.father;

              if(p < 0)
                break;

              no = p;
            }
#ifndef TWODIMS
          SphP[i].Hsml =
            pow(3.0 / (4 * M_PI) * All.DesNumNgb * P[i].Mass / Nodes[no].u.d.
      mass, 1.0 / 3) * Nodes[no].len;
#else
          SphP[i].Hsml =
            pow(1.0 / (M_PI) * All.DesNumNgb * P[i].Mass / Nodes[no].u.d.mass, 
      1.0 / 2) * Nodes[no].len;
#endif
        }
    }

  density();
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_abca44f066552d38c44a1cd6020d349d5_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_abca44f066552d38c44a1cd6020d349d5_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad47ac005519641e0cfc423c3802d3ef2}{\index{proto.\-h@{proto.\-h}!statistics@{statistics}}
\index{statistics@{statistics}!proto.h@{proto.\-h}}
\subsubsection[{statistics}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf statistics} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad47ac005519641e0cfc423c3802d3ef2}
\hypertarget{proto_8h_a869daac8b2af5667db265026f09fb9d8}{\index{proto.\-h@{proto.\-h}!terminate\-\_\-processes@{terminate\-\_\-processes}}
\index{terminate\-\_\-processes@{terminate\-\_\-processes}!proto.h@{proto.\-h}}
\subsubsection[{terminate\-\_\-processes}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf terminate\-\_\-processes} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a869daac8b2af5667db265026f09fb9d8}


\-Referenced by endrun().



\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a869daac8b2af5667db265026f09fb9d8_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a890645bdc4536bd797ca53028072e30d}{\index{proto.\-h@{proto.\-h}!timediff@{timediff}}
\index{timediff@{timediff}!proto.h@{proto.\-h}}
\subsubsection[{timediff}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf timediff} (
\begin{DoxyParamCaption}
\item[{double}]{t0, }
\item[{double}]{t1}
\end{DoxyParamCaption}
)}}\label{proto_8h_a890645bdc4536bd797ca53028072e30d}
returns the time difference between two measurements obtained with \hyperlink{proto_8h_ad24c35a2016ce428248988795c1d3174}{second()}. \-The routine takes care of the possible overflow of the tick counter on 32bit systems, but depending on the system, this may not always work properly. \-Similarly, in some \-M\-P\-I implementations, the \-M\-P\-I\-\_\-\-Wtime() function may also overflow, in which case a negative time difference would be returned. \-The routine returns instead a time difference equal to 0. 

\-Definition at line 70 of file system.\-c.



\-References pow().



\-Referenced by advance\-\_\-and\-\_\-find\-\_\-timesteps(), compute\-\_\-accelerations(), compute\-\_\-potential(), density(), domain\-\_\-\-Decomposition(), find\-\_\-next\-\_\-sync\-\_\-point\-\_\-and\-\_\-drift(), gravity\-\_\-forcetest(), gravity\-\_\-tree(), hydro\-\_\-force(), main(), move\-\_\-particles(), run(), and savepositions().


\begin{DoxyCode}
{
  double dt;

  dt = t1 - t0;

  if(dt < 0)    /* overflow has occured (for systems with 32bit tick counter) 
      */
    {
#ifdef WALLCLOCK
      dt = 0;
#else
      dt = t1 + pow(2, 32) / CLOCKS_PER_SEC - t0;
#endif
    }

  return dt;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{proto_8h_a890645bdc4536bd797ca53028072e30d_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a890645bdc4536bd797ca53028072e30d_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a48b0ed3a843924501df8ed871e08e77c}{\index{proto.\-h@{proto.\-h}!write\-\_\-file@{write\-\_\-file}}
\index{write\-\_\-file@{write\-\_\-file}!proto.h@{proto.\-h}}
\subsubsection[{write\-\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf write\-\_\-file} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname, }
\item[{int}]{write\-Task, }
\item[{int}]{last\-Task}
\end{DoxyParamCaption}
)}}\label{proto_8h_a48b0ed3a843924501df8ed871e08e77c}
\-This function writes an actual snapshot file containing the data from processors 'write\-Task' to 'last\-Task'. 'write\-Task' is the one that actually writes. \-Each snapshot file contains a header first, then particle positions, velocities and \-I\-D's. \-Particle masses are written only for those particle types with zero entry in \-Mass\-Table. \-After that, first the internal energies u, and then the density is written for the \-S\-P\-H particles. \-If cooling is enabled, mean molecular weight and neutral hydrogen abundance are written for the gas particles. \-This is followed by the \-S\-P\-H smoothing length and further blocks of information, depending on included physics and compile-\/time flags. \-If \-H\-D\-F5 is used, the header is stored in a group called \char`\"{}/\-Header\char`\"{}, and the particle data is stored separately for each particle type in groups calles \char`\"{}/\-Part\-Type0\char`\"{}, \char`\"{}/\-Part\-Type1\char`\"{}, etc. \-The sequence of the blocks is unimportant in this case. $<$ \-Various tags used for labelling \-M\-P\-I messages

$<$ \-Various tags used for labelling \-M\-P\-I messages

$<$ total number of defined information blocks for snapshot files. \-Must be equal to the number of entries in \char`\"{}enum iofields\char`\"{} 

\-Definition at line 672 of file io.\-c.



\-References \-All, blockpresent(), \-Comm\-Buffer, endrun(), fd, fill\-\_\-write\-\_\-buffer(), get\-\_\-bytes\-\_\-per\-\_\-blockelement(), get\-\_\-dataset\-\_\-name(), get\-\_\-datatype\-\_\-in\-\_\-block(), get\-\_\-particles\-\_\-in\-\_\-block(), get\-\_\-values\-\_\-per\-\_\-blockelement(), header, my\-\_\-fwrite(), n\-\_\-type, ntot\-\_\-type\-\_\-all, \-S\-K\-I\-P, \-Tab\-\_\-\-I\-O\-\_\-\-Labels, \-T\-A\-G\-\_\-\-L\-O\-C\-A\-L\-N, \-T\-A\-G\-\_\-\-N, \-T\-A\-G\-\_\-\-N\-F\-O\-R\-T\-H\-I\-S\-T\-A\-S\-K, \-T\-A\-G\-\_\-\-P\-D\-A\-T\-A, \-This\-Task, and write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5().



\-Referenced by savepositions().


\begin{DoxyCode}
{
  int type, bytes_per_blockelement, npart, nextblock, typelist[6];
  int n_for_this_task, ntask, n, p, pc, offset = 0, task;
  int blockmaxlen, ntot_type[6], nn[6];
  enum iofields blocknr;
  int blksize;
  MPI_Status status;
  FILE *fd = 0;

#ifdef HAVE_HDF5
  hid_t hdf5_file = 0, hdf5_grp[6], hdf5_headergrp = 0, hdf5_dataspace_memory;
  hid_t hdf5_datatype = 0, hdf5_dataspace_in_file = 0, hdf5_dataset = 0;
  herr_t hdf5_status;
  hsize_t dims[2], count[2], start[2];
  int rank, pcsum = 0;
  char buf[500];
#endif

#define SKIP  {my_fwrite(&blksize,sizeof(int),1,fd);}

  /* determine particle numbers of each type in file */

  if(ThisTask == writeTask)
    {
      for(n = 0; n < 6; n++)
        ntot_type[n] = n_type[n];

      for(task = writeTask + 1; task <= lastTask; task++)
        {
          MPI_Recv(&nn[0], 6, MPI_INT, task, TAG_LOCALN, MPI_COMM_WORLD, &
      status);
          for(n = 0; n < 6; n++)
            ntot_type[n] += nn[n];
        }

      for(task = writeTask + 1; task <= lastTask; task++)
        MPI_Send(&ntot_type[0], 6, MPI_INT, task, TAG_N, MPI_COMM_WORLD);
    }
  else
    {
      MPI_Send(&n_type[0], 6, MPI_INT, writeTask, TAG_LOCALN, MPI_COMM_WORLD);
      MPI_Recv(&ntot_type[0], 6, MPI_INT, writeTask, TAG_N, MPI_COMM_WORLD, &
      status);
    }



  /* fill file header */

  for(n = 0; n < 6; n++)
    {
      header.npart[n] = ntot_type[n];
      header.npartTotal[n] = (unsigned int) ntot_type_all[n];
      header.npartTotalHighWord[n] = (unsigned int) (ntot_type_all[n] >> 32);
    }

  for(n = 0; n < 6; n++)
    header.mass[n] = All.MassTable[n];

  header.time = All.Time;

  if(All.ComovingIntegrationOn)
    header.redshift = 1.0 / All.Time - 1;
  else
    header.redshift = 0;

  header.flag_sfr = 0;
  header.flag_feedback = 0;
  header.flag_cooling = 0;
  header.flag_stellarage = 0;
  header.flag_metals = 0;

#ifdef COOLING
  header.flag_cooling = 1;
#endif
#ifdef SFR
  header.flag_sfr = 1;
  header.flag_feedback = 1;
#ifdef STELLARAGE
  header.flag_stellarage = 1;
#endif
#ifdef METALS
  header.flag_metals = 1;
#endif
#endif

  header.num_files = All.NumFilesPerSnapshot;
  header.BoxSize = All.BoxSize;
  header.Omega0 = All.Omega0;
  header.OmegaLambda = All.OmegaLambda;
  header.HubbleParam = All.HubbleParam;


  /* open file and write header */

  if(ThisTask == writeTask)
    {
      if(All.SnapFormat == 3)
        {
#ifdef HAVE_HDF5
          sprintf(buf, "%s.hdf5", fname);
          hdf5_file = H5Fcreate(buf, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);

          hdf5_headergrp = H5Gcreate(hdf5_file, "/Header", 0);

          for(type = 0; type < 6; type++)
            {
              if(header.npart[type] > 0)
                {
                  sprintf(buf, "/PartType%d", type);
                  hdf5_grp[type] = H5Gcreate(hdf5_file, buf, 0);
                }
            }

          write_header_attributes_in_hdf5(hdf5_headergrp);
#endif
        }
      else
        {
          if(!(fd = fopen(fname, "w")))
            {
              printf("can't open file `%s' for writing snapshot.\n", fname);
              endrun(123);
            }

          if(All.SnapFormat == 2)
            {
              blksize = sizeof(int) + 4 * sizeof(char);
              SKIP;
              my_fwrite("HEAD", sizeof(char), 4, fd);
              nextblock = sizeof(header) + 2 * sizeof(int);
              my_fwrite(&nextblock, sizeof(int), 1, fd);
              SKIP;
            }

          blksize = sizeof(header);
          SKIP;
          my_fwrite(&header, sizeof(header), 1, fd);
          SKIP;
        }
    }

  ntask = lastTask - writeTask + 1;

  for(blocknr = 0; blocknr < IO_NBLOCKS; blocknr++)
    {
      if(blockpresent(blocknr))
        {
          bytes_per_blockelement = get_bytes_per_blockelement(blocknr);

          blockmaxlen = ((int) (All.BufferSize * 1024 * 1024)) / 
      bytes_per_blockelement;

          npart = get_particles_in_block(blocknr, &typelist[0]);

          if(npart > 0)
            {
              if(ThisTask == writeTask)
                {

                  if(All.SnapFormat == 1 || All.SnapFormat == 2)
                    {
                      if(All.SnapFormat == 2)
                        {
                          blksize = sizeof(int) + 4 * sizeof(char);
                          SKIP;
                          my_fwrite(Tab_IO_Labels[blocknr], sizeof(char), 4, fd
      );
                          nextblock = npart * bytes_per_blockelement + 2 * 
      sizeof(int);
                          my_fwrite(&nextblock, sizeof(int), 1, fd);
                          SKIP;
                        }

                      blksize = npart * bytes_per_blockelement;
                      SKIP;

                    }
                }

              for(type = 0; type < 6; type++)
                {
                  if(typelist[type])
                    {
#ifdef HAVE_HDF5
                      if(ThisTask == writeTask && All.SnapFormat == 3 && header
      .npart[type] > 0)
                        {
                          switch (get_datatype_in_block(blocknr))
                            {
                            case 0:
                              hdf5_datatype = H5Tcopy(H5T_NATIVE_UINT);
                              break;
                            case 1:
                              hdf5_datatype = H5Tcopy(H5T_NATIVE_FLOAT);
                              break;
                            case 2:
                              hdf5_datatype = H5Tcopy(H5T_NATIVE_UINT64);
                              break;
                            }

                          dims[0] = header.npart[type];
                          dims[1] = get_values_per_blockelement(blocknr);
                          if(dims[1] == 1)
                            rank = 1;
                          else
                            rank = 2;

                          get_dataset_name(blocknr, buf);

                          hdf5_dataspace_in_file = H5Screate_simple(rank, dims,
       NULL);
                          hdf5_dataset =
                            H5Dcreate(hdf5_grp[type], buf, hdf5_datatype, 
      hdf5_dataspace_in_file,
                                      H5P_DEFAULT);
                          pcsum = 0;
                        }
#endif

                      for(task = writeTask, offset = 0; task <= lastTask; task+
      +)
                        {
                          if(task == ThisTask)
                            {
                              n_for_this_task = n_type[type];

                              for(p = writeTask; p <= lastTask; p++)
                                if(p != ThisTask)
                                  MPI_Send(&n_for_this_task, 1, MPI_INT, p, 
      TAG_NFORTHISTASK, MPI_COMM_WORLD);
                            }
                          else
                            MPI_Recv(&n_for_this_task, 1, MPI_INT, task, 
      TAG_NFORTHISTASK, MPI_COMM_WORLD,
                                     &status);

                          while(n_for_this_task > 0)
                            {
                              pc = n_for_this_task;

                              if(pc > blockmaxlen)
                                pc = blockmaxlen;

                              if(ThisTask == task)
                                fill_write_buffer(blocknr, &offset, pc, type);

                              if(ThisTask == writeTask && task != writeTask)
                                MPI_Recv(CommBuffer, bytes_per_blockelement * 
      pc, MPI_BYTE, task,
                                         TAG_PDATA, MPI_COMM_WORLD, &status);

                              if(ThisTask != writeTask && task == ThisTask)
                                MPI_Ssend(CommBuffer, bytes_per_blockelement * 
      pc, MPI_BYTE, writeTask,
                                          TAG_PDATA, MPI_COMM_WORLD);

                              if(ThisTask == writeTask)
                                {
                                  if(All.SnapFormat == 3)
                                    {
#ifdef HAVE_HDF5
                                      start[0] = pcsum;
                                      start[1] = 0;

                                      count[0] = pc;
                                      count[1] = get_values_per_blockelement(
      blocknr);
                                      pcsum += pc;

                                      H5Sselect_hyperslab(
      hdf5_dataspace_in_file, H5S_SELECT_SET,
                                                          start, NULL, count, 
      NULL);

                                      dims[0] = pc;
                                      dims[1] = get_values_per_blockelement(
      blocknr);
                                      hdf5_dataspace_memory = H5Screate_simple(
      rank, dims, NULL);

                                      hdf5_status =
                                        H5Dwrite(hdf5_dataset, hdf5_datatype, 
      hdf5_dataspace_memory,
                                                 hdf5_dataspace_in_file, 
      H5P_DEFAULT, CommBuffer);

                                      H5Sclose(hdf5_dataspace_memory);
#endif
                                    }
                                  else
                                    my_fwrite(CommBuffer, 
      bytes_per_blockelement, pc, fd);
                                }

                              n_for_this_task -= pc;
                            }
                        }

#ifdef HAVE_HDF5
                      if(ThisTask == writeTask && All.SnapFormat == 3 && header
      .npart[type] > 0)
                        {
                          if(All.SnapFormat == 3)
                            {
                              H5Dclose(hdf5_dataset);
                              H5Sclose(hdf5_dataspace_in_file);
                              H5Tclose(hdf5_datatype);
                            }
                        }
#endif
                    }
                }

              if(ThisTask == writeTask)
                {
                  if(All.SnapFormat == 1 || All.SnapFormat == 2)
                    SKIP;
                }
            }
        }
    }

  if(ThisTask == writeTask)
    {
      if(All.SnapFormat == 3)
        {
#ifdef HAVE_HDF5
          for(type = 5; type >= 0; type--)
            if(header.npart[type] > 0)
              H5Gclose(hdf5_grp[type]);
          H5Gclose(hdf5_headergrp);
          H5Fclose(hdf5_file);
#endif
        }
      else
        fclose(fd);
    }
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a48b0ed3a843924501df8ed871e08e77c_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_a48b0ed3a843924501df8ed871e08e77c_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf}{\index{proto.\-h@{proto.\-h}!write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5@{write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5}}
\index{write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5@{write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5}!proto.h@{proto.\-h}}
\subsubsection[{write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf write\-\_\-header\-\_\-attributes\-\_\-in\-\_\-hdf5} (
\begin{DoxyParamCaption}
\item[{hid\-\_\-t}]{handle}
\end{DoxyParamCaption}
)}}\label{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf}
\-This function writes the header information in case \-H\-D\-F5 is selected as file format. 

\-Definition at line 998 of file io.\-c.



\-References header.



\-Referenced by write\-\_\-file().


\begin{DoxyCode}
{
  hsize_t adim[1] = { 6 };
  hid_t hdf5_dataspace, hdf5_attribute;

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "NumPart_ThisFile", H5T_NATIVE_INT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, header.npart);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "NumPart_Total", H5T_NATIVE_UINT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotal);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "NumPart_Total_HW", H5T_NATIVE_UINT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, header.npartTotalHighWord);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);


  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "MassTable", H5T_NATIVE_DOUBLE, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, header.mass);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Time", H5T_NATIVE_DOUBLE, hdf5_dataspace,
       H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.time);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Redshift", H5T_NATIVE_DOUBLE, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.redshift);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "BoxSize", H5T_NATIVE_DOUBLE, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.BoxSize);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "NumFilesPerSnapshot", H5T_NATIVE_INT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.num_files);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Omega0", H5T_NATIVE_DOUBLE, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.Omega0);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "OmegaLambda", H5T_NATIVE_DOUBLE, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.OmegaLambda);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "HubbleParam", H5T_NATIVE_DOUBLE, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_DOUBLE, &header.HubbleParam);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Sfr", H5T_NATIVE_INT, hdf5_dataspace
      , H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_sfr);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Cooling", H5T_NATIVE_INT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_cooling);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_StellarAge", H5T_NATIVE_INT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_stellarage);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Metals", H5T_NATIVE_INT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_metals);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  hdf5_dataspace = H5Screate(H5S_SCALAR);
  hdf5_attribute = H5Acreate(handle, "Flag_Feedback", H5T_NATIVE_INT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_INT, &header.flag_feedback);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);

  header.flag_entropy_instead_u = 0;

  hdf5_dataspace = H5Screate(H5S_SIMPLE);
  H5Sset_extent_simple(hdf5_dataspace, 1, adim, NULL);
  hdf5_attribute = H5Acreate(handle, "Flag_Entropy_ICs", H5T_NATIVE_UINT, 
      hdf5_dataspace, H5P_DEFAULT);
  H5Awrite(hdf5_attribute, H5T_NATIVE_UINT, &header.flag_entropy_instead_u);
  H5Aclose(hdf5_attribute);
  H5Sclose(hdf5_dataspace);
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{proto_8h_ad5243b69dcba17be62f7d64f422bfbbf_icgraph}
\end{center}
\end{figure}


\hypertarget{proto_8h_a38a8b7521229c82f0f4146f60b88d9c5}{\index{proto.\-h@{proto.\-h}!write\-\_\-pid\-\_\-file@{write\-\_\-pid\-\_\-file}}
\index{write\-\_\-pid\-\_\-file@{write\-\_\-pid\-\_\-file}!proto.h@{proto.\-h}}
\subsubsection[{write\-\_\-pid\-\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf write\-\_\-pid\-\_\-file} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{proto_8h_a38a8b7521229c82f0f4146f60b88d9c5}
