\hypertarget{begrun_8c}{\section{begrun.\-c \-File \-Reference}
\label{begrun_8c}\index{begrun.\-c@{begrun.\-c}}
}


initial set-\/up of a simulation run  


{\ttfamily \#include $<$stdio.\-h$>$}\*
{\ttfamily \#include $<$stdlib.\-h$>$}\*
{\ttfamily \#include $<$string.\-h$>$}\*
{\ttfamily \#include $<$math.\-h$>$}\*
{\ttfamily \#include $<$mpi.\-h$>$}\*
{\ttfamily \#include $<$sys/types.\-h$>$}\*
{\ttfamily \#include $<$unistd.\-h$>$}\*
{\ttfamily \#include $<$gsl/gsl\-\_\-rng.\-h$>$}\*
{\ttfamily \#include \char`\"{}allvars.\-h\char`\"{}}\*
{\ttfamily \#include \char`\"{}proto.\-h\char`\"{}}\*
\-Include dependency graph for begrun.\-c\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c__incl}
\end{center}
\end{figure}
\subsection*{\-Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{begrun_8c_a8747af38b86aa2bbcda2f1b1aa0888c2}{\-D\-O\-U\-B\-L\-E}~1
\item 
\#define \hyperlink{begrun_8c_a0f4d394a3ab4e09bff60f714c66dc5ee}{\-S\-T\-R\-I\-N\-G}~2
\item 
\#define \hyperlink{begrun_8c_afeeffe52c8fd59db7c61cf8b02042dbf}{\-I\-N\-T}~3
\item 
\#define \hyperlink{begrun_8c_a80a3e5dc9fa74f5cba16d39307f148e0}{\-M\-A\-X\-T\-A\-G\-S}~300
\end{DoxyCompactItemize}
\subsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{begrun_8c_aceeb5c8909331b90ea8345e0fc853f82}{begrun} (void)
\item 
void \hyperlink{begrun_8c_aba986f6be1d66945199c7ea43e5c9610}{set\-\_\-units} (void)
\item 
void \hyperlink{begrun_8c_a6f629274f7b036874c743fb81d58ce68}{open\-\_\-outputfiles} (void)
\item 
void \hyperlink{begrun_8c_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}{close\-\_\-outputfiles} (void)
\item 
void \hyperlink{begrun_8c_a952eae1977b498c4fdfabed1742a3ba2}{read\-\_\-parameter\-\_\-file} (char $\ast$fname)
\item 
int \hyperlink{begrun_8c_a849a294ac908c933ffb82dc4319af513}{read\-\_\-outputlist} (char $\ast$fname)
\item 
void \hyperlink{begrun_8c_acc4d1f5e4e51140090a7ce25ea263b98}{readjust\-\_\-timebase} (double \-Time\-Max\-\_\-old, double \-Time\-Max\-\_\-new)
\end{DoxyCompactItemize}


\subsection{\-Detailed \-Description}
initial set-\/up of a simulation run \-This file contains various functions to initialize a simulation run. \-In particular, the parameterfile is read in and parsed, the initial conditions or restart files are read, and global variables are initialized to their proper values. 

\-Definition in file \hyperlink{begrun_8c_source}{begrun.\-c}.



\subsection{\-Define \-Documentation}
\hypertarget{begrun_8c_a8747af38b86aa2bbcda2f1b1aa0888c2}{\index{begrun.\-c@{begrun.\-c}!\-D\-O\-U\-B\-L\-E@{\-D\-O\-U\-B\-L\-E}}
\index{\-D\-O\-U\-B\-L\-E@{\-D\-O\-U\-B\-L\-E}!begrun.c@{begrun.\-c}}
\subsubsection[{\-D\-O\-U\-B\-L\-E}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-D\-O\-U\-B\-L\-E}~1}}\label{begrun_8c_a8747af38b86aa2bbcda2f1b1aa0888c2}


\-Referenced by read\-\_\-parameter\-\_\-file().

\hypertarget{begrun_8c_afeeffe52c8fd59db7c61cf8b02042dbf}{\index{begrun.\-c@{begrun.\-c}!\-I\-N\-T@{\-I\-N\-T}}
\index{\-I\-N\-T@{\-I\-N\-T}!begrun.c@{begrun.\-c}}
\subsubsection[{\-I\-N\-T}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-I\-N\-T}~3}}\label{begrun_8c_afeeffe52c8fd59db7c61cf8b02042dbf}


\-Referenced by read\-\_\-parameter\-\_\-file().

\hypertarget{begrun_8c_a80a3e5dc9fa74f5cba16d39307f148e0}{\index{begrun.\-c@{begrun.\-c}!\-M\-A\-X\-T\-A\-G\-S@{\-M\-A\-X\-T\-A\-G\-S}}
\index{\-M\-A\-X\-T\-A\-G\-S@{\-M\-A\-X\-T\-A\-G\-S}!begrun.c@{begrun.\-c}}
\subsubsection[{\-M\-A\-X\-T\-A\-G\-S}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-M\-A\-X\-T\-A\-G\-S}~300}}\label{begrun_8c_a80a3e5dc9fa74f5cba16d39307f148e0}


\-Referenced by read\-\_\-parameter\-\_\-file().

\hypertarget{begrun_8c_a0f4d394a3ab4e09bff60f714c66dc5ee}{\index{begrun.\-c@{begrun.\-c}!\-S\-T\-R\-I\-N\-G@{\-S\-T\-R\-I\-N\-G}}
\index{\-S\-T\-R\-I\-N\-G@{\-S\-T\-R\-I\-N\-G}!begrun.c@{begrun.\-c}}
\subsubsection[{\-S\-T\-R\-I\-N\-G}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-S\-T\-R\-I\-N\-G}~2}}\label{begrun_8c_a0f4d394a3ab4e09bff60f714c66dc5ee}


\-Referenced by read\-\_\-parameter\-\_\-file().



\subsection{\-Function \-Documentation}
\hypertarget{begrun_8c_aceeb5c8909331b90ea8345e0fc853f82}{\index{begrun.\-c@{begrun.\-c}!begrun@{begrun}}
\index{begrun@{begrun}!begrun.c@{begrun.\-c}}
\subsubsection[{begrun}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf begrun} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{begrun_8c_aceeb5c8909331b90ea8345e0fc853f82}
\-This function performs the initial set-\/up of the simulation. \-First, the parameterfile is set, then routines for setting units, reading \-I\-Cs/restart-\/files are called, auxialiary memory is allocated, etc. $<$ code version string 

\-Definition at line 28 of file begrun.\-c.



\-References \-All, allocate\-\_\-commbuffers(), \-Allocate\-Interaction\-Table(), \-C\-P\-U\-This\-Run, ewald\-\_\-init(), find\-\_\-next\-\_\-outputtime(), init(), init\-\_\-drift\-\_\-table(), init\-\_\-geofactor\-\_\-table(), long\-\_\-range\-\_\-init(), long\-\_\-range\-\_\-init\-\_\-regionsize(), \-N\-Task, \-Num\-Part, open\-\_\-outputfiles(), \-P, \-Parameter\-File, random\-\_\-generator, read\-\_\-parameter\-\_\-file(), readjust\-\_\-timebase(), restart(), \-Restart\-Flag, set\-\_\-random\-\_\-numbers(), set\-\_\-units(), and \-This\-Task.



\-Referenced by main().


\begin{DoxyCode}
{
  struct global_data_all_processes all;

  if(ThisTask == 0)
    {
      printf("\nThis is Gadget, version `%s'.\n", GADGETVERSION);
      printf("\nRunning on %d processors.\n", NTask);
    }

  read_parameter_file(ParameterFile);   /* ... read in parameters for this run 
      */

  allocate_commbuffers();       /* ... allocate buffer-memory for particle 
                                   exchange during force computation */
  set_units();

#if defined(PERIODIC) && (!defined(PMGRID) || defined(FORCETEST))
  ewald_init();
#endif

  open_outputfiles();

  random_generator = gsl_rng_alloc(gsl_rng_ranlxd1);
  gsl_rng_set(random_generator, 42);    /* start-up seed */

#ifdef PMGRID
  long_range_init();
#endif

  All.TimeLastRestartFile = CPUThisRun;

#ifdef COMPUTE_SELFINTERACTION_FORDARK
  int i;
  for(i = 0; i < NumPart; i++)
    P[i].dTi_selfInt = 0;
  AllocateInteractionTable(INTERACTION_TABLE_LENGTH, PARTICLE_MAX_INTERACTIONS 
      + 1);
  init_geofactor_table();
#endif

  if(RestartFlag == 0 || RestartFlag == 2)
    {
      set_random_numbers();

      init();                   /* ... read in initial model */
    }
  else
    {
      all = All;                /* save global variables. (will be read from
       restart file) */

      restart(RestartFlag);     /* ... read restart file. Note: This also
       resets 
                                   all variables in the struct `All'. 
                                   However, during the run, some variables in
       the parameter
                                   file are allowed to be changed, if desired.
       These need to 
                                   copied in the way below.
                                   Note:  All.PartAllocFactor is treated in
       restart() separately.  
                                 */

      All.MinSizeTimestep = all.MinSizeTimestep;
      All.MaxSizeTimestep = all.MaxSizeTimestep;
      All.BufferSize = all.BufferSize;
      All.BunchSizeForce = all.BunchSizeForce;
      All.BunchSizeDensity = all.BunchSizeDensity;
      All.BunchSizeHydro = all.BunchSizeHydro;
      All.BunchSizeDomain = all.BunchSizeDomain;

      All.TimeLimitCPU = all.TimeLimitCPU;
      All.ResubmitOn = all.ResubmitOn;
      All.TimeBetSnapshot = all.TimeBetSnapshot;
      All.TimeBetStatistics = all.TimeBetStatistics;
      All.CpuTimeBetRestartFile = all.CpuTimeBetRestartFile;
      All.ErrTolIntAccuracy = all.ErrTolIntAccuracy;
      All.MaxRMSDisplacementFac = all.MaxRMSDisplacementFac;

      All.ErrTolForceAcc = all.ErrTolForceAcc;

      All.TypeOfTimestepCriterion = all.TypeOfTimestepCriterion;
      All.TypeOfOpeningCriterion = all.TypeOfOpeningCriterion;
      All.NumFilesWrittenInParallel = all.NumFilesWrittenInParallel;
      All.TreeDomainUpdateFrequency = all.TreeDomainUpdateFrequency;

      All.SnapFormat = all.SnapFormat;
      All.NumFilesPerSnapshot = all.NumFilesPerSnapshot;
      All.MaxNumNgbDeviation = all.MaxNumNgbDeviation;
      All.ArtBulkViscConst = all.ArtBulkViscConst;


      All.OutputListOn = all.OutputListOn;
      All.CourantFac = all.CourantFac;

      All.OutputListLength = all.OutputListLength;
      memcpy(All.OutputListTimes, all.OutputListTimes, sizeof(double) * All.
      OutputListLength);


      strcpy(All.ResubmitCommand, all.ResubmitCommand);
      strcpy(All.OutputListFilename, all.OutputListFilename);
      strcpy(All.OutputDir, all.OutputDir);
      strcpy(All.RestartFile, all.RestartFile);
      strcpy(All.EnergyFile, all.EnergyFile);
      strcpy(All.InfoFile, all.InfoFile);
      strcpy(All.CpuFile, all.CpuFile);
      strcpy(All.TimingsFile, all.TimingsFile);
      strcpy(All.SnapshotFileBase, all.SnapshotFileBase);

      if(All.TimeMax != all.TimeMax)
        readjust_timebase(All.TimeMax, all.TimeMax);
    }

#ifdef PMGRID
  long_range_init_regionsize();
#endif
 
  if(All.ComovingIntegrationOn)
    init_drift_table();

  if(RestartFlag == 2)
    All.Ti_nextoutput = find_next_outputtime(All.Ti_Current + 1);
  else
    All.Ti_nextoutput = find_next_outputtime(All.Ti_Current);


  All.TimeLastRestartFile = CPUThisRun;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_aceeb5c8909331b90ea8345e0fc853f82_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=208pt]{begrun_8c_aceeb5c8909331b90ea8345e0fc853f82_icgraph}
\end{center}
\end{figure}


\hypertarget{begrun_8c_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}{\index{begrun.\-c@{begrun.\-c}!close\-\_\-outputfiles@{close\-\_\-outputfiles}}
\index{close\-\_\-outputfiles@{close\-\_\-outputfiles}!begrun.c@{begrun.\-c}}
\subsubsection[{close\-\_\-outputfiles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf close\-\_\-outputfiles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{begrun_8c_aa1abb9ee0e0a43ec19cdaa55c8ecd43c}
\-This function closes the global log-\/files. 

\-Definition at line 265 of file begrun.\-c.



\-References \-Fd\-C\-P\-U, \-Fd\-Energy, \-Fd\-Force\-Test, \-Fd\-Info, \-Fd\-Timings, and \-This\-Task.



\-Referenced by run().


\begin{DoxyCode}
{
  if(ThisTask != 0)             /* only the root processor writes to the log
       files */
    return;

  fclose(FdCPU);
  fclose(FdInfo);
  fclose(FdEnergy);
  fclose(FdTimings);
#ifdef FORCETEST
  fclose(FdForceTest);
#endif
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{begrun_8c_aa1abb9ee0e0a43ec19cdaa55c8ecd43c_icgraph}
\end{center}
\end{figure}


\hypertarget{begrun_8c_a6f629274f7b036874c743fb81d58ce68}{\index{begrun.\-c@{begrun.\-c}!open\-\_\-outputfiles@{open\-\_\-outputfiles}}
\index{open\-\_\-outputfiles@{open\-\_\-outputfiles}!begrun.c@{begrun.\-c}}
\subsubsection[{open\-\_\-outputfiles}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf open\-\_\-outputfiles} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{begrun_8c_a6f629274f7b036874c743fb81d58ce68}
\-This function opens various log-\/files that report on the status and performance of the simulstion. \-On restart from restart-\/files (start-\/option 1), the code will append to these files. 

\-Definition at line 207 of file begrun.\-c.



\-References \-All, endrun(), \-Fd\-C\-P\-U, \-Fd\-Energy, \-Fd\-Force\-Test, \-Fd\-Info, \-Fd\-Timings, \-Restart\-Flag, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  char mode[2], buf[200];

  if(ThisTask != 0)             /* only the root processor writes to the log
       files */
    return;

  if(RestartFlag == 0)
    strcpy(mode, "w");
  else
    strcpy(mode, "a");


  sprintf(buf, "%s%s", All.OutputDir, All.CpuFile);
  if(!(FdCPU = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.InfoFile);
  if(!(FdInfo = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.EnergyFile);
  if(!(FdEnergy = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

  sprintf(buf, "%s%s", All.OutputDir, All.TimingsFile);
  if(!(FdTimings = fopen(buf, mode)))
    {
      printf("error in opening file '%s'\n", buf);
      endrun(1);
    }

#ifdef FORCETEST
  if(RestartFlag == 0)
    {
      sprintf(buf, "%s%s", All.OutputDir, "forcetest.txt");
      if(!(FdForceTest = fopen(buf, "w")))
        {
          printf("error in opening file '%s'\n", buf);
          endrun(1);
        }
      fclose(FdForceTest);
    }
#endif
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_a6f629274f7b036874c743fb81d58ce68_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{begrun_8c_a6f629274f7b036874c743fb81d58ce68_icgraph}
\end{center}
\end{figure}


\hypertarget{begrun_8c_a849a294ac908c933ffb82dc4319af513}{\index{begrun.\-c@{begrun.\-c}!read\-\_\-outputlist@{read\-\_\-outputlist}}
\index{read\-\_\-outputlist@{read\-\_\-outputlist}!begrun.c@{begrun.\-c}}
\subsubsection[{read\-\_\-outputlist}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf read\-\_\-outputlist} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{begrun_8c_a849a294ac908c933ffb82dc4319af513}
this function reads a table with a list of desired output times. \-The table does not have to be ordered in any way, but may not contain more than \-M\-A\-X\-L\-E\-N\-\_\-\-O\-U\-T\-P\-U\-T\-L\-I\-S\-T entries. $<$ maxmimum number of entries in list of snapshot output times 

\-Definition at line 777 of file begrun.\-c.



\-References \-All, and fd.



\-Referenced by read\-\_\-parameter\-\_\-file().


\begin{DoxyCode}
{
  FILE *fd;

  if(!(fd = fopen(fname, "r")))
    {
      printf("can't read output list in file '%s'\n", fname);
      return 1;
    }

  All.OutputListLength = 0;
  do
    {
      if(fscanf(fd, " %lg ", &All.OutputListTimes[All.OutputListLength]) == 1)
        All.OutputListLength++;
      else
        break;
    }
  while(All.OutputListLength < MAXLEN_OUTPUTLIST);

  fclose(fd);

  printf("\nfound %d times in output-list.\n", All.OutputListLength);

  return 0;
}
\end{DoxyCode}


\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_a849a294ac908c933ffb82dc4319af513_icgraph}
\end{center}
\end{figure}


\hypertarget{begrun_8c_a952eae1977b498c4fdfabed1742a3ba2}{\index{begrun.\-c@{begrun.\-c}!read\-\_\-parameter\-\_\-file@{read\-\_\-parameter\-\_\-file}}
\index{read\-\_\-parameter\-\_\-file@{read\-\_\-parameter\-\_\-file}!begrun.c@{begrun.\-c}}
\subsubsection[{read\-\_\-parameter\-\_\-file}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf read\-\_\-parameter\-\_\-file} (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{fname}
\end{DoxyParamCaption}
)}}\label{begrun_8c_a952eae1977b498c4fdfabed1742a3ba2}
\-This function parses the parameterfile in a simple way. \-Each paramater is defined by a keyword (`tag'), and can be either of type double, int, or character string. \-The routine makes sure that each parameter appears exactly once in the parameterfile, otherwise error messages are produced that complain about the missing parameters. 

\-Definition at line 288 of file begrun.\-c.



\-References \-All, \-D\-O\-U\-B\-L\-E, endrun(), fd, \-I\-N\-T, \-M\-A\-X\-T\-A\-G\-S, \-N\-Task, read\-\_\-outputlist(), \-S\-T\-R\-I\-N\-G, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
#define DOUBLE 1
#define STRING 2
#define INT 3
#define MAXTAGS 300

  FILE *fd, *fdout;
  char buf[200], buf1[200], buf2[200], buf3[400];
  int i, j, nt;
  int id[MAXTAGS];
  void *addr[MAXTAGS];
  char tag[MAXTAGS][50];
  int  errorFlag = 0;


  if(sizeof(long long) != 8)
    {
      if(ThisTask == 0)
        printf("\nType `long long' is not 64 bit on this platform. Stopping.\n
      \n");
      endrun(0);
    }

  if(sizeof(int) != 4)
    {
      if(ThisTask == 0)
        printf("\nType `int' is not 32 bit on this platform. Stopping.\n\n");
      endrun(0);
    }

  if(sizeof(float) != 4)
    {
      if(ThisTask == 0)
        printf("\nType `float' is not 32 bit on this platform. Stopping.\n\n");
      endrun(0);
    }

  if(sizeof(double) != 8)
    {
      if(ThisTask == 0)
        printf("\nType `double' is not 64 bit on this platform. Stopping.\n\n")
      ;
      endrun(0);
    }


  if(ThisTask == 0)             /* read parameter file on process 0 */
    {
      nt = 0;

      strcpy(tag[nt], "InitCondFile");
      addr[nt] = All.InitCondFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputDir");
      addr[nt] = All.OutputDir;
      id[nt++] = STRING;

      strcpy(tag[nt], "SnapshotFileBase");
      addr[nt] = All.SnapshotFileBase;
      id[nt++] = STRING;

      strcpy(tag[nt], "EnergyFile");
      addr[nt] = All.EnergyFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "CpuFile");
      addr[nt] = All.CpuFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "InfoFile");
      addr[nt] = All.InfoFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "TimingsFile");
      addr[nt] = All.TimingsFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "RestartFile");
      addr[nt] = All.RestartFile;
      id[nt++] = STRING;

      strcpy(tag[nt], "ResubmitCommand");
      addr[nt] = All.ResubmitCommand;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputListFilename");
      addr[nt] = All.OutputListFilename;
      id[nt++] = STRING;

      strcpy(tag[nt], "OutputListOn");
      addr[nt] = &All.OutputListOn;
      id[nt++] = INT;

      strcpy(tag[nt], "Omega0");
      addr[nt] = &All.Omega0;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "OmegaBaryon");
      addr[nt] = &All.OmegaBaryon;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "OmegaLambda");
      addr[nt] = &All.OmegaLambda;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "HubbleParam");
      addr[nt] = &All.HubbleParam;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "BoxSize");
      addr[nt] = &All.BoxSize;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "PeriodicBoundariesOn");
      addr[nt] = &All.PeriodicBoundariesOn;
      id[nt++] = INT;

      strcpy(tag[nt], "TimeOfFirstSnapshot");
      addr[nt] = &All.TimeOfFirstSnapshot;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "CpuTimeBetRestartFile");
      addr[nt] = &All.CpuTimeBetRestartFile;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBetStatistics");
      addr[nt] = &All.TimeBetStatistics;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBegin");
      addr[nt] = &All.TimeBegin;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeMax");
      addr[nt] = &All.TimeMax;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TimeBetSnapshot");
      addr[nt] = &All.TimeBetSnapshot;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitVelocity_in_cm_per_s");
      addr[nt] = &All.UnitVelocity_in_cm_per_s;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitLength_in_cm");
      addr[nt] = &All.UnitLength_in_cm;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "UnitMass_in_g");
      addr[nt] = &All.UnitMass_in_g;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TreeDomainUpdateFrequency");
      addr[nt] = &All.TreeDomainUpdateFrequency;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolIntAccuracy");
      addr[nt] = &All.ErrTolIntAccuracy;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolTheta");
      addr[nt] = &All.ErrTolTheta;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ErrTolForceAcc");
      addr[nt] = &All.ErrTolForceAcc;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinGasHsmlFractional");
      addr[nt] = &All.MinGasHsmlFractional;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxSizeTimestep");
      addr[nt] = &All.MaxSizeTimestep;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinSizeTimestep");
      addr[nt] = &All.MinSizeTimestep;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxRMSDisplacementFac");
      addr[nt] = &All.MaxRMSDisplacementFac;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ArtBulkViscConst");
      addr[nt] = &All.ArtBulkViscConst;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "CourantFac");
      addr[nt] = &All.CourantFac;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "DesNumNgb");
      addr[nt] = &All.DesNumNgb;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MaxNumNgbDeviation");
      addr[nt] = &All.MaxNumNgbDeviation;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "ComovingIntegrationOn");
      addr[nt] = &All.ComovingIntegrationOn;
      id[nt++] = INT;

      strcpy(tag[nt], "ICFormat");
      addr[nt] = &All.ICFormat;
      id[nt++] = INT;

      strcpy(tag[nt], "SnapFormat");
      addr[nt] = &All.SnapFormat;
      id[nt++] = INT;

      strcpy(tag[nt], "NumFilesPerSnapshot");
      addr[nt] = &All.NumFilesPerSnapshot;
      id[nt++] = INT;

      strcpy(tag[nt], "NumFilesWrittenInParallel");
      addr[nt] = &All.NumFilesWrittenInParallel;
      id[nt++] = INT;

      strcpy(tag[nt], "ResubmitOn");
      addr[nt] = &All.ResubmitOn;
      id[nt++] = INT;

      strcpy(tag[nt], "TypeOfTimestepCriterion");
      addr[nt] = &All.TypeOfTimestepCriterion;
      id[nt++] = INT;

      strcpy(tag[nt], "TypeOfOpeningCriterion");
      addr[nt] = &All.TypeOfOpeningCriterion;
      id[nt++] = INT;

      strcpy(tag[nt], "TimeLimitCPU");
      addr[nt] = &All.TimeLimitCPU;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningHalo");
      addr[nt] = &All.SofteningHalo;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningDisk");
      addr[nt] = &All.SofteningDisk;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBulge");
      addr[nt] = &All.SofteningBulge;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningGas");
      addr[nt] = &All.SofteningGas;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningStars");
      addr[nt] = &All.SofteningStars;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBndry");
      addr[nt] = &All.SofteningBndry;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningHaloMaxPhys");
      addr[nt] = &All.SofteningHaloMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningDiskMaxPhys");
      addr[nt] = &All.SofteningDiskMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBulgeMaxPhys");
      addr[nt] = &All.SofteningBulgeMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningGasMaxPhys");
      addr[nt] = &All.SofteningGasMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningStarsMaxPhys");
      addr[nt] = &All.SofteningStarsMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SofteningBndryMaxPhys");
      addr[nt] = &All.SofteningBndryMaxPhys;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "BufferSize");
      addr[nt] = &All.BufferSize;
      id[nt++] = INT;

      strcpy(tag[nt], "PartAllocFactor");
      addr[nt] = &All.PartAllocFactor;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "TreeAllocFactor");
      addr[nt] = &All.TreeAllocFactor;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "GravityConstantInternal");
      addr[nt] = &All.GravityConstantInternal;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "InitGasTemp");
      addr[nt] = &All.InitGasTemp;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "MinGasTemp");
      addr[nt] = &All.MinGasTemp;
      id[nt++] = DOUBLE;

#ifdef COMPUTE_SELFINTERACTION_FORDARK 
      strcpy(tag[nt], "InteractionCrossSection");
      addr[nt] = &All.InteractionCrossSection;
      id[nt++] = DOUBLE;

      strcpy(tag[nt], "SIDMSmoothingFactor");
      addr[nt] = &All.SIDMSmoothingFactor;
      id[nt++] = DOUBLE;
#endif

      if((fd = fopen(fname, "r")))
        {
          sprintf(buf, "%s%s", fname, "-usedvalues");
          if(!(fdout = fopen(buf, "w")))
            {
              printf("error opening file '%s' \n", buf);
              errorFlag = 1;
            }
          else
            {
              while(!feof(fd))
                {
                  *buf = 0;
                  fgets(buf, 200, fd);
                  if(sscanf(buf, "%s%s%s", buf1, buf2, buf3) < 2)
                    continue;

                  if(buf1[0] == '%')
                    continue;

                  for(i = 0, j = -1; i < nt; i++)
                    if(strcmp(buf1, tag[i]) == 0)
                      {
                        j = i;
                        tag[i][0] = 0;
                        break;
                      }

                  if(j >= 0)
                    {
                      switch (id[j])
                        {
                        case DOUBLE:
                          *((double *) addr[j]) = atof(buf2);
                          fprintf(fdout, "%-35s%g\n", buf1, *((double *) addr[j
      ]));
                          break;
                        case STRING:
                          strcpy(addr[j], buf2);
                          fprintf(fdout, "%-35s%s\n", buf1, buf2);
                          break;
                        case INT:
                          *((int *) addr[j]) = atoi(buf2);
                          fprintf(fdout, "%-35s%d\n", buf1, *((int *) addr[j]))
      ;
                          break;
                        }
                    }
                  else
                    {
                      fprintf(stdout, "Error in file %s:   Tag '%s' not allowed
       or multiple defined.\n",
                              fname, buf1);
                      errorFlag = 1;
                    }
                }
              fclose(fd);
              fclose(fdout);

              i = strlen(All.OutputDir);
              if(i > 0)
                if(All.OutputDir[i - 1] != '/')
                  strcat(All.OutputDir, "/");

              sprintf(buf1, "%s%s", fname, "-usedvalues");
              sprintf(buf2, "%s%s", All.OutputDir, "parameters-usedvalues");
              sprintf(buf3, "cp %s %s", buf1, buf2);
              system(buf3);
            }
        }
      else
        {
          printf("\nParameter file %s not found.\n\n", fname);
          errorFlag = 2;
        }

      if(errorFlag != 2)
        for(i = 0; i < nt; i++)
          {
            if(*tag[i])
              {
                printf("Error. I miss a value for tag '%s' in parameter file
       '%s'.\n", tag[i], fname);
                errorFlag = 1;
              }
          }

      if(All.OutputListOn && errorFlag == 0)
        errorFlag += read_outputlist(All.OutputListFilename);
      else
        All.OutputListLength = 0;
    }

  MPI_Bcast(&errorFlag, 1, MPI_INT, 0, MPI_COMM_WORLD);

  if(errorFlag)
    {
      MPI_Finalize();
      exit(0);
    }

  /* now communicate the relevant parameters to the other processes */
  MPI_Bcast(&All, sizeof(struct global_data_all_processes), MPI_BYTE, 0, 
      MPI_COMM_WORLD);


  if(All.NumFilesWrittenInParallel < 1)
    {
      if(ThisTask == 0)
        printf("NumFilesWrittenInParallel MUST be at least 1\n");
      endrun(0);
    }

  if(All.NumFilesWrittenInParallel > NTask)
    {
      if(ThisTask == 0)
        printf("NumFilesWrittenInParallel MUST be smaller than number of
       processors\n");
      endrun(0);
    }

#ifdef PERIODIC
  if(All.PeriodicBoundariesOn == 0)
    {
      if(ThisTask == 0)
        {
          printf("Code was compiled with periodic boundary conditions switched
       on.\n");
          printf("You must set `PeriodicBoundariesOn=1', or recompile the code.
      \n");
        }
      endrun(0);
    }
#else
  if(All.PeriodicBoundariesOn == 1)
    {
      if(ThisTask == 0)
        {
          printf("Code was compiled with periodic boundary conditions switched
       off.\n");
          printf("You must set `PeriodicBoundariesOn=0', or recompile the code.
      \n");
        }
      endrun(0);
    }
#endif


  if(All.TypeOfTimestepCriterion >= 1)
    {
      if(ThisTask == 0)
        {
          printf("The specified timestep criterion\n");
          printf("is not valid\n");
        }
      endrun(0);
    }

#if defined(LONG_X) ||  defined(LONG_Y) || defined(LONG_Z)
#ifndef NOGRAVITY
  if(ThisTask == 0)
    {
      printf("Code was compiled with LONG_X/Y/Z, but not with NOGRAVITY.\n");
      printf("Stretched periodic boxes are not implemented for gravity yet.\n")
      ;
    }
  endrun(0);
#endif
#endif

#undef DOUBLE
#undef STRING
#undef INT
#undef MAXTAGS
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_a952eae1977b498c4fdfabed1742a3ba2_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_a952eae1977b498c4fdfabed1742a3ba2_icgraph}
\end{center}
\end{figure}


\hypertarget{begrun_8c_acc4d1f5e4e51140090a7ce25ea263b98}{\index{begrun.\-c@{begrun.\-c}!readjust\-\_\-timebase@{readjust\-\_\-timebase}}
\index{readjust\-\_\-timebase@{readjust\-\_\-timebase}!begrun.c@{begrun.\-c}}
\subsubsection[{readjust\-\_\-timebase}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf readjust\-\_\-timebase} (
\begin{DoxyParamCaption}
\item[{double}]{\-Time\-Max\-\_\-old, }
\item[{double}]{\-Time\-Max\-\_\-new}
\end{DoxyParamCaption}
)}}\label{begrun_8c_acc4d1f5e4e51140090a7ce25ea263b98}
\-If a restart from restart-\/files is carried out where the \-Time\-Max variable is increased, then the integer timeline needs to be adjusted. \-The approach taken here is to reduce the resolution of the integer timeline by factors of 2 until the new final time can be reached within \-T\-I\-M\-E\-B\-A\-S\-E. $<$ \-The simulated timespan is mapped onto the integer interval \mbox{[}0,\-T\-I\-M\-E\-S\-P\-A\-N\mbox{]}, $\ast$ where \-T\-I\-M\-E\-S\-P\-A\-N needs to be a power of 2. \-Note that (1$<$$<$28) corresponds to 2$^\wedge$29 

\-Definition at line 811 of file begrun.\-c.



\-References \-All, endrun(), \-Num\-Part, \-P, and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  int i;
  long long ti_end;

  if(ThisTask == 0)
    {
      printf("\nAll.TimeMax has been changed in the parameterfile\n");
      printf("Need to adjust integer timeline\n\n\n");
    }

  if(TimeMax_new < TimeMax_old)
    {
      if(ThisTask == 0)
        printf("\nIt is not allowed to reduce All.TimeMax\n\n");
      endrun(556);
    }

  if(All.ComovingIntegrationOn)
    ti_end = log(TimeMax_new / All.TimeBegin) / All.Timebase_interval;
  else
    ti_end = (TimeMax_new - All.TimeBegin) / All.Timebase_interval;

  while(ti_end > TIMEBASE)
    {
      All.Timebase_interval *= 2.0;

      ti_end /= 2;
      All.Ti_Current /= 2;

#ifdef PMGRID
      All.PM_Ti_begstep /= 2;
      All.PM_Ti_endstep /= 2;
#endif

      for(i = 0; i < NumPart; i++)
        {
          P[i].Ti_begstep /= 2;
          P[i].Ti_endstep /= 2;
        }
    }

  All.TimeMax = TimeMax_new;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_acc4d1f5e4e51140090a7ce25ea263b98_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{begrun_8c_acc4d1f5e4e51140090a7ce25ea263b98_icgraph}
\end{center}
\end{figure}


\hypertarget{begrun_8c_aba986f6be1d66945199c7ea43e5c9610}{\index{begrun.\-c@{begrun.\-c}!set\-\_\-units@{set\-\_\-units}}
\index{set\-\_\-units@{set\-\_\-units}!begrun.c@{begrun.\-c}}
\subsubsection[{set\-\_\-units}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf set\-\_\-units} (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{begrun_8c_aba986f6be1d66945199c7ea43e5c9610}
\-Computes conversion factors between internal code units and the cgs-\/system. $<$ \-Gravitational constant (in cgs units)

$<$ mass fraction of hydrogen, relevant only for radiative cooling

$<$ adiabatic index of simulated gas 

\-Definition at line 157 of file begrun.\-c.



\-References \-All, pow(), and \-This\-Task.



\-Referenced by begrun().


\begin{DoxyCode}
{
  double meanweight;

  All.UnitTime_in_s = All.UnitLength_in_cm / All.UnitVelocity_in_cm_per_s;
  All.UnitTime_in_Megayears = All.UnitTime_in_s / SEC_PER_MEGAYEAR;

  if(All.GravityConstantInternal == 0)
    All.G = GRAVITY / pow(All.UnitLength_in_cm, 3) * All.UnitMass_in_g * pow(All
      .UnitTime_in_s, 2);
  else
    All.G = All.GravityConstantInternal;

  All.UnitDensity_in_cgs = All.UnitMass_in_g / pow(All.UnitLength_in_cm, 3);
  All.UnitPressure_in_cgs = All.UnitMass_in_g / All.UnitLength_in_cm / pow(All.
      UnitTime_in_s, 2);
  All.UnitCoolingRate_in_cgs = All.UnitPressure_in_cgs / All.UnitTime_in_s;
  All.UnitEnergy_in_cgs = All.UnitMass_in_g * pow(All.UnitLength_in_cm, 2) / pow
      (All.UnitTime_in_s, 2);

  /* convert some physical input parameters to internal units */

  All.Hubble = HUBBLE * All.UnitTime_in_s;

  if(ThisTask == 0)
    {
      printf("\nHubble (internal units) = %g\n", All.Hubble);
      printf("G (internal units) = %g\n", All.G);
      printf("UnitMass_in_g = %g \n", All.UnitMass_in_g);
      printf("UnitTime_in_s = %g \n", All.UnitTime_in_s);
      printf("UnitVelocity_in_cm_per_s = %g \n", All.UnitVelocity_in_cm_per_s);
      printf("UnitDensity_in_cgs = %g \n", All.UnitDensity_in_cgs);
      printf("UnitEnergy_in_cgs = %g \n", All.UnitEnergy_in_cgs);
      printf("\n");
    }

  meanweight = 4.0 / (1 + 3 * HYDROGEN_MASSFRAC);       /* note: we assume
       neutral gas here */

#ifdef ISOTHERM_EQS
  All.MinEgySpec = 0;
#else
  All.MinEgySpec = 1 / meanweight * (1.0 / GAMMA_MINUS1) * (BOLTZMANN / 
      PROTONMASS) * All.MinGasTemp;
  All.MinEgySpec *= All.UnitMass_in_g / All.UnitEnergy_in_cgs;
#endif

}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{begrun_8c_aba986f6be1d66945199c7ea43e5c9610_cgraph}
\end{center}
\end{figure}




\-Here is the caller graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=304pt]{begrun_8c_aba986f6be1d66945199c7ea43e5c9610_icgraph}
\end{center}
\end{figure}


