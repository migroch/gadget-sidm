\hypertarget{timestep_8c}{
\section{timestep.c File Reference}
\label{timestep_8c}\index{timestep.c@{timestep.c}}
}


routines for 'kicking' particles in momentum space and assigning new timesteps  


{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include \char`\"{}allvars.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}proto.h\char`\"{}}\par
Include dependency graph for timestep.c:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{timestep_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{timestep_8c_a05e5a546d63684b55d2457aa56efdd06}{advance\_\-and\_\-find\_\-timesteps} (void)
\item 
int \hyperlink{timestep_8c_af48922752ff457721f558510789e61e1}{get\_\-timestep} (int p, double $\ast$aphys, int flag)
\item 
void \hyperlink{timestep_8c_a78ed439b8a1cb93647a2b9de998d9269}{find\_\-dt\_\-displacement\_\-constraint} (double hfac)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static double \hyperlink{timestep_8c_a59a20f8242197c1ba41f7a0b1b880d62}{fac1}
\item 
static double \hyperlink{timestep_8c_a1a666a0983f6d540fa41ec867aa40d09}{fac2}
\item 
static double \hyperlink{timestep_8c_aebe1da050ef46b7b63c856394494292c}{fac3}
\item 
static double \hyperlink{timestep_8c_abb7074f2e4b01309c6f2dc87bb3a1a40}{hubble\_\-a}
\item 
static double \hyperlink{timestep_8c_aec7bcb1d46812f966d89f66dc1a399ea}{atime}
\item 
static double \hyperlink{timestep_8c_a7f2a6bb4bade30e4e04ee29be22d0962}{a3inv}
\item 
static double \hyperlink{timestep_8c_aebcd2de4b9dfac8c2feb1594616f4803}{dt\_\-displacement} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
routines for 'kicking' particles in momentum space and assigning new timesteps 

Definition in file \hyperlink{timestep_8c_source}{timestep.c}.



\subsection{Function Documentation}
\hypertarget{timestep_8c_a05e5a546d63684b55d2457aa56efdd06}{
\index{timestep.c@{timestep.c}!advance\_\-and\_\-find\_\-timesteps@{advance\_\-and\_\-find\_\-timesteps}}
\index{advance\_\-and\_\-find\_\-timesteps@{advance\_\-and\_\-find\_\-timesteps}!timestep.c@{timestep.c}}
\subsubsection[{advance\_\-and\_\-find\_\-timesteps}]{\setlength{\rightskip}{0pt plus 5cm}void advance\_\-and\_\-find\_\-timesteps (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{timestep_8c_a05e5a546d63684b55d2457aa56efdd06}
This function advances the system in momentum space, i.e. it does apply the 'kick' operation after the forces have been computed. Additionally, it assigns new timesteps to particles. At start-\/up, a half-\/timestep is carried out, as well as at the end of the simulation. In between, the half-\/step kick that ends the previous timestep and the half-\/step kick for the new timestep are combined into one operation. 

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ adiabatic index of simulated gas

$<$ adiabatic index of simulated gas

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 



Definition at line 24 of file timestep.c.



References a3inv, All, atime, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CPU\_\-TimeLine, NODE::d, dt\_\-displacement, sph\_\-particle\_\-data::DtEntropy, sph\_\-particle\_\-data::Entropy, Extnodes, fac1, fac2, fac3, Father, find\_\-dt\_\-displacement\_\-constraint(), Flag\_\-FullStep, FLOAT, global\_\-data\_\-all\_\-processes::G, GAMMA, GAMMA\_\-MINUS1, get\_\-gravkick\_\-factor(), get\_\-hydrokick\_\-factor(), get\_\-random\_\-number(), get\_\-timestep(), particle\_\-data::GravAccel, particle\_\-data::GravPM, global\_\-data\_\-all\_\-processes::Hubble, hubble\_\-a, sph\_\-particle\_\-data::HydroAccel, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, global\_\-data\_\-all\_\-processes::MinEgySpec, Nodes, global\_\-data\_\-all\_\-processes::NumForcesSinceLastDomainDecomp, NumPart, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaLambda, P, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-begstep, global\_\-data\_\-all\_\-processes::PM\_\-Ti\_\-endstep, particle\_\-data::Pos, pow(), second(), SphP, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Time, TIMEBASE, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, timediff(), global\_\-data\_\-all\_\-processes::TotNumPart, global\_\-data\_\-all\_\-processes::TreeDomainUpdateFrequency, NODE::u, particle\_\-data::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by run().




\begin{DoxyCode}
{
  int i, j, no, ti_step, ti_min, tend, tstart;
  double dt_entr, dt_entr2, dt_gravkick, dt_hydrokick, dt_gravkick2, dt_hydrokick
      2, t0, t1;
  double minentropy, aphys;
  FLOAT dv[3];

#ifdef FLEXSTEPS
  int ti_grp;
#endif
#if defined(PSEUDOSYMMETRIC) && !defined(FLEXSTEPS)
  double apred, prob;
  int ti_step2;
#endif
#ifdef PMGRID
  double dt_gravkickA, dt_gravkickB;
#endif
#ifdef MAKEGLASS
  double disp, dispmax, globmax, dmean, fac, disp2sum, globdisp2sum;
#endif

  t0 = second();

  if(All.ComovingIntegrationOn)
    {
      fac1 = 1 / (All.Time * All.Time);
      fac2 = 1 / pow(All.Time, 3 * GAMMA - 2);
      fac3 = pow(All.Time, 3 * (1 - GAMMA) / 2.0);
      hubble_a = All.Omega0 / (All.Time * All.Time * All.Time)
        + (1 - All.Omega0 - All.OmegaLambda) / (All.Time * All.Time) + All.
      OmegaLambda;

      hubble_a = All.Hubble * sqrt(hubble_a);
      a3inv = 1 / (All.Time * All.Time * All.Time);
      atime = All.Time;
    }
  else
    fac1 = fac2 = fac3 = hubble_a = a3inv = atime = 1;

#ifdef NOPMSTEPADJUSTMENT
  dt_displacement = All.MaxSizeTimestep;
#else
  if(Flag_FullStep || dt_displacement == 0)
    find_dt_displacement_constraint(hubble_a * atime * atime);
#endif

#ifdef PMGRID
  if(All.ComovingIntegrationOn)
    dt_gravkickB = get_gravkick_factor(All.PM_Ti_begstep, All.Ti_Current) -
      get_gravkick_factor(All.PM_Ti_begstep, (All.PM_Ti_begstep + All.
      PM_Ti_endstep) / 2);
  else
    dt_gravkickB = (All.Ti_Current - (All.PM_Ti_begstep + All.PM_Ti_endstep) / 2)
       * All.Timebase_interval;

  if(All.PM_Ti_endstep == All.Ti_Current)       /* need to do long-range kick */
    {
      /* make sure that we reconstruct the domain/tree next time because we don't
       kick the tree nodes in this case */
      All.NumForcesSinceLastDomainDecomp = 1 + All.TotNumPart * All.
      TreeDomainUpdateFrequency;
    }
#endif


#ifdef MAKEGLASS
  for(i = 0, dispmax = 0, disp2sum = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          P[i].GravPM[j] *= -1;
          P[i].GravAccel[j] *= -1;
          P[i].GravAccel[j] += P[i].GravPM[j];
          P[i].GravPM[j] = 0;
        }

      disp = sqrt(P[i].GravAccel[0] * P[i].GravAccel[0] +
                  P[i].GravAccel[1] * P[i].GravAccel[1] + P[i].GravAccel[2] * P[i
      ].GravAccel[2]);

      disp *= 2.0 / (3 * All.Hubble * All.Hubble);

      disp2sum += disp * disp;

      if(disp > dispmax)
        dispmax = disp;
    }

  MPI_Allreduce(&dispmax, &globmax, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
  MPI_Allreduce(&disp2sum, &globdisp2sum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD)
      ;

  dmean = pow(P[0].Mass / (All.Omega0 * 3 * All.Hubble * All.Hubble / (8 * M_PI *
       All.G)), 1.0 / 3);

  if(globmax > dmean)
    fac = dmean / globmax;
  else
    fac = 1.0;

  if(ThisTask == 0)
    {
      printf("\nglass-making:  dmean= %g  global disp-maximum= %g  rms= %g\n\n",
             dmean, globmax, sqrt(globdisp2sum / All.TotNumPart));
      fflush(stdout);
    }

  for(i = 0, dispmax = 0; i < NumPart; i++)
    {
      for(j = 0; j < 3; j++)
        {
          P[i].Vel[j] = 0;
          P[i].Pos[j] += fac * P[i].GravAccel[j] * 2.0 / (3 * All.Hubble * All.
      Hubble);
          P[i].GravAccel[j] = 0;
        }
    }
#endif




  /* Now assign new timesteps and kick */

#ifdef FLEXSTEPS
  if((All.Ti_Current % (4 * All.PresentMinStep)) == 0)
    if(All.PresentMinStep < TIMEBASE)
      All.PresentMinStep *= 2;

  for(i = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          ti_step = get_timestep(i, &aphys, 0);

          /* make it a power 2 subdivision */
          ti_min = TIMEBASE;
          while(ti_min > ti_step)
            ti_min >>= 1;
          ti_step = ti_min;

          if(ti_step < All.PresentMinStep)
            All.PresentMinStep = ti_step;
        }
    }

  ti_step = All.PresentMinStep;
  MPI_Allreduce(&ti_step, &All.PresentMinStep, 1, MPI_INT, MPI_MIN, MPI_COMM_WORL
      D);

  if(dt_displacement < All.MaxSizeTimestep)
    ti_step = (int) (dt_displacement / All.Timebase_interval);
  else
    ti_step = (int) (All.MaxSizeTimestep / All.Timebase_interval);

  /* make it a power 2 subdivision */
  ti_min = TIMEBASE;
  while(ti_min > ti_step)
    ti_min >>= 1;
  All.PresentMaxStep = ti_min;


  if(ThisTask == 0)
    printf("Syn Range = %g  PresentMinStep = %d  PresentMaxStep = %d \n",
           (double) All.PresentMaxStep / All.PresentMinStep, All.PresentMinStep, 
      All.PresentMaxStep);

#endif


  for(i = 0; i < NumPart; i++)
    {
      if(P[i].Ti_endstep == All.Ti_Current)
        {
          ti_step = get_timestep(i, &aphys, 0);

          /* make it a power 2 subdivision */
          ti_min = TIMEBASE;
          while(ti_min > ti_step)
            ti_min >>= 1;
          ti_step = ti_min;

#ifdef FLEXSTEPS
          ti_grp = P[i].FlexStepGrp % All.PresentMaxStep;
          ti_grp = (ti_grp / All.PresentMinStep) * All.PresentMinStep;
          ti_step = ((P[i].Ti_endstep + ti_grp + ti_step) / ti_step) * ti_step - 
      (P[i].Ti_endstep + ti_grp);
#else

#ifdef PSEUDOSYMMETRIC
          if(P[i].Type != 0)
            {
              if(P[i].Ti_endstep > P[i].Ti_begstep)
                {
                  apred = aphys + ((aphys - P[i].AphysOld) / (P[i].Ti_endstep - 
      P[i].Ti_begstep)) * ti_step;
                  if(fabs(apred - aphys) < 0.5 * aphys)
                    {
                      ti_step2 = get_timestep(i, &apred, -1);
                      ti_min = TIMEBASE;
                      while(ti_min > ti_step2)
                        ti_min >>= 1;
                      ti_step2 = ti_min;

                      if(ti_step2 < ti_step)
                        {
                          get_timestep(i, &apred, ti_step);
                          prob =
                            ((apred - aphys) / (aphys - P[i].AphysOld) * (P[i].
      Ti_endstep -
                                                                          P[i].
      Ti_begstep)) / ti_step;
                          if(prob < get_random_number(P[i].ID))
                            ti_step /= 2;
                        }
                      else if(ti_step2 > ti_step)
                        {
                          get_timestep(i, &apred, 2 * ti_step);
                          prob =
                            ((apred - aphys) / (aphys - P[i].AphysOld) * (P[i].
      Ti_endstep -
                                                                          P[i].
      Ti_begstep)) / ti_step;
                          if(prob < get_random_number(P[i].ID + 1))
                            ti_step *= 2;
                        }
                    }
                }
              P[i].AphysOld = aphys;
            }
#endif

#ifdef SYNCHRONIZATION
          if(ti_step > (P[i].Ti_endstep - P[i].Ti_begstep))     /* timestep wants
       to increase */
            {
              if(((TIMEBASE - P[i].Ti_endstep) % ti_step) > 0)
                ti_step = P[i].Ti_endstep - P[i].Ti_begstep;    /* leave at old s
      tep */
            }
#endif
#endif /* end of FLEXSTEPS */

          if(All.Ti_Current == TIMEBASE)        /* we here finish the last timest
      ep. */
            ti_step = 0;

          if((TIMEBASE - All.Ti_Current) < ti_step)     /* check that we don't ru
      n beyond the end */
            ti_step = TIMEBASE - All.Ti_Current;

          tstart = (P[i].Ti_begstep + P[i].Ti_endstep) / 2;     /* midpoint of ol
      d step */
          tend = P[i].Ti_endstep + ti_step / 2; /* midpoint of new step */

          if(All.ComovingIntegrationOn)
            {
              dt_entr = (tend - tstart) * All.Timebase_interval;
              dt_entr2 = (tend - P[i].Ti_endstep) * All.Timebase_interval;
              dt_gravkick = get_gravkick_factor(tstart, tend);
              dt_hydrokick = get_hydrokick_factor(tstart, tend);
              dt_gravkick2 = get_gravkick_factor(P[i].Ti_endstep, tend);
              dt_hydrokick2 = get_hydrokick_factor(P[i].Ti_endstep, tend);
            }
          else
            {
              dt_entr = dt_gravkick = dt_hydrokick = (tend - tstart) * All.
      Timebase_interval;
              dt_gravkick2 = dt_hydrokick2 = dt_entr2 = (tend - P[i].Ti_endstep) 
      * All.Timebase_interval;
            }

          P[i].Ti_begstep = P[i].Ti_endstep;
          P[i].Ti_endstep = P[i].Ti_begstep + ti_step;


          /* do the kick */

          for(j = 0; j < 3; j++)
            {
              dv[j] = P[i].GravAccel[j] * dt_gravkick;
              P[i].Vel[j] += dv[j];
            }

          if(P[i].Type == 0)    /* SPH stuff */
            {
              for(j = 0; j < 3; j++)
                {
                  dv[j] += SphP[i].HydroAccel[j] * dt_hydrokick;
                  P[i].Vel[j] += SphP[i].HydroAccel[j] * dt_hydrokick;

                  SphP[i].VelPred[j] =
                    P[i].Vel[j] - dt_gravkick2 * P[i].GravAccel[j] - dt_hydrokick
      2 * SphP[i].HydroAccel[j];
#ifdef PMGRID
                  SphP[i].VelPred[j] += P[i].GravPM[j] * dt_gravkickB;
#endif
                }

              /* In case of cooling, we prevent that the entropy (and
                 hence temperature decreases by more than a factor 0.5 */

              if(SphP[i].DtEntropy * dt_entr > -0.5 * SphP[i].Entropy)
                SphP[i].Entropy += SphP[i].DtEntropy * dt_entr;
              else
                SphP[i].Entropy *= 0.5;

              if(All.MinEgySpec)
                {
                  minentropy = All.MinEgySpec * GAMMA_MINUS1 / pow(SphP[i].Densit
      y * a3inv, GAMMA_MINUS1);
                  if(SphP[i].Entropy < minentropy)
                    {
                      SphP[i].Entropy = minentropy;
                      SphP[i].DtEntropy = 0;
                    }
                }

              /* In case the timestep increases in the new step, we
                 make sure that we do not 'overcool' when deriving
                 predicted temperatures. The maximum timespan over
                 which prediction can occur is ti_step/2, i.e. from
                 the middle to the end of the current step */

              dt_entr = ti_step / 2 * All.Timebase_interval;
              if(SphP[i].Entropy + SphP[i].DtEntropy * dt_entr < 0.5 * SphP[i].En
      tropy)
                SphP[i].DtEntropy = -0.5 * SphP[i].Entropy / dt_entr;
            }


          /* if tree is not going to be reconstructed, kick parent nodes dynamica
      lly.
           */
          if(All.NumForcesSinceLastDomainDecomp < All.TotNumPart * All.
      TreeDomainUpdateFrequency)
            {
              no = Father[i];
              while(no >= 0)
                {
                  for(j = 0; j < 3; j++)
                    Extnodes[no].vs[j] += dv[j] * P[i].Mass / Nodes[no].u.d.mass;
      

                  no = Nodes[no].u.d.father;
                }
            }
        }
    }



#ifdef PMGRID
  if(All.PM_Ti_endstep == All.Ti_Current)       /* need to do long-range kick */
    {
      ti_step = TIMEBASE;
      while(ti_step > (dt_displacement / All.Timebase_interval))
        ti_step >>= 1;

      if(ti_step > (All.PM_Ti_endstep - All.PM_Ti_begstep))     /* PM-timestep wa
      nts to increase */
        {
          /* we only increase if an integer number of steps will bring us to the 
      end */
          if(((TIMEBASE - All.PM_Ti_endstep) % ti_step) > 0)
            ti_step = All.PM_Ti_endstep - All.PM_Ti_begstep;    /* leave at old s
      tep */
        }

      if(All.Ti_Current == TIMEBASE)    /* we here finish the last timestep. */
        ti_step = 0;

      tstart = (All.PM_Ti_begstep + All.PM_Ti_endstep) / 2;
      tend = All.PM_Ti_endstep + ti_step / 2;

      if(All.ComovingIntegrationOn)
        dt_gravkick = get_gravkick_factor(tstart, tend);
      else
        dt_gravkick = (tend - tstart) * All.Timebase_interval;

      All.PM_Ti_begstep = All.PM_Ti_endstep;
      All.PM_Ti_endstep = All.PM_Ti_begstep + ti_step;

      if(All.ComovingIntegrationOn)
        dt_gravkickB = -get_gravkick_factor(All.PM_Ti_begstep, (All.
      PM_Ti_begstep + All.PM_Ti_endstep) / 2);
      else
        dt_gravkickB =
          -((All.PM_Ti_begstep + All.PM_Ti_endstep) / 2 - All.PM_Ti_begstep) * 
      All.Timebase_interval;

      for(i = 0; i < NumPart; i++)
        {
          for(j = 0; j < 3; j++)        /* do the kick */
            P[i].Vel[j] += P[i].GravPM[j] * dt_gravkick;

          if(P[i].Type == 0)
            {
              if(All.ComovingIntegrationOn)
                {
                  dt_gravkickA = get_gravkick_factor(P[i].Ti_begstep, All.
      Ti_Current) -
                    get_gravkick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i].
      Ti_endstep) / 2);
                  dt_hydrokick = get_hydrokick_factor(P[i].Ti_begstep, All.
      Ti_Current) -
                    get_hydrokick_factor(P[i].Ti_begstep, (P[i].Ti_begstep + P[i]
      .Ti_endstep) / 2);
                }
              else
                dt_gravkickA = dt_hydrokick =
                  (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) / 2) * 
      All.Timebase_interval;

              for(j = 0; j < 3; j++)
                SphP[i].VelPred[j] = P[i].Vel[j]
                  + P[i].GravAccel[j] * dt_gravkickA
                  + SphP[i].HydroAccel[j] * dt_hydrokick + P[i].GravPM[j] * dt_gr
      avkickB;
            }
        }
    }
#endif

  t1 = second();
  All.CPU_TimeLine += timediff(t0, t1);
}
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{timestep_8c_a05e5a546d63684b55d2457aa56efdd06_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=382pt]{timestep_8c_a05e5a546d63684b55d2457aa56efdd06_icgraph}
\end{center}
\end{figure}


\hypertarget{timestep_8c_a78ed439b8a1cb93647a2b9de998d9269}{
\index{timestep.c@{timestep.c}!find\_\-dt\_\-displacement\_\-constraint@{find\_\-dt\_\-displacement\_\-constraint}}
\index{find\_\-dt\_\-displacement\_\-constraint@{find\_\-dt\_\-displacement\_\-constraint}!timestep.c@{timestep.c}}
\subsubsection[{find\_\-dt\_\-displacement\_\-constraint}]{\setlength{\rightskip}{0pt plus 5cm}void find\_\-dt\_\-displacement\_\-constraint (
\begin{DoxyParamCaption}
\item[{double}]{ hfac}
\end{DoxyParamCaption}
)}}
\label{timestep_8c_a78ed439b8a1cb93647a2b9de998d9269}
This function computes an upper limit ('dt\_\-displacement') to the global timestep of the system based on the rms velocities of particles. For cosmological simulations, the criterion used is that the rms displacement should be at most a fraction MaxRMSDisplacementFac of the mean particle separation. Note that the latter is estimated using the assigned particle masses, separately for each particle type. If comoving integration is not used, the function imposes no constraint on the timestep. 
\begin{DoxyParams}{Parameters}
\item[{\em hfac}]should be a$^\wedge$2$\ast$H(a) \end{DoxyParams}


Definition at line 566 of file timestep.c.



References All, global\_\-data\_\-all\_\-processes::Asmth, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, dt\_\-displacement, global\_\-data\_\-all\_\-processes::G, global\_\-data\_\-all\_\-processes::Hubble, global\_\-data\_\-all\_\-processes::MaxRMSDisplacementFac, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, NTask, NumPart, global\_\-data\_\-all\_\-processes::Omega0, global\_\-data\_\-all\_\-processes::OmegaBaryon, P, pow(), ThisTask, global\_\-data\_\-all\_\-processes::Time, and particle\_\-data::Type.



Referenced by advance\_\-and\_\-find\_\-timesteps().




\begin{DoxyCode}
{
  int i, j, type, *temp;
  int count[6];
  long long count_sum[6];
  double v[6], v_sum[6], mim[6], min_mass[6];
  double dt, dmean, asmth = 0;

  dt_displacement = All.MaxSizeTimestep;

  if(All.ComovingIntegrationOn)
    {
      for(type = 0; type < 6; type++)
        {
          count[type] = 0;
          v[type] = 0;
          mim[type] = 1.0e30;
        }

      for(i = 0; i < NumPart; i++)
        {
          v[P[i].Type] += P[i].Vel[0] * P[i].Vel[0] + P[i].Vel[1] * P[i].Vel[1] +
       P[i].Vel[2] * P[i].Vel[2];
          if(mim[P[i].Type] > P[i].Mass)
            mim[P[i].Type] = P[i].Mass;
          count[P[i].Type]++;
        }

      MPI_Allreduce(v, v_sum, 6, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
      MPI_Allreduce(mim, min_mass, 6, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

      temp = malloc(NTask * 6 * sizeof(int));
      MPI_Allgather(count, 6, MPI_INT, temp, 6, MPI_INT, MPI_COMM_WORLD);
      for(i = 0; i < 6; i++)
        {
          count_sum[i] = 0;
          for(j = 0; j < NTask; j++)
            count_sum[i] += temp[j * 6 + i];
        }
      free(temp);

      for(type = 0; type < 6; type++)
        {
          if(count_sum[type] > 0)
            {
              if(type == 0)
                dmean =
                  pow(min_mass[type] / (All.OmegaBaryon * 3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G)),
                      1.0 / 3);
              else
                dmean =
                  pow(min_mass[type] /
                      ((All.Omega0 - All.OmegaBaryon) * 3 * All.Hubble * All.
      Hubble / (8 * M_PI * All.G)),
                      1.0 / 3);

              dt = All.MaxRMSDisplacementFac * hfac * dmean / sqrt(v_sum[type] / 
      count_sum[type]);

#ifdef PMGRID
              asmth = All.Asmth[0];
#ifdef PLACEHIGHRESREGION
              if(((1 << type) & (PLACEHIGHRESREGION)))
                asmth = All.Asmth[1];
#endif
              if(asmth < dmean)
                dt = All.MaxRMSDisplacementFac * hfac * asmth / sqrt(v_sum[type] 
      / count_sum[type]);
#endif

              if(ThisTask == 0)
                printf("type=%d  dmean=%g asmth=%g minmass=%g a=%g  sqrt(<p^2>)=%
      g  dlogmax=%g\n",
                       type, dmean, asmth, min_mass[type], All.Time, sqrt(v_sum[t
      ype] / count_sum[type]), dt);

              if(dt < dt_displacement)
                dt_displacement = dt;
            }
        }

      if(ThisTask == 0)
        printf("displacement time constraint: %g  (%g)\n", dt_displacement, All.
      MaxSizeTimestep);
    }
}
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{timestep_8c_a78ed439b8a1cb93647a2b9de998d9269_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{timestep_8c_a78ed439b8a1cb93647a2b9de998d9269_icgraph}
\end{center}
\end{figure}


\hypertarget{timestep_8c_af48922752ff457721f558510789e61e1}{
\index{timestep.c@{timestep.c}!get\_\-timestep@{get\_\-timestep}}
\index{get\_\-timestep@{get\_\-timestep}!timestep.c@{timestep.c}}
\subsubsection[{get\_\-timestep}]{\setlength{\rightskip}{0pt plus 5cm}int get\_\-timestep (
\begin{DoxyParamCaption}
\item[{int}]{ p, }
\item[{double $\ast$}]{ aphys, }
\item[{int}]{ flag}
\end{DoxyParamCaption}
)}}
\label{timestep_8c_af48922752ff457721f558510789e61e1}
This function normally (for flag==0) returns the maximum allowed timestep of a particle, expressed in terms of the integer mapping that is used to represent the total simulated timespan. The physical acceleration is returned in `aphys'. The latter is used in conjunction with the PSEUDOSYMMETRIC integration option, which also makes of the second function of get\_\-timestep. When it is called with a finite timestep for flag, it returns the physical acceleration that would lead to this timestep, assuming timestep criterion 0. 

$<$ adiabatic index of simulated gas

$<$ The simulated timespan is mapped onto the integer interval \mbox{[}0,TIMESPAN\mbox{]}, $\ast$ where TIMESPAN needs to be a power of 2. Note that (1$<$$<$28) corresponds to 2$^\wedge$29 


\begin{DoxyParams}{Parameters}
\item[{\em p}]particle index \item[{\em aphys}]acceleration (physical units) \item[{\em flag}]either 0 for normal operation, or finite timestep to get corresponding aphys \end{DoxyParams}


Definition at line 423 of file timestep.c.



References All, atime, global\_\-data\_\-all\_\-processes::ComovingIntegrationOn, global\_\-data\_\-all\_\-processes::CourantFac, dt\_\-displacement, endrun(), global\_\-data\_\-all\_\-processes::ErrTolIntAccuracy, fac1, fac2, fac3, GAMMA, particle\_\-data::GravAccel, particle\_\-data::GravPM, sph\_\-particle\_\-data::Hsml, hubble\_\-a, sph\_\-particle\_\-data::HydroAccel, sph\_\-particle\_\-data::MaxSignalVel, global\_\-data\_\-all\_\-processes::MaxSizeTimestep, global\_\-data\_\-all\_\-processes::MinSizeTimestep, P, particle\_\-data::Pos, global\_\-data\_\-all\_\-processes::SofteningTable, SphP, ThisTask, global\_\-data\_\-all\_\-processes::Time, TIMEBASE, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, particle\_\-data::Type, and global\_\-data\_\-all\_\-processes::TypeOfTimestepCriterion.



Referenced by advance\_\-and\_\-find\_\-timesteps().




\begin{DoxyCode}
{
  double ax, ay, az, ac, csnd;
  double dt = 0, dt_courant = 0, dt_accel;
  int ti_step;

#ifdef CONDUCTION
  double dt_cond;
#endif

  if(flag == 0)
    {
      ax = fac1 * P[p].GravAccel[0];
      ay = fac1 * P[p].GravAccel[1];
      az = fac1 * P[p].GravAccel[2];

#ifdef PMGRID
      ax += fac1 * P[p].GravPM[0];
      ay += fac1 * P[p].GravPM[1];
      az += fac1 * P[p].GravPM[2];
#endif

      if(P[p].Type == 0)
        {
          ax += fac2 * SphP[p].HydroAccel[0];
          ay += fac2 * SphP[p].HydroAccel[1];
          az += fac2 * SphP[p].HydroAccel[2];
        }

      ac = sqrt(ax * ax + ay * ay + az * az);   /* this is now the physical accel
      eration */
      *aphys = ac;
    }
  else
    ac = *aphys;

  if(ac == 0)
    ac = 1.0e-30;

  switch (All.TypeOfTimestepCriterion)
    {
    case 0:
      if(flag > 0)
        {
          dt = flag * All.Timebase_interval;
          dt /= hubble_a;       /* convert dloga to physical timestep  */
          ac = 2 * All.ErrTolIntAccuracy * atime * All.SofteningTable[P[p].Type] 
      / (dt * dt);
          *aphys = ac;
          return flag;
        }
      dt = dt_accel = sqrt(2 * All.ErrTolIntAccuracy * atime * All.
      SofteningTable[P[p].Type] / ac);
#ifdef ADAPTIVE_GRAVSOFT_FORGAS
      if(P[p].Type == 0)
        dt = dt_accel = sqrt(2 * All.ErrTolIntAccuracy * atime * SphP[p].Hsml / 2
      .8 / ac);
#endif
      break;
    default:
      endrun(888);
      break;
    }

  if(P[p].Type == 0)
    {
      csnd = sqrt(GAMMA * SphP[p].Pressure / SphP[p].Density);

      if(All.ComovingIntegrationOn)
        dt_courant = 2 * All.CourantFac * All.Time * SphP[p].Hsml / (fac3 * SphP[
      p].MaxSignalVel);
      else
        dt_courant = 2 * All.CourantFac * SphP[p].Hsml / SphP[p].MaxSignalVel;

      if(dt_courant < dt)
        dt = dt_courant;
    }

  /* convert the physical timestep to dloga if needed. Note: If comoving integrat
      ion has not been selected,
     hubble_a=1.
   */
  dt *= hubble_a;

  if(dt >= All.MaxSizeTimestep)
    dt = All.MaxSizeTimestep;

  if(dt >= dt_displacement)
    dt = dt_displacement;

  if(dt < All.MinSizeTimestep)
    {
#ifndef NOSTOP_WHEN_BELOW_MINTIMESTEP
      printf("warning: Timestep wants to be below the limit `MinSizeTimestep'\n")
      ;

      if(P[p].Type == 0)
        {
          printf
            ("Part-ID=%d  dt=%g dtc=%g ac=%g xyz=(%g|%g|%g)  hsml=%g  maxsignalve
      l=%g dt0=%g eps=%g\n",
             (int) P[p].ID, dt, dt_courant * hubble_a, ac, P[p].Pos[0], P[p].Pos[
      1], P[p].Pos[2],
             SphP[p].Hsml, SphP[p].MaxSignalVel,
             sqrt(2 * All.ErrTolIntAccuracy * atime * All.SofteningTable[P[p].
      Type] / ac) * hubble_a,
             All.SofteningTable[P[p].Type]);
        }
      else
        {
          printf("Part-ID=%d  dt=%g ac=%g xyz=(%g|%g|%g)\n", (int) P[p].ID, dt, a
      c, P[p].Pos[0], P[p].Pos[1],
                 P[p].Pos[2]);
        }
      fflush(stdout);
      endrun(888);
#endif
      dt = All.MinSizeTimestep;
    }

  ti_step = dt / All.Timebase_interval;

  if(!(ti_step > 0 && ti_step < TIMEBASE))
    {
      printf("\nError: A timestep of size zero was assigned on the integer timeli
      ne!\n"
             "We better stop.\n"
             "Task=%d Part-ID=%d dt=%g tibase=%g ti_step=%d ac=%g xyz=(%g|%g|%g) 
      tree=(%g|%g%g)\n\n",
             ThisTask, (int) P[p].ID, dt, All.Timebase_interval, ti_step, ac,
             P[p].Pos[0], P[p].Pos[1], P[p].Pos[2], P[p].GravAccel[0], P[p].
      GravAccel[1], P[p].GravAccel[2]);
#ifdef PMGRID
      printf("pm_force=(%g|%g|%g)\n", P[p].GravPM[0], P[p].GravPM[1], P[p].GravPM
      [2]);
#endif
      if(P[p].Type == 0)
        printf("hydro-frc=(%g|%g|%g)\n", SphP[p].HydroAccel[0], SphP[p].HydroAcce
      l[1], SphP[p].HydroAccel[2]);

      fflush(stdout);
      endrun(818);
    }

  return ti_step;
}
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{timestep_8c_af48922752ff457721f558510789e61e1_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{timestep_8c_af48922752ff457721f558510789e61e1_icgraph}
\end{center}
\end{figure}




\subsection{Variable Documentation}
\hypertarget{timestep_8c_a7f2a6bb4bade30e4e04ee29be22d0962}{
\index{timestep.c@{timestep.c}!a3inv@{a3inv}}
\index{a3inv@{a3inv}!timestep.c@{timestep.c}}
\subsubsection[{a3inv}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf a3inv}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_a7f2a6bb4bade30e4e04ee29be22d0962}


Definition at line 13 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps().

\hypertarget{timestep_8c_aec7bcb1d46812f966d89f66dc1a399ea}{
\index{timestep.c@{timestep.c}!atime@{atime}}
\index{atime@{atime}!timestep.c@{timestep.c}}
\subsubsection[{atime}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf atime}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_aec7bcb1d46812f966d89f66dc1a399ea}


Definition at line 13 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), and get\_\-timestep().

\hypertarget{timestep_8c_aebcd2de4b9dfac8c2feb1594616f4803}{
\index{timestep.c@{timestep.c}!dt\_\-displacement@{dt\_\-displacement}}
\index{dt\_\-displacement@{dt\_\-displacement}!timestep.c@{timestep.c}}
\subsubsection[{dt\_\-displacement}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf dt\_\-displacement} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_aebcd2de4b9dfac8c2feb1594616f4803}


Definition at line 14 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), find\_\-dt\_\-displacement\_\-constraint(), and get\_\-timestep().

\hypertarget{timestep_8c_a59a20f8242197c1ba41f7a0b1b880d62}{
\index{timestep.c@{timestep.c}!fac1@{fac1}}
\index{fac1@{fac1}!timestep.c@{timestep.c}}
\subsubsection[{fac1}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf fac1}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_a59a20f8242197c1ba41f7a0b1b880d62}


Definition at line 13 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), fill\_\-write\_\-buffer(), get\_\-timestep(), and gravity\_\-forcetest().

\hypertarget{timestep_8c_a1a666a0983f6d540fa41ec867aa40d09}{
\index{timestep.c@{timestep.c}!fac2@{fac2}}
\index{fac2@{fac2}!timestep.c@{timestep.c}}
\subsubsection[{fac2}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf fac2}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_a1a666a0983f6d540fa41ec867aa40d09}


Definition at line 13 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), fill\_\-write\_\-buffer(), and get\_\-timestep().

\hypertarget{timestep_8c_aebe1da050ef46b7b63c856394494292c}{
\index{timestep.c@{timestep.c}!fac3@{fac3}}
\index{fac3@{fac3}!timestep.c@{timestep.c}}
\subsubsection[{fac3}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf fac3}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_aebe1da050ef46b7b63c856394494292c}


Definition at line 13 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), and get\_\-timestep().

\hypertarget{timestep_8c_abb7074f2e4b01309c6f2dc87bb3a1a40}{
\index{timestep.c@{timestep.c}!hubble\_\-a@{hubble\_\-a}}
\index{hubble\_\-a@{hubble\_\-a}!timestep.c@{timestep.c}}
\subsubsection[{hubble\_\-a}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf hubble\_\-a}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{timestep_8c_abb7074f2e4b01309c6f2dc87bb3a1a40}


Definition at line 13 of file timestep.c.



Referenced by advance\_\-and\_\-find\_\-timesteps(), and get\_\-timestep().

