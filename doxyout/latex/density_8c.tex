\hypertarget{density_8c}{
\section{density.c File Reference}
\label{density_8c}\index{density.c@{density.c}}
}


SPH density computation and smoothing length determination.  


{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$mpi.h$>$}\par
{\ttfamily \#include \char`\"{}allvars.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}proto.h\char`\"{}}\par
Include dependency graph for density.c:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{density_8c__incl}
\end{center}
\end{figure}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{density_8c_a5c5328b307b005e6682669279878cef0}{boxSize\_\-X}~\hyperlink{ngb_8c_ac9067960018a06b81c117434c01f19cc}{boxSize}
\item 
\#define \hyperlink{density_8c_a0ecceb71797a529fb6f2b8c47b51686c}{boxHalf\_\-X}~\hyperlink{ngb_8c_af62571c97dc75a691aeafead0528b369}{boxHalf}
\item 
\#define \hyperlink{density_8c_ab0db73a31e08d33d840e28651e3cf610}{boxSize\_\-Y}~\hyperlink{ngb_8c_ac9067960018a06b81c117434c01f19cc}{boxSize}
\item 
\#define \hyperlink{density_8c_a59f20d7decc2bdfedcaafb70ef23df0e}{boxHalf\_\-Y}~\hyperlink{ngb_8c_af62571c97dc75a691aeafead0528b369}{boxHalf}
\item 
\#define \hyperlink{density_8c_a8a97a1c456bdd396791c84c370f0aa18}{boxSize\_\-Z}~\hyperlink{ngb_8c_ac9067960018a06b81c117434c01f19cc}{boxSize}
\item 
\#define \hyperlink{density_8c_a34e9d5d079320cbfc0576d26f58d2fe7}{boxHalf\_\-Z}~\hyperlink{ngb_8c_af62571c97dc75a691aeafead0528b369}{boxHalf}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{density} (void)
\item 
void \hyperlink{density_8c_a4e6b32342a24a33518b6ae8723809749}{density\_\-evaluate} (int target, int mode)
\item 
int \hyperlink{density_8c_ab6453dd0ac2ecf2478b1208374e68ae1}{dens\_\-compare\_\-key} (const void $\ast$a, const void $\ast$b)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static double \hyperlink{density_8c_ac9067960018a06b81c117434c01f19cc}{boxSize}
\item 
static double \hyperlink{density_8c_af62571c97dc75a691aeafead0528b369}{boxHalf}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
SPH density computation and smoothing length determination. This file contains the \char`\"{}first SPH loop\char`\"{}, where the SPH densities and some auxiliary quantities are computed. If the number of neighbours obtained falls outside the target range, the correct smoothing length is determined iteratively, if needed. 

Definition in file \hyperlink{density_8c_source}{density.c}.



\subsection{Define Documentation}
\hypertarget{density_8c_a0ecceb71797a529fb6f2b8c47b51686c}{
\index{density.c@{density.c}!boxHalf\_\-X@{boxHalf\_\-X}}
\index{boxHalf\_\-X@{boxHalf\_\-X}!density.c@{density.c}}
\subsubsection[{boxHalf\_\-X}]{\setlength{\rightskip}{0pt plus 5cm}\#define boxHalf\_\-X~{\bf boxHalf}}}
\label{density_8c_a0ecceb71797a529fb6f2b8c47b51686c}


Definition at line 28 of file density.c.



Referenced by density(), and density\_\-evaluate().

\hypertarget{density_8c_a59f20d7decc2bdfedcaafb70ef23df0e}{
\index{density.c@{density.c}!boxHalf\_\-Y@{boxHalf\_\-Y}}
\index{boxHalf\_\-Y@{boxHalf\_\-Y}!density.c@{density.c}}
\subsubsection[{boxHalf\_\-Y}]{\setlength{\rightskip}{0pt plus 5cm}\#define boxHalf\_\-Y~{\bf boxHalf}}}
\label{density_8c_a59f20d7decc2bdfedcaafb70ef23df0e}


Definition at line 34 of file density.c.



Referenced by density(), and density\_\-evaluate().

\hypertarget{density_8c_a34e9d5d079320cbfc0576d26f58d2fe7}{
\index{density.c@{density.c}!boxHalf\_\-Z@{boxHalf\_\-Z}}
\index{boxHalf\_\-Z@{boxHalf\_\-Z}!density.c@{density.c}}
\subsubsection[{boxHalf\_\-Z}]{\setlength{\rightskip}{0pt plus 5cm}\#define boxHalf\_\-Z~{\bf boxHalf}}}
\label{density_8c_a34e9d5d079320cbfc0576d26f58d2fe7}


Definition at line 40 of file density.c.



Referenced by density(), and density\_\-evaluate().

\hypertarget{density_8c_a5c5328b307b005e6682669279878cef0}{
\index{density.c@{density.c}!boxSize\_\-X@{boxSize\_\-X}}
\index{boxSize\_\-X@{boxSize\_\-X}!density.c@{density.c}}
\subsubsection[{boxSize\_\-X}]{\setlength{\rightskip}{0pt plus 5cm}\#define boxSize\_\-X~{\bf boxSize}}}
\label{density_8c_a5c5328b307b005e6682669279878cef0}


Definition at line 27 of file density.c.



Referenced by density().

\hypertarget{density_8c_ab0db73a31e08d33d840e28651e3cf610}{
\index{density.c@{density.c}!boxSize\_\-Y@{boxSize\_\-Y}}
\index{boxSize\_\-Y@{boxSize\_\-Y}!density.c@{density.c}}
\subsubsection[{boxSize\_\-Y}]{\setlength{\rightskip}{0pt plus 5cm}\#define boxSize\_\-Y~{\bf boxSize}}}
\label{density_8c_ab0db73a31e08d33d840e28651e3cf610}


Definition at line 33 of file density.c.



Referenced by density().

\hypertarget{density_8c_a8a97a1c456bdd396791c84c370f0aa18}{
\index{density.c@{density.c}!boxSize\_\-Z@{boxSize\_\-Z}}
\index{boxSize\_\-Z@{boxSize\_\-Z}!density.c@{density.c}}
\subsubsection[{boxSize\_\-Z}]{\setlength{\rightskip}{0pt plus 5cm}\#define boxSize\_\-Z~{\bf boxSize}}}
\label{density_8c_a8a97a1c456bdd396791c84c370f0aa18}


Definition at line 39 of file density.c.



Referenced by density().



\subsection{Function Documentation}
\hypertarget{density_8c_ab6453dd0ac2ecf2478b1208374e68ae1}{
\index{density.c@{density.c}!dens\_\-compare\_\-key@{dens\_\-compare\_\-key}}
\index{dens\_\-compare\_\-key@{dens\_\-compare\_\-key}!density.c@{density.c}}
\subsubsection[{dens\_\-compare\_\-key}]{\setlength{\rightskip}{0pt plus 5cm}int dens\_\-compare\_\-key (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{ a, }
\item[{const void $\ast$}]{ b}
\end{DoxyParamCaption}
)}}
\label{density_8c_ab6453dd0ac2ecf2478b1208374e68ae1}
This routine is a comparison kernel used in a sort routine to group particles that are exported to the same processor. 

Definition at line 607 of file density.c.



Referenced by density().




\begin{DoxyCode}
{
  if(((struct densdata_in *) a)->Task < (((struct densdata_in *) b)->Task))
    return -1;

  if(((struct densdata_in *) a)->Task > (((struct densdata_in *) b)->Task))
    return +1;

  return 0;
}
\end{DoxyCode}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{density_8c_ab6453dd0ac2ecf2478b1208374e68ae1_icgraph}
\end{center}
\end{figure}


\hypertarget{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}{
\index{density.c@{density.c}!density@{density}}
\index{density@{density}!density.c@{density.c}}
\subsubsection[{density}]{\setlength{\rightskip}{0pt plus 5cm}void density (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c}
This function computes the local density for each active SPH particle, the number of neighbours in the current smoothing radius, and the divergence and curl of the velocity field. The pressure is updated as well. If a particle with its smoothing region is fully inside the local domain, it is not exported to the other processors. The function also detects particles that have a number of neighbours outside the allowed tolerance range. For these particles, the smoothing length is adjusted accordingly, and the density computation is executed again. Note that the smoothing length is not allowed to fall below the lower bound set by MinGasHsml. 

$<$ For 3D-\/normalized kernel

$<$ adiabatic index of simulated gas

$<$ maxmimum number of steps for SPH neighbour iteration

$<$ For 3D-\/normalized kernel

$<$ For 3D-\/normalized kernel

$<$ maxmimum number of steps for SPH neighbour iteration 



Definition at line 56 of file density.c.



References All, boxHalf, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, global\_\-data\_\-all\_\-processes::BoxSize, boxSize, boxSize\_\-X, boxSize\_\-Y, boxSize\_\-Z, global\_\-data\_\-all\_\-processes::BunchSizeDensity, global\_\-data\_\-all\_\-processes::CPU\_\-EnsureNgb, global\_\-data\_\-all\_\-processes::CPU\_\-HydCommSumm, global\_\-data\_\-all\_\-processes::CPU\_\-HydCompWalk, global\_\-data\_\-all\_\-processes::CPU\_\-HydImbalance, sph\_\-particle\_\-data::CurlVel, dens\_\-compare\_\-key(), DensDataGet, DensDataIn, DensDataPartialResult, DensDataResult, sph\_\-particle\_\-data::Density, density\_\-evaluate(), global\_\-data\_\-all\_\-processes::DesNumNgb, densdata\_\-out::DhsmlDensity, sph\_\-particle\_\-data::DhsmlDensityFactor, densdata\_\-out::Div, sph\_\-particle\_\-data::DivVel, dmax(), sph\_\-particle\_\-data::DtEntropy, endrun(), sph\_\-particle\_\-data::Entropy, Exportflag, GAMMA, sph\_\-particle\_\-data::Hsml, densdata\_\-in::Hsml, densdata\_\-in::Index, sph\_\-particle\_\-data::Left, MAXITER, global\_\-data\_\-all\_\-processes::MaxNumNgbDeviation, global\_\-data\_\-all\_\-processes::MinGasHsml, N\_\-gas, densdata\_\-out::Ngb, NTask, NUMDIMS, sph\_\-particle\_\-data::NumNgb, NumPart, NumSphUpdate, P, particle\_\-data::Pos, densdata\_\-in::Pos, pow(), sph\_\-particle\_\-data::Pressure, PTask, densdata\_\-out::Rho, sph\_\-particle\_\-data::Right, densdata\_\-out::Rot, sph\_\-particle\_\-data::Rot, second(), SphP, TAG\_\-DENS\_\-A, TAG\_\-DENS\_\-B, densdata\_\-in::Task, ThisTask, particle\_\-data::Ti\_\-begstep, global\_\-data\_\-all\_\-processes::Ti\_\-Current, particle\_\-data::Ti\_\-endstep, global\_\-data\_\-all\_\-processes::Timebase\_\-interval, timediff(), densdata\_\-in::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by compute\_\-accelerations(), and setup\_\-smoothinglengths().




\begin{DoxyCode}
{
  long long ntot, ntotleft;
  int *noffset, *nbuffer, *nsend, *nsend_local, *numlist, *ndonelist;
  int i, j, n, ndone, npleft, maxfill, source, iter = 0;
  int level, ngrp, sendTask, recvTask, place, nexport;
  double dt_entr, tstart, tend, tstart_ngb = 0, tend_ngb = 0;
  double sumt, sumcomm, timengb, sumtimengb;
  double timecomp = 0, timeimbalance = 0, timecommsumm = 0, sumimbalance;
  MPI_Status status;

#ifdef PERIODIC
  boxSize = All.BoxSize;
  boxHalf = 0.5 * All.BoxSize;
#ifdef LONG_X
  boxHalf_X = boxHalf * LONG_X;
  boxSize_X = boxSize * LONG_X;
#endif
#ifdef LONG_Y
  boxHalf_Y = boxHalf * LONG_Y;
  boxSize_Y = boxSize * LONG_Y;
#endif
#ifdef LONG_Z
  boxHalf_Z = boxHalf * LONG_Z;
  boxSize_Z = boxSize * LONG_Z;
#endif
#endif


  noffset = malloc(sizeof(int) * NTask);        /* offsets of bunches in common l
      ist */
  nbuffer = malloc(sizeof(int) * NTask);
  nsend_local = malloc(sizeof(int) * NTask);
  nsend = malloc(sizeof(int) * NTask * NTask);
  ndonelist = malloc(sizeof(int) * NTask);

  for(n = 0, NumSphUpdate = 0; n < N_gas; n++)
    {
      SphP[n].Left = SphP[n].Right = 0;

      if(P[n].Ti_endstep == All.Ti_Current)
        NumSphUpdate++;
    }

  numlist = malloc(NTask * sizeof(int) * NTask);
  MPI_Allgather(&NumSphUpdate, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
  for(i = 0, ntot = 0; i < NTask; i++)
    ntot += numlist[i];
  free(numlist);



  /* we will repeat the whole thing for those particles where we didn't
   * find enough neighbours
   */
  do
    {
      i = 0;                    /* beginn with this index */
      ntotleft = ntot;          /* particles left for all tasks together */

      while(ntotleft > 0)
        {
          for(j = 0; j < NTask; j++)
            nsend_local[j] = 0;

          /* do local particles and prepare export list */
          tstart = second();
          for(nexport = 0, ndone = 0; i < N_gas && nexport < All.
      BunchSizeDensity - NTask; i++)
            if(P[i].Ti_endstep == All.Ti_Current)
              {
                ndone++;

                for(j = 0; j < NTask; j++)
                  Exportflag[j] = 0;

                density_evaluate(i, 0);

                for(j = 0; j < NTask; j++)
                  {
                    if(Exportflag[j])
                      {
                        DensDataIn[nexport].Pos[0] = P[i].Pos[0];
                        DensDataIn[nexport].Pos[1] = P[i].Pos[1];
                        DensDataIn[nexport].Pos[2] = P[i].Pos[2];
                        DensDataIn[nexport].Vel[0] = SphP[i].VelPred[0];
                        DensDataIn[nexport].Vel[1] = SphP[i].VelPred[1];
                        DensDataIn[nexport].Vel[2] = SphP[i].VelPred[2];
                        DensDataIn[nexport].Hsml = SphP[i].Hsml;
                        DensDataIn[nexport].Index = i;
                        DensDataIn[nexport].Task = j;
                        nexport++;
                        nsend_local[j]++;
                      }
                  }
              }
          tend = second();
          timecomp += timediff(tstart, tend);

          qsort(DensDataIn, nexport, sizeof(struct densdata_in), 
      dens_compare_key);

          for(j = 1, noffset[0] = 0; j < NTask; j++)
            noffset[j] = noffset[j - 1] + nsend_local[j - 1];

          tstart = second();

          MPI_Allgather(nsend_local, NTask, MPI_INT, nsend, NTask, MPI_INT, MPI_C
      OMM_WORLD);

          tend = second();
          timeimbalance += timediff(tstart, tend);


          /* now do the particles that need to be exported */

          for(level = 1; level < (1 << PTask); level++)
            {
              tstart = second();
              for(j = 0; j < NTask; j++)
                nbuffer[j] = 0;
              for(ngrp = level; ngrp < (1 << PTask); ngrp++)
                {
                  maxfill = 0;
                  for(j = 0; j < NTask; j++)
                    {
                      if((j ^ ngrp) < NTask)
                        if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                          maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                    }
                  if(maxfill >= All.BunchSizeDensity)
                    break;

                  sendTask = ThisTask;
                  recvTask = ThisTask ^ ngrp;

                  if(recvTask < NTask)
                    {
                      if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask
       * NTask + ThisTask] > 0)
                        {
                          /* get the particles */
                          MPI_Sendrecv(&DensDataIn[noffset[recvTask]],
                                       nsend_local[recvTask] * sizeof(struct 
      densdata_in), MPI_BYTE,
                                       recvTask, TAG_DENS_A,
                                       &DensDataGet[nbuffer[ThisTask]],
                                       nsend[recvTask * NTask + ThisTask] * sizeo
      f(struct densdata_in),
                                       MPI_BYTE, recvTask, TAG_DENS_A, MPI_COMM_W
      ORLD, &status);
                        }
                    }

                  for(j = 0; j < NTask; j++)
                    if((j ^ ngrp) < NTask)
                      nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
                }
              tend = second();
              timecommsumm += timediff(tstart, tend);


              tstart = second();
              for(j = 0; j < nbuffer[ThisTask]; j++)
                density_evaluate(j, 1);
              tend = second();
              timecomp += timediff(tstart, tend);

              /* do a block to explicitly measure imbalance */
              tstart = second();
              MPI_Barrier(MPI_COMM_WORLD);
              tend = second();
              timeimbalance += timediff(tstart, tend);

              /* get the result */
              tstart = second();
              for(j = 0; j < NTask; j++)
                nbuffer[j] = 0;
              for(ngrp = level; ngrp < (1 << PTask); ngrp++)
                {
                  maxfill = 0;
                  for(j = 0; j < NTask; j++)
                    {
                      if((j ^ ngrp) < NTask)
                        if(maxfill < nbuffer[j] + nsend[(j ^ ngrp) * NTask + j])
                          maxfill = nbuffer[j] + nsend[(j ^ ngrp) * NTask + j];
                    }
                  if(maxfill >= All.BunchSizeDensity)
                    break;

                  sendTask = ThisTask;
                  recvTask = ThisTask ^ ngrp;

                  if(recvTask < NTask)
                    {
                      if(nsend[ThisTask * NTask + recvTask] > 0 || nsend[recvTask
       * NTask + ThisTask] > 0)
                        {
                          /* send the results */
                          MPI_Sendrecv(&DensDataResult[nbuffer[ThisTask]],
                                       nsend[recvTask * NTask + ThisTask] * sizeo
      f(struct densdata_out),
                                       MPI_BYTE, recvTask, TAG_DENS_B,
                                       &DensDataPartialResult[noffset[recvTask]],
      
                                       nsend_local[recvTask] * sizeof(struct 
      densdata_out),
                                       MPI_BYTE, recvTask, TAG_DENS_B, MPI_COMM_W
      ORLD, &status);

                          /* add the result to the particles */
                          for(j = 0; j < nsend_local[recvTask]; j++)
                            {
                              source = j + noffset[recvTask];
                              place = DensDataIn[source].Index;

                              SphP[place].NumNgb += DensDataPartialResult[source]
      .Ngb;
                              SphP[place].Density += DensDataPartialResult[source
      ].Rho;
                              SphP[place].DivVel += DensDataPartialResult[source]
      .Div;

                              SphP[place].DhsmlDensityFactor += 
      DensDataPartialResult[source].DhsmlDensity;

                              SphP[place].Rot[0] += DensDataPartialResult[source]
      .Rot[0];
                              SphP[place].Rot[1] += DensDataPartialResult[source]
      .Rot[1];
                              SphP[place].Rot[2] += DensDataPartialResult[source]
      .Rot[2];
                            }
                        }
                    }

                  for(j = 0; j < NTask; j++)
                    if((j ^ ngrp) < NTask)
                      nbuffer[j] += nsend[(j ^ ngrp) * NTask + j];
                }
              tend = second();
              timecommsumm += timediff(tstart, tend);

              level = ngrp - 1;
            }

          MPI_Allgather(&ndone, 1, MPI_INT, ndonelist, 1, MPI_INT, MPI_COMM_WORLD
      );
          for(j = 0; j < NTask; j++)
            ntotleft -= ndonelist[j];
        }



      /* do final operations on results */
      tstart = second();
      for(i = 0, npleft = 0; i < N_gas; i++)
        {
          if(P[i].Ti_endstep == All.Ti_Current)
            {
              {
                SphP[i].DhsmlDensityFactor =
                  1 / (1 + SphP[i].Hsml * SphP[i].DhsmlDensityFactor / (NUMDIMS *
       SphP[i].Density));

                SphP[i].CurlVel = sqrt(SphP[i].Rot[0] * SphP[i].Rot[0] +
                                       SphP[i].Rot[1] * SphP[i].Rot[1] +
                                       SphP[i].Rot[2] * SphP[i].Rot[2]) / SphP[i]
      .Density;

                SphP[i].DivVel /= SphP[i].Density;

                dt_entr = (All.Ti_Current - (P[i].Ti_begstep + P[i].Ti_endstep) /
       2) * All.Timebase_interval;

                SphP[i].Pressure =
                  (SphP[i].Entropy + SphP[i].DtEntropy * dt_entr) * pow(SphP[i].D
      ensity, GAMMA);
              }


              /* now check whether we had enough neighbours */

              if(SphP[i].NumNgb < (All.DesNumNgb - All.MaxNumNgbDeviation) ||
                 (SphP[i].NumNgb > (All.DesNumNgb + All.MaxNumNgbDeviation)
                  && SphP[i].Hsml > (1.01 * All.MinGasHsml)))
                {
                  /* need to redo this particle */
                  npleft++;

                  if(SphP[i].Left > 0 && SphP[i].Right > 0)
                    if((SphP[i].Right - SphP[i].Left) < 1.0e-3 * SphP[i].Left)
                      {
                        /* this one should be ok */
                        npleft--;
                        P[i].Ti_endstep = -P[i].Ti_endstep - 1; /* Mark as inacti
      ve */
                        continue;
                      }

                  if(SphP[i].NumNgb < (All.DesNumNgb - All.MaxNumNgbDeviation))
                    SphP[i].Left = dmax(SphP[i].Hsml, SphP[i].Left);
                  else
                    {
                      if(SphP[i].Right != 0)
                        {
                          if(SphP[i].Hsml < SphP[i].Right)
                            SphP[i].Right = SphP[i].Hsml;
                        }
                      else
                        SphP[i].Right = SphP[i].Hsml;
                    }

                  if(iter >= MAXITER - 10)
                    {
                      printf
                        ("i=%d task=%d ID=%d Hsml=%g Left=%g Right=%g Ngbs=%g Rig
      ht-Left=%g\n   pos=(%g|%g|%g)\n",
                         i, ThisTask, (int) P[i].ID, SphP[i].Hsml, SphP[i].Left, 
      SphP[i].Right,
                         (float) SphP[i].NumNgb, SphP[i].Right - SphP[i].Left, P[
      i].Pos[0], P[i].Pos[1],
                         P[i].Pos[2]);
                      fflush(stdout);
                    }

                  if(SphP[i].Right > 0 && SphP[i].Left > 0)
                    SphP[i].Hsml = pow(0.5 * (pow(SphP[i].Left, 3) + pow(SphP[i].
      Right, 3)), 1.0 / 3);
                  else
                    {
                      if(SphP[i].Right == 0 && SphP[i].Left == 0)
                        endrun(8188);   /* can't occur */

                      if(SphP[i].Right == 0 && SphP[i].Left > 0)
                        {
                          if(P[i].Type == 0 && fabs(SphP[i].NumNgb - All.
      DesNumNgb) < 0.5 * All.DesNumNgb)
                            {
                              SphP[i].Hsml *=
                                1 - (SphP[i].NumNgb -
                                     All.DesNumNgb) / (NUMDIMS * SphP[i].NumNgb) 
      * SphP[i].DhsmlDensityFactor;
                            }
                          else
                            SphP[i].Hsml *= 1.26;
                        }

                      if(SphP[i].Right > 0 && SphP[i].Left == 0)
                        {
                          if(P[i].Type == 0 && fabs(SphP[i].NumNgb - All.
      DesNumNgb) < 0.5 * All.DesNumNgb)
                            {
                              SphP[i].Hsml *=
                                1 - (SphP[i].NumNgb -
                                     All.DesNumNgb) / (NUMDIMS * SphP[i].NumNgb) 
      * SphP[i].DhsmlDensityFactor;
                            }
                          else
                            SphP[i].Hsml /= 1.26;
                        }
                    }

                  if(SphP[i].Hsml < All.MinGasHsml)
                    SphP[i].Hsml = All.MinGasHsml;
                }
              else
                P[i].Ti_endstep = -P[i].Ti_endstep - 1; /* Mark as inactive */
            }
        }
      tend = second();
      timecomp += timediff(tstart, tend);


      numlist = malloc(NTask * sizeof(int) * NTask);
      MPI_Allgather(&npleft, 1, MPI_INT, numlist, 1, MPI_INT, MPI_COMM_WORLD);
      for(i = 0, ntot = 0; i < NTask; i++)
        ntot += numlist[i];
      free(numlist);

      if(ntot > 0)
        {
          if(iter == 0)
            tstart_ngb = second();

          iter++;

          if(iter > 0 && ThisTask == 0)
            {
              printf("ngb iteration %d: need to repeat for %d%09d particles.\n", 
      iter,
                     (int) (ntot / 1000000000), (int) (ntot % 1000000000));
              fflush(stdout);
            }

          if(iter > MAXITER)
            {
              printf("failed to converge in neighbour iteration in density()\n");
      
              fflush(stdout);
              endrun(1155);
            }
        }
      else
        tend_ngb = second();
    }
  while(ntot > 0);


  /* mark as active again */
  for(i = 0; i < NumPart; i++)
    if(P[i].Ti_endstep < 0)
      P[i].Ti_endstep = -P[i].Ti_endstep - 1;

  free(ndonelist);
  free(nsend);
  free(nsend_local);
  free(nbuffer);
  free(noffset);


  /* collect some timing information */
  if(iter > 0)
    timengb = timediff(tstart_ngb, tend_ngb);
  else
    timengb = 0;

  MPI_Reduce(&timengb, &sumtimengb, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecomp, &sumt, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&timecommsumm, &sumcomm, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
      
  MPI_Reduce(&timeimbalance, &sumimbalance, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_W
      ORLD);

  if(ThisTask == 0)
    {
      All.CPU_HydCompWalk += sumt / NTask;
      All.CPU_HydCommSumm += sumcomm / NTask;
      All.CPU_HydImbalance += sumimbalance / NTask;
      All.CPU_EnsureNgb += sumtimengb / NTask;
    }
}
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{density_8c_ad86cdeb9e3bfbe9af379ac9f7daf194c_icgraph}
\end{center}
\end{figure}


\hypertarget{density_8c_a4e6b32342a24a33518b6ae8723809749}{
\index{density.c@{density.c}!density\_\-evaluate@{density\_\-evaluate}}
\index{density\_\-evaluate@{density\_\-evaluate}!density.c@{density.c}}
\subsubsection[{density\_\-evaluate}]{\setlength{\rightskip}{0pt plus 5cm}void density\_\-evaluate (
\begin{DoxyParamCaption}
\item[{int}]{ target, }
\item[{int}]{ mode}
\end{DoxyParamCaption}
)}}
\label{density_8c_a4e6b32342a24a33518b6ae8723809749}
This function represents the core of the SPH density computation. The target particle may either be local, or reside in the communication buffer. 

$<$ Coefficients for SPH spline kernel and its derivative

$<$ Coefficient for kernel normalization. Note: 4.0/3 $\ast$ PI = 4.188790204786

$<$ For 3D-\/normalized kernel 



Definition at line 467 of file density.c.



References All, boxHalf\_\-X, boxHalf\_\-Y, boxHalf\_\-Z, DensDataGet, DensDataResult, sph\_\-particle\_\-data::Density, densdata\_\-out::DhsmlDensity, sph\_\-particle\_\-data::DhsmlDensityFactor, densdata\_\-out::Div, sph\_\-particle\_\-data::DivVel, FLOAT, densdata\_\-in::Hsml, sph\_\-particle\_\-data::Hsml, KERNEL\_\-COEFF\_\-1, KERNEL\_\-COEFF\_\-2, KERNEL\_\-COEFF\_\-3, KERNEL\_\-COEFF\_\-5, KERNEL\_\-COEFF\_\-6, particle\_\-data::Mass, global\_\-data\_\-all\_\-processes::MaxPart, densdata\_\-out::Ngb, ngb\_\-treefind\_\-variable(), Ngblist, NORM\_\-COEFF, NUMDIMS, sph\_\-particle\_\-data::NumNgb, P, densdata\_\-in::Pos, particle\_\-data::Pos, densdata\_\-out::Rho, densdata\_\-out::Rot, sph\_\-particle\_\-data::Rot, SphP, densdata\_\-in::Vel, and sph\_\-particle\_\-data::VelPred.



Referenced by density().




\begin{DoxyCode}
{
  int j, n, startnode, numngb, numngb_inbox;
  double h, h2, fac, hinv, hinv3, hinv4;
  double rho, divv, wk, dwk;
  double dx, dy, dz, r, r2, u, mass_j;
  double dvx, dvy, dvz, rotv[3];
  double weighted_numngb, dhsmlrho;
  FLOAT *pos, *vel;

  if(mode == 0)
    {
      pos = P[target].Pos;
      vel = SphP[target].VelPred;
      h = SphP[target].Hsml;
    }
  else
    {
      pos = DensDataGet[target].Pos;
      vel = DensDataGet[target].Vel;
      h = DensDataGet[target].Hsml;
    }

  h2 = h * h;
  hinv = 1.0 / h;
#ifndef  TWODIMS
  hinv3 = hinv * hinv * hinv;
#else
  hinv3 = hinv * hinv / boxSize_Z;
#endif
  hinv4 = hinv3 * hinv;

  rho = divv = rotv[0] = rotv[1] = rotv[2] = 0;
  weighted_numngb = 0;
  dhsmlrho = 0;

  startnode = All.MaxPart;
  numngb = 0;
  do
    {
      numngb_inbox = ngb_treefind_variable(&pos[0], h, &startnode);

      for(n = 0; n < numngb_inbox; n++)
        {
          j = Ngblist[n];

          dx = pos[0] - P[j].Pos[0];
          dy = pos[1] - P[j].Pos[1];
          dz = pos[2] - P[j].Pos[2];

#ifdef PERIODIC                 /*  now find the closest image in the given box s
      ize  */
          if(dx > boxHalf_X)
            dx -= boxSize_X;
          if(dx < -boxHalf_X)
            dx += boxSize_X;
          if(dy > boxHalf_Y)
            dy -= boxSize_Y;
          if(dy < -boxHalf_Y)
            dy += boxSize_Y;
          if(dz > boxHalf_Z)
            dz -= boxSize_Z;
          if(dz < -boxHalf_Z)
            dz += boxSize_Z;
#endif
          r2 = dx * dx + dy * dy + dz * dz;

          if(r2 < h2)
            {
              numngb++;

              r = sqrt(r2);

              u = r * hinv;

              if(u < 0.5)
                {
                  wk = hinv3 * (KERNEL_COEFF_1 + KERNEL_COEFF_2 * (u - 1) * u * u
      );
                  dwk = hinv4 * u * (KERNEL_COEFF_3 * u - KERNEL_COEFF_4);
                }
              else
                {
                  wk = hinv3 * KERNEL_COEFF_5 * (1.0 - u) * (1.0 - u) * (1.0 - u)
      ;
                  dwk = hinv4 * KERNEL_COEFF_6 * (1.0 - u) * (1.0 - u);
                }

              mass_j = P[j].Mass;

              rho += mass_j * wk;

              weighted_numngb += NORM_COEFF * wk / hinv3;

              dhsmlrho += -mass_j * (NUMDIMS * hinv * wk + u * dwk);

              if(r > 0)
                {
                  fac = mass_j * dwk / r;

                  dvx = vel[0] - SphP[j].VelPred[0];
                  dvy = vel[1] - SphP[j].VelPred[1];
                  dvz = vel[2] - SphP[j].VelPred[2];

                  divv -= fac * (dx * dvx + dy * dvy + dz * dvz);

                  rotv[0] += fac * (dz * dvy - dy * dvz);
                  rotv[1] += fac * (dx * dvz - dz * dvx);
                  rotv[2] += fac * (dy * dvx - dx * dvy);
                }
            }
        }
    }
  while(startnode >= 0);

  if(mode == 0)
    {
      SphP[target].NumNgb = weighted_numngb;
      SphP[target].Density = rho;
      SphP[target].DivVel = divv;
      SphP[target].DhsmlDensityFactor = dhsmlrho;
      SphP[target].Rot[0] = rotv[0];
      SphP[target].Rot[1] = rotv[1];
      SphP[target].Rot[2] = rotv[2];
    }
  else
    {
      DensDataResult[target].Rho = rho;
      DensDataResult[target].Div = divv;
      DensDataResult[target].Ngb = weighted_numngb;
      DensDataResult[target].DhsmlDensity = dhsmlrho;
      DensDataResult[target].Rot[0] = rotv[0];
      DensDataResult[target].Rot[1] = rotv[1];
      DensDataResult[target].Rot[2] = rotv[2];
    }
}
\end{DoxyCode}




Here is the call graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{density_8c_a4e6b32342a24a33518b6ae8723809749_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{density_8c_a4e6b32342a24a33518b6ae8723809749_icgraph}
\end{center}
\end{figure}




\subsection{Variable Documentation}
\hypertarget{density_8c_af62571c97dc75a691aeafead0528b369}{
\index{density.c@{density.c}!boxHalf@{boxHalf}}
\index{boxHalf@{boxHalf}!density.c@{density.c}}
\subsubsection[{boxHalf}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf boxHalf}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{density_8c_af62571c97dc75a691aeafead0528b369}


Definition at line 22 of file density.c.



Referenced by density().

\hypertarget{density_8c_ac9067960018a06b81c117434c01f19cc}{
\index{density.c@{density.c}!boxSize@{boxSize}}
\index{boxSize@{boxSize}!density.c@{density.c}}
\subsubsection[{boxSize}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf boxSize}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{density_8c_ac9067960018a06b81c117434c01f19cc}


Definition at line 22 of file density.c.



Referenced by density(), and fill\_\-write\_\-buffer().

